      SUBROUTINE G05FDF(A,B,N,X)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C     MARK 16A REVISED. IER-1038 (JUN 1993).
C
C     Returns a vector of N pseudo-random numbers from a normal
C     distribution with mean A and standard deviation B.
C
C     Pseudo-random numbers are generated by the auxiliary routine
C     G05CAY, 63 at a time, and stored in the array RV in common block
C     CG05CA. G05FDF copies numbers from RV to X, using the Box-Muller
C     method to transform to the normal distribution two at a time,
C     and calling G05CAY to replenish RV when necessary.
C
C     A call of G05FDF does *not* return the same sequence of
C     pseudo-random numbers as N consecutive calls to G05DDF,
C     because G05DDF uses a different transformation (Brent's method).
C     G05FDF uses the Box-Muller method because it is more amenable
C     to vectorization.
C
C     Jeremy Du Croz, NAG Ltd, May 1989.
C
C     .. Parameters ..
      INTEGER           LV
      PARAMETER         (LV=63)
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, B
      INTEGER           N
C     .. Array Arguments ..
      DOUBLE PRECISION  X(N)
C     .. Scalars in Common ..
      DOUBLE PRECISION  VNORML
      INTEGER           KV
C     .. Arrays in Common ..
      DOUBLE PRECISION  RV(LV)
C     .. Local Scalars ..
      DOUBLE PRECISION  T1, T2, TWOPI
      INTEGER           I, I1, I2, IV
      LOGICAL           INIT
C     .. External Functions ..
      DOUBLE PRECISION  X01AAF
      EXTERNAL          X01AAF
C     .. External Subroutines ..
      EXTERNAL          G05CAY, G05CAZ
C     .. Intrinsic Functions ..
      INTRINSIC         COS, LOG, MIN, SIN, SQRT
C     .. Common blocks ..
      COMMON            /CG05CA/RV, KV
c$OMP THREADPRIVATE(/CG05CA/)
      COMMON            /DG05CA/VNORML
c$OMP THREADPRIVATE(/DG05CA/)
C     .. Save statement ..
      SAVE              /CG05CA/, /DG05CA/, INIT, TWOPI
C     .. Data statements ..
      DATA              INIT/.TRUE./
C     .. Executable Statements ..
      IF (N.LE.0) RETURN
C
C     Ensure that the basic generator has been initialized
C
      IF (INIT) THEN
         CALL G05CAZ(INIT)
         TWOPI = 2*X01AAF(TWOPI)
      END IF
C
C     Replenish the buffer if necessary
C
      IF (KV.GE.LV) CALL G05CAY(.FALSE.)
C
C     Fill the array X in segments: I1 and I2 are indices of first and
C     last elements in current segment
C
      I1 = 1
      I2 = -KV
      IF (VNORML.NE.256.0D0) I2 = I2 + 1
   20 CONTINUE
C
C     The value 256.0 is used to indicate that no useful value is saved
C     in VNORML. A useful value of T1*SIN(T2) must be bounded in
C     absolute value by sqrt(120*log(2)) = 9.12... .
C
      IF (VNORML.NE.256.0D0) THEN
C
C        Use the value saved in VNORML to generate one value
C
         X(I1) = A + B*VNORML
         VNORML = 256.0D0
         I1 = I1 + 1
      END IF
      I2 = MIN(I2+LV,N)
      IV = KV - I1 + 1
C
C     Generate values for the current segment of X in pairs.
C     This loop should be vectorizable; its length is at most LV.
C
CDIR$ SHORTLOOP
      DO 40 I = I1, I2 - 1, 2
         T1 = SQRT(-2*LOG(RV(I+IV)))
         T2 = TWOPI*RV(I+IV+1)
         X(I) = A + B*T1*COS(T2)
         X(I+1) = A + B*T1*SIN(T2)
   40 CONTINUE
      KV = KV + I - I1
C
      IF (I.EQ.I2) THEN
C
C        Generate first element of a pair to fill the current segment
C        of X; save the unused value of T1*SIN(T2) in VNORML.
C
         KV = KV + 1
         T1 = SQRT(-2*LOG(RV(KV)))
C
C        Replenish buffer if necessary
C
         IF (KV.GE.LV) CALL G05CAY(.FALSE.)
         KV = KV + 1
         T2 = TWOPI*RV(KV)
         X(I2) = A + B*T1*COS(T2)
         VNORML = T1*SIN(T2)
      ELSE
C
C        Replenish buffer if necessary and set VNORML to indicate that
C        no useful value is saved
C
         IF (KV.GE.LV) CALL G05CAY(.FALSE.)
         VNORML = 256.0D0
      END IF
C
      IF (I2.GE.N) RETURN
C
C     Go back to generate next segment
C
      I1 = I2 + 1
      GO TO 20
      END
      SUBROUTINE C06FPQ(M,N,INIT,TRIG,Q,NQ,IERROR)
CVD$R NOVECTOR
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     MARK 18 REVISED (THREAD SAFETY). (SEP 1996).
C     .. Scalar Arguments ..
      INTEGER           IERROR, M, N, NQ
      CHARACTER*1       INIT
C     .. Array Arguments ..
      DOUBLE PRECISION  TRIG(2*N)
      INTEGER           Q(30)
C     .. External Subroutines ..
      EXTERNAL          C06FPY, C06FPZ
C     .. Intrinsic Functions ..
      INTRINSIC         NINT
C     .. Executable Statements ..
      IERROR = 0
C
      IF (M.LT.1) THEN
         IERROR = 1
         RETURN
      ELSE IF (N.LT.1) THEN
         IERROR = 2
         RETURN
      END IF
      IF (INIT.NE.'I' .AND. INIT.NE.'i' .AND. INIT.NE.'S' .AND. INIT.NE.
     *    's' .AND. INIT.NE.'R' .AND. INIT.NE.'r') THEN
         IERROR = 3
         RETURN
      END IF
      IF (INIT.EQ.'S' .OR. INIT.EQ.'s') THEN
         IF (NINT(TRIG(N)).NE.N .OR. NINT(TRIG(2*N)).NE.N) THEN
            IERROR = 5
            RETURN
         END IF
      END IF
      IF (INIT.EQ.'R' .OR. INIT.EQ.'r') THEN
         IF (NINT(TRIG(N)).NE.N .OR. NINT(TRIG(2*N)).NE.N) THEN
            IERROR = 5
            RETURN
         END IF
      END IF
      CALL C06FPZ(N,NQ,Q)
      IF (INIT.EQ.'I' .OR. INIT.EQ.'i') THEN
         CALL C06FPY(N,NQ,Q,TRIG(1),TRIG(N+1))
      END IF
      NCHECK = N
      RETURN
      END
      SUBROUTINE C06FPY(N,NQ,Q,COSINE,SINE)
CVD$R VECTOR
CVD$R NOLSTVAL
CVD$R STRIP
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     Trig function initialisation subroutine
C
C     .. Scalar Arguments ..
      INTEGER           N, NQ
C     .. Array Arguments ..
      DOUBLE PRECISION  COSINE(0:N-1), SINE(0:N-1)
      INTEGER           Q(NQ)
C     .. Local Scalars ..
      DOUBLE PRECISION  TWOPI, Z
      INTEGER           I, J, K, L, L1, QI, R
C     .. External Functions ..
      DOUBLE PRECISION  X01AAF
      EXTERNAL          X01AAF
C     .. Intrinsic Functions ..
      INTRINSIC         COS, SIN, DBLE
C     .. Executable Statements ..
      TWOPI = 2.0D0*X01AAF(0.0D0)
      Z = TWOPI/DBLE(N)
C
      R = N
      L = 0
C
      DO 80 I = 1, NQ
         QI = Q(I)
         R = R/QI
         L1 = L
         DO 40 J = 1, QI - 1
            DO 20 K = 0, R - 1
               COSINE(L) = Z*DBLE(J*K)
               L = L + 1
   20       CONTINUE
   40    CONTINUE
         IF (QI.GE.7) THEN
            L = L1
            DO 60 J = 1, QI - 1
               COSINE(L) = Z*J*R
               L = L + R
   60       CONTINUE
         END IF
         Z = Z*QI
   80 CONTINUE
C
      DO 100 I = 0, N - 2
         SINE(I) = -SIN(COSINE(I))
         COSINE(I) = COS(COSINE(I))
  100 CONTINUE
C
C     Check on consistency of N and TRIG array --
C
      COSINE(N-1) = DBLE(N)
      SINE(N-1) = DBLE(N)
C
      RETURN
      END
      SUBROUTINE C06FPZ(N,NQ,Q)
CVD$R NOVECTOR
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     .. Scalar Arguments ..
      INTEGER           N, NQ
C     .. Array Arguments ..
      INTEGER           Q(30)
C     .. Local Scalars ..
      INTEGER           I, K, L, NN
C     .. Intrinsic Functions ..
      INTRINSIC         MOD
C     .. Executable Statements ..
      NN = N
      K = 0
C
C     Trap the special case N = 1
C
      IF (N.EQ.1) THEN
         NQ = 1
         Q(1) = 1
         RETURN
      END IF
C
C     Factors of 6 --
C
   20 IF (MOD(NN,6).NE.0) GO TO 40
      K = K + 1
      Q(K) = 6
      NN = NN/6
      IF (NN.EQ.1) GO TO 160
      GO TO 20
C
C     Factors of 4 --
C
   40 IF (MOD(NN,4).NE.0) GO TO 60
      K = K + 1
      Q(K) = 4
      NN = NN/4
      IF (NN.EQ.1) GO TO 160
      GO TO 40
C
C     Factors of 2 --
C
   60 IF (MOD(NN,2).NE.0) GO TO 80
      K = K + 1
      Q(K) = 2
      NN = NN/2
      IF (NN.EQ.1) GO TO 160
      GO TO 60
C
C     Factors of 3 --
C
   80 IF (MOD(NN,3).NE.0) GO TO 100
      K = K + 1
      Q(K) = 3
      NN = NN/3
      IF (NN.EQ.1) GO TO 160
      GO TO 80
C
C     Remaining odd factors --
C
  100 L = 5
      I = 2
C
C     I is alternatively 2 or 4 --
C
  120 IF (MOD(NN,L).NE.0) GO TO 140
      K = K + 1
      Q(K) = L
      NN = NN/L
      IF (NN.EQ.1) GO TO 160
      GO TO 120
  140 L = L + I
      I = 6 - I
      GO TO 120
  160 NQ = K
C
      RETURN
      END
      SUBROUTINE C06FRR(X,Y,BR,BI,P,Q,R,COSINE,SINE)
C     MARK 15 RE-ISSUE. NAG COPYRIGHT 1991.
C
C     Multiple complex Fourier transform kernel
C     Odd factors greater than 6
C
C     Self-sorting, decimation in frequency (Singleton's method)
C
C     .. Scalar Arguments ..
      INTEGER           P, Q, R
C     .. Array Arguments ..
      DOUBLE PRECISION  BI(0:P-1,0:Q-1,0:R-1), BR(0:P-1,0:Q-1,0:R-1),
     *                  COSINE(0:R-1,1:Q-1), SINE(0:R-1,1:Q-1),
     *                  X(0:P-1,0:R-1,0:Q-1), Y(0:P-1,0:R-1,0:Q-1)
C     .. Local Scalars ..
      DOUBLE PRECISION  TEMP1, TEMPI, TEMPR
      INTEGER           I, INDX, J, K, L, M, Q2
C     .. Intrinsic Functions ..
      INTRINSIC         MOD
C     .. Executable Statements ..
C
      Q2 = (Q-1)/2
      IF (R.GT.P) THEN
C
         DO 280 I = 0, P - 1
            DO 40 J = 1, Q2
               DO 20 K = 0, R - 1
                  TEMPR = X(I,K,J)
                  TEMPI = Y(I,K,J)
                  X(I,K,J) = TEMPR + X(I,K,Q-J)
                  Y(I,K,J) = TEMPI + Y(I,K,Q-J)
                  X(I,K,Q-J) = TEMPR - X(I,K,Q-J)
                  Y(I,K,Q-J) = TEMPI - Y(I,K,Q-J)
   20          CONTINUE
   40       CONTINUE
            DO 120 L = 1, Q2
               DO 60 K = 0, R - 1
                  BR(I,L,K) = X(I,K,0)
                  BI(I,L,K) = Y(I,K,0)
                  BR(I,Q-L,K) = 0.0D0
                  BI(I,Q-L,K) = 0.0D0
   60          CONTINUE
               DO 100 M = 1, Q2
                  INDX = MOD(L*M,Q)
                  DO 80 K = 0, R - 1
                     BR(I,L,K) = BR(I,L,K) + X(I,K,M)*COSINE(0,INDX)
                     BI(I,L,K) = BI(I,L,K) + Y(I,K,M)*COSINE(0,INDX)
                     BR(I,Q-L,K) = BR(I,Q-L,K) + X(I,K,Q-M)*SINE(0,INDX)
                     BI(I,Q-L,K) = BI(I,Q-L,K) + Y(I,K,Q-M)*SINE(0,INDX)
   80             CONTINUE
  100          CONTINUE
  120       CONTINUE
            DO 140 K = 0, R - 1
               BR(I,0,K) = X(I,K,0)
               BI(I,0,K) = Y(I,K,0)
  140       CONTINUE
            DO 180 L = 1, Q2
               DO 160 K = 0, R - 1
                  BR(I,0,K) = BR(I,0,K) + X(I,K,L)
                  BI(I,0,K) = BI(I,0,K) + Y(I,K,L)
  160          CONTINUE
  180       CONTINUE
            DO 220 L = 1, Q2
               DO 200 K = 0, R - 1
                  TEMPR = BR(I,L,K)
                  TEMPI = BI(I,L,K)
                  BR(I,L,K) = TEMPR - BI(I,Q-L,K)
                  BI(I,L,K) = TEMPI + BR(I,Q-L,K)
                  TEMP1 = BR(I,Q-L,K)
                  BR(I,Q-L,K) = TEMPR + BI(I,Q-L,K)
                  BI(I,Q-L,K) = TEMPI - TEMP1
  200          CONTINUE
  220       CONTINUE
            DO 260 L = 1, Q - 1
               DO 240 K = 1, R - 1
                  TEMPR = BR(I,L,K)
                  TEMPI = BI(I,L,K)
                  BR(I,L,K) = COSINE(K,L)*TEMPR - SINE(K,L)*TEMPI
                  BI(I,L,K) = COSINE(K,L)*TEMPI + SINE(K,L)*TEMPR
  240          CONTINUE
  260       CONTINUE
  280    CONTINUE
C
      ELSE
C
         DO 520 K = 0, R - 1
            DO 320 J = 1, Q2
               DO 300 I = 0, P - 1
                  TEMPR = X(I,K,J)
                  TEMPI = Y(I,K,J)
                  X(I,K,J) = TEMPR + X(I,K,Q-J)
                  Y(I,K,J) = TEMPI + Y(I,K,Q-J)
                  X(I,K,Q-J) = TEMPR - X(I,K,Q-J)
                  Y(I,K,Q-J) = TEMPI - Y(I,K,Q-J)
  300          CONTINUE
  320       CONTINUE
            DO 400 L = 1, Q2
               DO 340 I = 0, P - 1
                  BR(I,L,K) = X(I,K,0)
                  BI(I,L,K) = Y(I,K,0)
                  BR(I,Q-L,K) = 0.0D0
                  BI(I,Q-L,K) = 0.0D0
  340          CONTINUE
               DO 380 M = 1, Q2
                  INDX = MOD(L*M,Q)
                  DO 360 I = 0, P - 1
                     BR(I,L,K) = BR(I,L,K) + X(I,K,M)*COSINE(0,INDX)
                     BI(I,L,K) = BI(I,L,K) + Y(I,K,M)*COSINE(0,INDX)
                     BR(I,Q-L,K) = BR(I,Q-L,K) + X(I,K,Q-M)*SINE(0,INDX)
                     BI(I,Q-L,K) = BI(I,Q-L,K) + Y(I,K,Q-M)*SINE(0,INDX)
  360             CONTINUE
  380          CONTINUE
  400       CONTINUE
            DO 420 I = 0, P - 1
               BR(I,0,K) = X(I,K,0)
               BI(I,0,K) = Y(I,K,0)
  420       CONTINUE
            DO 460 L = 1, Q2
               DO 440 I = 0, P - 1
                  BR(I,0,K) = BR(I,0,K) + X(I,K,L)
                  BI(I,0,K) = BI(I,0,K) + Y(I,K,L)
  440          CONTINUE
  460       CONTINUE
            DO 500 L = 1, Q2
               DO 480 I = 0, P - 1
                  TEMPR = BR(I,L,K)
                  TEMPI = BI(I,L,K)
                  BR(I,L,K) = TEMPR - BI(I,Q-L,K)
                  BI(I,L,K) = TEMPI + BR(I,Q-L,K)
                  TEMP1 = BR(I,Q-L,K)
                  BR(I,Q-L,K) = TEMPR + BI(I,Q-L,K)
                  BI(I,Q-L,K) = TEMPI - TEMP1
  480          CONTINUE
  500       CONTINUE
  520    CONTINUE
         DO 580 K = 1, R - 1
            DO 560 L = 1, Q - 1
               DO 540 I = 0, P - 1
                  TEMPR = BR(I,L,K)
                  TEMPI = BI(I,L,K)
                  BR(I,L,K) = COSINE(K,L)*TEMPR - SINE(K,L)*TEMPI
                  BI(I,L,K) = COSINE(K,L)*TEMPI + SINE(K,L)*TEMPR
  540          CONTINUE
  560       CONTINUE
  580    CONTINUE
      END IF
      RETURN
      END
      SUBROUTINE C06FRS(X,Y,BR,BI,P,R,COSINE,SINE)
CVD$R VECTOR
CVD$R NOLSTVAL
CVD$R STRIP
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     MARK 14 REVISED. IER-704 (DEC 1989).
C
C     Radix 6 multiple complex Fourier transform kernel
C
C     Self-sorting, decimation in frequency
C
C     .. Parameters ..
      DOUBLE PRECISION  SIN60
      PARAMETER         (SIN60=0.866025403784438646763723170752936D0)
C     .. Scalar Arguments ..
      INTEGER           P, R
C     .. Array Arguments ..
      DOUBLE PRECISION  BI(0:P-1,0:5,0:R-1), BR(0:P-1,0:5,0:R-1),
     *                  COSINE(0:R-1,1:5), SINE(0:R-1,1:5),
     *                  X(0:P-1,0:R-1,0:5), Y(0:P-1,0:R-1,0:5)
C     .. Local Scalars ..
      DOUBLE PRECISION  C2K, C3K, C4K, C5K, CK, S2K, S3K, S4K, S5K, SK,
     *                  T1I, T1R, T2I, T2R, T3I, T3R, U0I, U0R, U1I,
     *                  U1R, U2I, U2R, V0I, V0R, V1I, V1R, V2I, V2R
      INTEGER           I, K
C     .. Executable Statements ..
      IF (P.LE.R) THEN
         DO 40 I = 0, P - 1
            DO 20 K = 0, R - 1
               T1R = X(I,K,2) + X(I,K,4)
               T1I = Y(I,K,2) + Y(I,K,4)
               T2R = X(I,K,0) - 0.5D0*T1R
               T2I = Y(I,K,0) - 0.5D0*T1I
               T3R = SIN60*(X(I,K,2)-X(I,K,4))
               T3I = SIN60*(Y(I,K,2)-Y(I,K,4))
               U0R = X(I,K,0) + T1R
               U0I = Y(I,K,0) + T1I
               U1R = T2R + T3I
               U1I = T2I - T3R
               U2R = T2R - T3I
               U2I = T2I + T3R
               T1R = X(I,K,5) + X(I,K,1)
               T1I = Y(I,K,5) + Y(I,K,1)
               T2R = X(I,K,3) - 0.5D0*T1R
               T2I = Y(I,K,3) - 0.5D0*T1I
               T3R = SIN60*(X(I,K,5)-X(I,K,1))
               T3I = SIN60*(Y(I,K,5)-Y(I,K,1))
               V0R = X(I,K,3) + T1R
               V0I = Y(I,K,3) + T1I
               V1R = T2R + T3I
               V1I = T2I - T3R
               V2R = T2R - T3I
               V2I = T2I + T3R
               BR(I,0,K) = U0R + V0R
               BI(I,0,K) = U0I + V0I
               BR(I,1,K) = COSINE(K,1)*(U1R-V1R) - SINE(K,1)*(U1I-V1I)
               BI(I,1,K) = COSINE(K,1)*(U1I-V1I) + SINE(K,1)*(U1R-V1R)
               BR(I,2,K) = COSINE(K,2)*(U2R+V2R) - SINE(K,2)*(U2I+V2I)
               BI(I,2,K) = COSINE(K,2)*(U2I+V2I) + SINE(K,2)*(U2R+V2R)
               BR(I,3,K) = COSINE(K,3)*(U0R-V0R) - SINE(K,3)*(U0I-V0I)
               BI(I,3,K) = COSINE(K,3)*(U0I-V0I) + SINE(K,3)*(U0R-V0R)
               BR(I,4,K) = COSINE(K,4)*(U1R+V1R) - SINE(K,4)*(U1I+V1I)
               BI(I,4,K) = COSINE(K,4)*(U1I+V1I) + SINE(K,4)*(U1R+V1R)
               BR(I,5,K) = COSINE(K,5)*(U2R-V2R) - SINE(K,5)*(U2I-V2I)
               BI(I,5,K) = COSINE(K,5)*(U2I-V2I) + SINE(K,5)*(U2R-V2R)
   20       CONTINUE
   40    CONTINUE
      ELSE
         DO 80 K = 0, R - 1
            CK = COSINE(K,1)
            C2K = COSINE(K,2)
            C3K = COSINE(K,3)
            C4K = COSINE(K,4)
            C5K = COSINE(K,5)
            SK = SINE(K,1)
            S2K = SINE(K,2)
            S3K = SINE(K,3)
            S4K = SINE(K,4)
            S5K = SINE(K,5)
            DO 60 I = 0, P - 1
               T1R = X(I,K,2) + X(I,K,4)
               T1I = Y(I,K,2) + Y(I,K,4)
               T2R = X(I,K,0) - 0.5D0*T1R
               T2I = Y(I,K,0) - 0.5D0*T1I
               T3R = SIN60*(X(I,K,2)-X(I,K,4))
               T3I = SIN60*(Y(I,K,2)-Y(I,K,4))
               U0R = X(I,K,0) + T1R
               U0I = Y(I,K,0) + T1I
               U1R = T2R + T3I
               U1I = T2I - T3R
               U2R = T2R - T3I
               U2I = T2I + T3R
               T1R = X(I,K,5) + X(I,K,1)
               T1I = Y(I,K,5) + Y(I,K,1)
               T2R = X(I,K,3) - 0.5D0*T1R
               T2I = Y(I,K,3) - 0.5D0*T1I
               T3R = SIN60*(X(I,K,5)-X(I,K,1))
               T3I = SIN60*(Y(I,K,5)-Y(I,K,1))
               V0R = X(I,K,3) + T1R
               V0I = Y(I,K,3) + T1I
               V1R = T2R + T3I
               V1I = T2I - T3R
               V2R = T2R - T3I
               V2I = T2I + T3R
               BR(I,0,K) = U0R + V0R
               BI(I,0,K) = U0I + V0I
               BR(I,1,K) = CK*(U1R-V1R) - SK*(U1I-V1I)
               BI(I,1,K) = CK*(U1I-V1I) + SK*(U1R-V1R)
               BR(I,2,K) = C2K*(U2R+V2R) - S2K*(U2I+V2I)
               BI(I,2,K) = C2K*(U2I+V2I) + S2K*(U2R+V2R)
               BR(I,3,K) = C3K*(U0R-V0R) - S3K*(U0I-V0I)
               BI(I,3,K) = C3K*(U0I-V0I) + S3K*(U0R-V0R)
               BR(I,4,K) = C4K*(U1R+V1R) - S4K*(U1I+V1I)
               BI(I,4,K) = C4K*(U1I+V1I) + S4K*(U1R+V1R)
               BR(I,5,K) = C5K*(U2R-V2R) - S5K*(U2I-V2I)
               BI(I,5,K) = C5K*(U2I-V2I) + S5K*(U2R-V2R)
   60       CONTINUE
   80    CONTINUE
      END IF
C
      RETURN
      END
      SUBROUTINE C06FRT(X,Y,BR,BI,P,R,COSINE,SINE)
CVD$R VECTOR
CVD$R NOLSTVAL
CVD$R STRIP
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     MARK 14 REVISED. IER-705 (DEC 1989).
C
C     Radix 5 multiple complex Fourier transform kernel
C
C     Self-sorting,decimation in frequency
C
C     .. Parameters ..
      DOUBLE PRECISION  R54, SIN36, SIN72, S36S72
      PARAMETER         (R54=0.559016994374947424102293417182819D0,
     *                  SIN36=0.587785252292473129168705954639073D0,
     *                  SIN72=0.951056516295153572116439333379382D0,
     *                  S36S72=0.618033988749894848204586834365638D0)
C     .. Scalar Arguments ..
      INTEGER           P, R
C     .. Array Arguments ..
      DOUBLE PRECISION  BI(0:P-1,0:4,0:R-1), BR(0:P-1,0:4,0:R-1),
     *                  COSINE(0:R-1,1:4), SINE(0:R-1,1:4),
     *                  X(0:P-1,0:R-1,0:4), Y(0:P-1,0:R-1,0:4)
C     .. Local Scalars ..
      DOUBLE PRECISION  C2K, C3K, C4K, CK, S2K, S3K, S4K, SK, T10I,
     *                  T10R, T11I, T11R, T1I, T1R, T2I, T2R, T3I, T3R,
     *                  T4I, T4R, T5I, T5R, T6I, T6R, T7I, T7R, T8I,
     *                  T8R, T9I, T9R
      INTEGER           I, K
C     .. Executable Statements ..
      IF (P.LE.R) THEN
         DO 40 I = 0, P - 1
            DO 20 K = 0, R - 1
               T1R = X(I,K,1) + X(I,K,4)
               T1I = Y(I,K,1) + Y(I,K,4)
               T2R = X(I,K,2) + X(I,K,3)
               T2I = Y(I,K,2) + Y(I,K,3)
               T3R = SIN72*(X(I,K,1)-X(I,K,4))
               T3I = SIN72*(Y(I,K,1)-Y(I,K,4))
               T4R = SIN72*(X(I,K,2)-X(I,K,3))
               T4I = SIN72*(Y(I,K,2)-Y(I,K,3))
               T5R = T1R + T2R
               T5I = T1I + T2I
               T6R = R54*(T1R-T2R)
               T6I = R54*(T1I-T2I)
               T7R = X(I,K,0) - 0.25D0*T5R
               T7I = Y(I,K,0) - 0.25D0*T5I
               T8R = T7R + T6R
               T8I = T7I + T6I
               T9R = T7R - T6R
               T9I = T7I - T6I
               T10R = T3R + S36S72*T4R
               T10I = T3I + S36S72*T4I
               T11R = S36S72*T3R - T4R
               T11I = S36S72*T3I - T4I
               BR(I,0,K) = X(I,K,0) + T5R
               BI(I,0,K) = Y(I,K,0) + T5I
               BR(I,1,K) = COSINE(K,1)*(T8R+T10I) - SINE(K,1)*(T8I-T10R)
               BI(I,1,K) = COSINE(K,1)*(T8I-T10R) + SINE(K,1)*(T8R+T10I)
               BR(I,2,K) = COSINE(K,2)*(T9R+T11I) - SINE(K,2)*(T9I-T11R)
               BI(I,2,K) = COSINE(K,2)*(T9I-T11R) + SINE(K,2)*(T9R+T11I)
               BR(I,3,K) = COSINE(K,3)*(T9R-T11I) - SINE(K,3)*(T9I+T11R)
               BI(I,3,K) = COSINE(K,3)*(T9I+T11R) + SINE(K,3)*(T9R-T11I)
               BR(I,4,K) = COSINE(K,4)*(T8R-T10I) - SINE(K,4)*(T8I+T10R)
               BI(I,4,K) = COSINE(K,4)*(T8I+T10R) + SINE(K,4)*(T8R-T10I)
   20       CONTINUE
   40    CONTINUE
      ELSE
         DO 80 K = 0, R - 1
            CK = COSINE(K,1)
            C2K = COSINE(K,2)
            C3K = COSINE(K,3)
            C4K = COSINE(K,4)
            SK = SINE(K,1)
            S2K = SINE(K,2)
            S3K = SINE(K,3)
            S4K = SINE(K,4)
            DO 60 I = 0, P - 1
               T1R = X(I,K,1) + X(I,K,4)
               T1I = Y(I,K,1) + Y(I,K,4)
               T2R = X(I,K,2) + X(I,K,3)
               T2I = Y(I,K,2) + Y(I,K,3)
               T3R = SIN72*(X(I,K,1)-X(I,K,4))
               T3I = SIN72*(Y(I,K,1)-Y(I,K,4))
               T4R = SIN72*(X(I,K,2)-X(I,K,3))
               T4I = SIN72*(Y(I,K,2)-Y(I,K,3))
               T5R = T1R + T2R
               T5I = T1I + T2I
               T6R = R54*(T1R-T2R)
               T6I = R54*(T1I-T2I)
               T7R = X(I,K,0) - 0.25D0*T5R
               T7I = Y(I,K,0) - 0.25D0*T5I
               T8R = T7R + T6R
               T8I = T7I + T6I
               T9R = T7R - T6R
               T9I = T7I - T6I
               T10R = T3R + S36S72*T4R
               T10I = T3I + S36S72*T4I
               T11R = S36S72*T3R - T4R
               T11I = S36S72*T3I - T4I
               BR(I,0,K) = X(I,K,0) + T5R
               BI(I,0,K) = Y(I,K,0) + T5I
               BR(I,1,K) = CK*(T8R+T10I) - SK*(T8I-T10R)
               BI(I,1,K) = CK*(T8I-T10R) + SK*(T8R+T10I)
               BR(I,2,K) = C2K*(T9R+T11I) - S2K*(T9I-T11R)
               BI(I,2,K) = C2K*(T9I-T11R) + S2K*(T9R+T11I)
               BR(I,3,K) = C3K*(T9R-T11I) - S3K*(T9I+T11R)
               BI(I,3,K) = C3K*(T9I+T11R) + S3K*(T9R-T11I)
               BR(I,4,K) = C4K*(T8R-T10I) - S4K*(T8I+T10R)
               BI(I,4,K) = C4K*(T8I+T10R) + S4K*(T8R-T10I)
   60       CONTINUE
   80    CONTINUE
      END IF
C
      RETURN
      END
      SUBROUTINE C06FRU(X,Y,BR,BI,P,R,COSINE,SINE)
CVD$R VECTOR
CVD$R NOLSTVAL
CVD$R STRIP
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     MARK 14 REVISED. IER-706 (DEC 1989).
C
C     Radix four multiple complex Fourier transform kernel
C
C     Self-sorting, decimation infrequency
C
C     .. Scalar Arguments ..
      INTEGER           P, R
C     .. Array Arguments ..
      DOUBLE PRECISION  BI(0:P-1,0:3,0:R-1), BR(0:P-1,0:3,0:R-1),
     *                  COSINE(0:R-1,1:3), SINE(0:R-1,1:3),
     *                  X(0:P-1,0:R-1,0:3), Y(0:P-1,0:R-1,0:3)
C     .. Local Scalars ..
      DOUBLE PRECISION  C2K, C3K, CK, S2K, S3K, SK, T1I, T1R, T2I, T2R,
     *                  T3I, T3R, T4I, T4R
      INTEGER           I, K
C     .. Executable Statements ..
      IF (P.LT.R) THEN
         DO 40 I = 0, P - 1
            DO 20 K = 0, R - 1
               T1R = X(I,K,0) + X(I,K,2)
               T1I = Y(I,K,0) + Y(I,K,2)
               T2R = X(I,K,1) + X(I,K,3)
               T2I = Y(I,K,1) + Y(I,K,3)
               T3R = X(I,K,0) - X(I,K,2)
               T3I = Y(I,K,0) - Y(I,K,2)
               T4R = X(I,K,1) - X(I,K,3)
               T4I = Y(I,K,1) - Y(I,K,3)
               BR(I,0,K) = T1R + T2R
               BI(I,0,K) = T1I + T2I
               BR(I,1,K) = COSINE(K,1)*(T3R+T4I) - SINE(K,1)*(T3I-T4R)
               BI(I,1,K) = COSINE(K,1)*(T3I-T4R) + SINE(K,1)*(T3R+T4I)
               BR(I,2,K) = COSINE(K,2)*(T1R-T2R) - SINE(K,2)*(T1I-T2I)
               BI(I,2,K) = COSINE(K,2)*(T1I-T2I) + SINE(K,2)*(T1R-T2R)
               BR(I,3,K) = COSINE(K,3)*(T3R-T4I) - SINE(K,3)*(T3I+T4R)
               BI(I,3,K) = COSINE(K,3)*(T3I+T4R) + SINE(K,3)*(T3R-T4I)
   20       CONTINUE
   40    CONTINUE
      ELSE
         DO 80 K = 0, R - 1
            CK = COSINE(K,1)
            C2K = COSINE(K,2)
            C3K = COSINE(K,3)
            SK = SINE(K,1)
            S2K = SINE(K,2)
            S3K = SINE(K,3)
            DO 60 I = 0, P - 1
               T1R = X(I,K,0) + X(I,K,2)
               T1I = Y(I,K,0) + Y(I,K,2)
               T2R = X(I,K,1) + X(I,K,3)
               T2I = Y(I,K,1) + Y(I,K,3)
               T3R = X(I,K,0) - X(I,K,2)
               T3I = Y(I,K,0) - Y(I,K,2)
               T4R = X(I,K,1) - X(I,K,3)
               T4I = Y(I,K,1) - Y(I,K,3)
               BR(I,0,K) = T1R + T2R
               BI(I,0,K) = T1I + T2I
               BR(I,1,K) = CK*(T3R+T4I) - SK*(T3I-T4R)
               BI(I,1,K) = CK*(T3I-T4R) + SK*(T3R+T4I)
               BR(I,2,K) = C2K*(T1R-T2R) - S2K*(T1I-T2I)
               BI(I,2,K) = C2K*(T1I-T2I) + S2K*(T1R-T2R)
               BR(I,3,K) = C3K*(T3R-T4I) - S3K*(T3I+T4R)
               BI(I,3,K) = C3K*(T3I+T4R) + S3K*(T3R-T4I)
   60       CONTINUE
   80    CONTINUE
      END IF
C
      RETURN
      END
      SUBROUTINE C06FRV(X,Y,BR,BI,P,R,COSINE,SINE)
CVD$R VECTOR
CVD$R NOLSTVAL
CVD$R STRIP
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     MARK 14 REVISED. IER-707 (DEC 1989).
C
C     Radix three multiple complex Fourier transform kernel
C
C     Self-sorting, decimation in frequency
C
C     .. Parameters ..
      DOUBLE PRECISION  SIN60
      PARAMETER         (SIN60=0.866025403784438646763723170752936D0)
C     .. Scalar Arguments ..
      INTEGER           P, R
C     .. Array Arguments ..
      DOUBLE PRECISION  BI(0:P-1,0:2,0:R-1), BR(0:P-1,0:2,0:R-1),
     *                  COSINE(0:R-1,1:2), SINE(0:R-1,1:2),
     *                  X(0:P-1,0:R-1,0:2), Y(0:P-1,0:R-1,0:2)
C     .. Local Scalars ..
      DOUBLE PRECISION  C2K, CK, S2K, SK, T1I, T1R, T2I, T2R, T3I, T3R
      INTEGER           I, K
C     .. Executable Statements ..
      IF (P.LE.R) THEN
         DO 40 I = 0, P - 1
            DO 20 K = 0, R - 1
               T1R = X(I,K,1) + X(I,K,2)
               T1I = Y(I,K,1) + Y(I,K,2)
               T2R = X(I,K,0) - 0.5D0*T1R
               T2I = Y(I,K,0) - 0.5D0*T1I
               T3R = SIN60*(X(I,K,1)-X(I,K,2))
               T3I = SIN60*(Y(I,K,1)-Y(I,K,2))
               BR(I,0,K) = X(I,K,0) + T1R
               BI(I,0,K) = Y(I,K,0) + T1I
               BR(I,1,K) = COSINE(K,1)*(T2R+T3I) - SINE(K,1)*(T2I-T3R)
               BI(I,1,K) = COSINE(K,1)*(T2I-T3R) + SINE(K,1)*(T2R+T3I)
               BR(I,2,K) = COSINE(K,2)*(T2R-T3I) - SINE(K,2)*(T2I+T3R)
               BI(I,2,K) = COSINE(K,2)*(T2I+T3R) + SINE(K,2)*(T2R-T3I)
   20       CONTINUE
   40    CONTINUE
      ELSE
         DO 80 K = 0, R - 1
            CK = COSINE(K,1)
            C2K = COSINE(K,2)
            SK = SINE(K,1)
            S2K = SINE(K,2)
            DO 60 I = 0, P - 1
               T1R = X(I,K,1) + X(I,K,2)
               T1I = Y(I,K,1) + Y(I,K,2)
               T2R = X(I,K,0) - 0.5D0*T1R
               T2I = Y(I,K,0) - 0.5D0*T1I
               T3R = SIN60*(X(I,K,1)-X(I,K,2))
               T3I = SIN60*(Y(I,K,1)-Y(I,K,2))
               BR(I,0,K) = X(I,K,0) + T1R
               BI(I,0,K) = Y(I,K,0) + T1I
               BR(I,1,K) = CK*(T2R+T3I) - SK*(T2I-T3R)
               BI(I,1,K) = CK*(T2I-T3R) + SK*(T2R+T3I)
               BR(I,2,K) = C2K*(T2R-T3I) - S2K*(T2I+T3R)
               BI(I,2,K) = C2K*(T2I+T3R) + S2K*(T2R-T3I)
   60       CONTINUE
   80    CONTINUE
      END IF
C
      RETURN
      END
      SUBROUTINE C06FRW(X,Y,BR,BI,P,R,COSINE,SINE)
CVD$R VECTOR
CVD$R NOLSTVAL
CVD$R STRIP
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     MARK 14 REVISED. IER-708 (DEC 1989).
C
C     Radix two multiple complex Fourier transform kernel
C
C     Self-sorting, decimation in frequency
C
C     .. Scalar Arguments ..
      INTEGER           P, R
C     .. Array Arguments ..
      DOUBLE PRECISION  BI(0:P-1,0:1,0:R-1), BR(0:P-1,0:1,0:R-1),
     *                  COSINE(0:R-1), SINE(0:R-1), X(0:P-1,0:R-1,0:1),
     *                  Y(0:P-1,0:R-1,0:1)
C     .. Local Scalars ..
      DOUBLE PRECISION  CK, SK, UI, UR, VI, VR
      INTEGER           I, K
C     .. Executable Statements ..
      IF (P.LT.R) THEN
         DO 40 I = 0, P - 1
            DO 20 K = 0, R - 1
               UR = X(I,K,0)
               UI = Y(I,K,0)
               VR = X(I,K,1)
               VI = Y(I,K,1)
               BR(I,0,K) = UR + VR
               BI(I,0,K) = UI + VI
               BR(I,1,K) = COSINE(K)*(UR-VR) - SINE(K)*(UI-VI)
               BI(I,1,K) = COSINE(K)*(UI-VI) + SINE(K)*(UR-VR)
   20       CONTINUE
   40    CONTINUE
      ELSE
         DO 80 K = 0, R - 1
            CK = COSINE(K)
            SK = SINE(K)
            DO 60 I = 0, P - 1
               UR = X(I,K,0)
               UI = Y(I,K,0)
               VR = X(I,K,1)
               VI = Y(I,K,1)
               BR(I,0,K) = UR + VR
               BI(I,0,K) = UI + VI
               BR(I,1,K) = CK*(UR-VR) - SK*(UI-VI)
               BI(I,1,K) = CK*(UI-VI) + SK*(UR-VR)
   60       CONTINUE
   80    CONTINUE
      END IF
C
      RETURN
      END
      SUBROUTINE C06FRX(X,Y,BR,BI,M,N,Q,NQ,TRIG)
CVD$R VECTOR
CVD$R NOLSTVAL
CVD$R STRIP
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     Multiple complex Fourier transform kernel driver
C
C     Mixed-radix, self-sorting, decimation in frequency
C
C     .. Scalar Arguments ..
      INTEGER           M, N, NQ
C     .. Array Arguments ..
      DOUBLE PRECISION  BI(0:M*N-1), BR(0:M*N-1), TRIG(0:2*N-1),
     *                  X(0:M*N-1), Y(0:M*N-1)
      INTEGER           Q(NQ)
C     .. Local Scalars ..
      DOUBLE PRECISION  FACTOR
      INTEGER           I, P, QI, R
      LOGICAL           INA
C     .. External Subroutines ..
      EXTERNAL          C06FRR, C06FRS, C06FRT, C06FRU, C06FRV, C06FRW
C     .. Intrinsic Functions ..
      INTRINSIC         SQRT, DBLE
C     .. Executable Statements ..
      INA = .TRUE.
      P = 1
      R = N
C
      IF (N.EQ.1) RETURN
      DO 20 I = 1, NQ
         QI = Q(I)
         R = R/QI
         IF (INA) THEN
            IF (QI.EQ.2) THEN
               CALL C06FRW(X,Y,BR,BI,M*P,R,TRIG((P-1)*QI*R),TRIG(N+(P-1)
     *                     *QI*R))
            ELSE IF (QI.EQ.3) THEN
               CALL C06FRV(X,Y,BR,BI,M*P,R,TRIG((P-1)*QI*R),TRIG(N+(P-1)
     *                     *QI*R))
            ELSE IF (QI.EQ.4) THEN
               CALL C06FRU(X,Y,BR,BI,M*P,R,TRIG((P-1)*QI*R),TRIG(N+(P-1)
     *                     *QI*R))
            ELSE IF (QI.EQ.5) THEN
               CALL C06FRT(X,Y,BR,BI,M*P,R,TRIG((P-1)*QI*R),TRIG(N+(P-1)
     *                     *QI*R))
            ELSE IF (QI.EQ.6) THEN
               CALL C06FRS(X,Y,BR,BI,M*P,R,TRIG((P-1)*QI*R),TRIG(N+(P-1)
     *                     *QI*R))
            ELSE
               CALL C06FRR(X,Y,BR,BI,M*P,QI,R,TRIG((P-1)*QI*R),
     *                     TRIG(N+(P-1)*QI*R))
            END IF
         ELSE
            IF (QI.EQ.2) THEN
               CALL C06FRW(BR,BI,X,Y,M*P,R,TRIG((P-1)*QI*R),TRIG(N+(P-1)
     *                     *QI*R))
            ELSE IF (QI.EQ.3) THEN
               CALL C06FRV(BR,BI,X,Y,M*P,R,TRIG((P-1)*QI*R),TRIG(N+(P-1)
     *                     *QI*R))
            ELSE IF (QI.EQ.4) THEN
               CALL C06FRU(BR,BI,X,Y,M*P,R,TRIG((P-1)*QI*R),TRIG(N+(P-1)
     *                     *QI*R))
            ELSE IF (QI.EQ.5) THEN
               CALL C06FRT(BR,BI,X,Y,M*P,R,TRIG((P-1)*QI*R),TRIG(N+(P-1)
     *                     *QI*R))
            ELSE IF (QI.EQ.6) THEN
               CALL C06FRS(BR,BI,X,Y,M*P,R,TRIG((P-1)*QI*R),TRIG(N+(P-1)
     *                     *QI*R))
            ELSE
               CALL C06FRR(BR,BI,X,Y,M*P,QI,R,TRIG((P-1)*QI*R),
     *                     TRIG(N+(P-1)*QI*R))
            END IF
         END IF
         INA = .NOT. INA
         P = P*QI
   20 CONTINUE
C
      FACTOR = 1.0D0/SQRT(DBLE(N))
      IF (INA) THEN
         DO 40 I = 0, M*N - 1
            X(I) = X(I)*FACTOR
            Y(I) = Y(I)*FACTOR
   40    CONTINUE
      ELSE
         DO 60 I = 0, M*N - 1
            X(I) = BR(I)*FACTOR
            Y(I) = BI(I)*FACTOR
   60    CONTINUE
      END IF
C
      RETURN
      END
      SUBROUTINE C06FUF(M,N,X,Y,INIT,TRIGM,TRIGN,WORK,IFAIL)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C     C06FUF computes a two-dimensional Fast Fourier Transform of
C     a complex array, by calling the vectorized multiple
C     one-dimensional routine C06FRF together with an explicit
C     transposition of the data using the auxiliary routine C06FUZ.
C
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='C06FUF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, M, N
      CHARACTER*1       INIT
C     .. Array Arguments ..
      DOUBLE PRECISION  TRIGM(2*M), TRIGN(2*N), WORK(2*M*N), X(M*N),
     *                  Y(M*N)
C     .. Local Scalars ..
      INTEGER           IERROR, MERROR, MQ, NERROR, NQ, NREC
C     .. Local Arrays ..
      INTEGER           QM(30), QN(30)
      CHARACTER*80      REC(1)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          C06FPQ, C06FRX, C06FUZ
C     .. Intrinsic Functions ..
      INTRINSIC         MAX
C     .. Executable Statements ..
      MERROR = 0
      CALL C06FPQ(M,N,INIT,TRIGN,QN,NQ,NERROR)
      IF (NERROR.EQ.0) THEN
         CALL C06FPQ(N,M,INIT,TRIGM,QM,MQ,MERROR)
         IF (MERROR.EQ.0) THEN
            CALL C06FRX(X,Y,WORK,WORK(M*N+1),M,N,QN,NQ,TRIGN)
            CALL C06FUZ(X,Y,WORK,WORK(M*N+1),M,N)
            CALL C06FRX(WORK,WORK(M*N+1),X,Y,N,M,QM,MQ,TRIGM)
            CALL C06FUZ(WORK,WORK(M*N+1),X,Y,N,M)
         ELSE IF (MERROR.EQ.5) THEN
            WRITE (REC(1),FMT=99999) INIT
         END IF
C
C         All other error exits checked by first call of C06FPQ
C
      ELSE IF (NERROR.EQ.1) THEN
         WRITE (REC(1),FMT=99998) M
      ELSE IF (NERROR.EQ.2) THEN
         WRITE (REC(1),FMT=99997) N
      ELSE IF (NERROR.EQ.3) THEN
         WRITE (REC(1),FMT=99996) INIT
      ELSE IF (NERROR.EQ.4) THEN
         WRITE (REC(1),FMT=99995) INIT
      ELSE IF (NERROR.EQ.5) THEN
         WRITE (REC(1),FMT=99994) INIT
      END IF
C
      NREC = 1
      IERROR = MAX(MERROR,NERROR)
      IFAIL = P01ABF(IFAIL,IERROR,SRNAME,NREC,REC)
C
      RETURN
C
99999 FORMAT (' ** INIT = ',A1,', but M and TRIGM array incompatible')
99998 FORMAT (' ** M must be at least 1: M = ',I16)
99997 FORMAT (' ** N must be at least 1: N = ',I16)
99996 FORMAT (' ** ',A1,' is an invalid value of INIT')
99995 FORMAT (' ** INIT = ',A1,', but TRIG arrays never initialized')
99994 FORMAT (' ** INIT = ',A1,', but N and TRIGN array incompatible')
      END
      SUBROUTINE C06FUZ(X,Y,XX,YY,M,N)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C     C06FUZ transposes a two-dimensional complex array.
C
C     .. Scalar Arguments ..
      INTEGER           M, N
C     .. Array Arguments ..
      DOUBLE PRECISION  X(M,N), XX(N,M), Y(M,N), YY(N,M)
C     .. Local Scalars ..
      INTEGER           I, J
C     .. Executable Statements ..
      IF (M.GE.N) THEN
         DO 40 J = 1, N
            DO 20 I = 1, M
               XX(J,I) = X(I,J)
               YY(J,I) = Y(I,J)
   20       CONTINUE
   40    CONTINUE
      ELSE
         DO 80 I = 1, M
            DO 60 J = 1, N
               XX(J,I) = X(I,J)
               YY(J,I) = Y(I,J)
   60       CONTINUE
   80    CONTINUE
      END IF
      RETURN
      END
      SUBROUTINE F01QCF(M,N,A,LDA,ZETA,IFAIL)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C
C  1. Purpose
C     =======
C
C  F01QCF  finds  the  QR factorization  of the real  m by n,  m .ge. n,
C  matrix A,  so that  A is reduced to upper triangular form by means of
C  orthogonal transformations.
C
C  2. Description
C     ===========
C
C  The m by n matrix A is factorized as
C
C     A = Q*( R )   when   m.gt.n,
C           ( 0 )
C
C     A = Q*R       when   m = n,
C
C  where  Q  is an  m by m orthogonal matrix and  R  is an  n by n upper
C  triangular matrix.
C
C  The  factorization  is  obtained  by  Householder's  method. The  kth
C  transformation matrix, Q( k ), which is used  to introduce zeros into
C  the kth column of A is given in the form
C
C     Q( k ) = ( I     0   ),
C              ( 0  T( k ) )
C
C  where
C
C     T( k ) = I - u( k )*u( k )',
C
C     u( k ) = ( zeta( k ) ),
C              (    z( k ) )
C
C  zeta( k )  is a scalar and  z( k )  is an  ( m - k )  element vector.
C  zeta( k ) and z( k )  are chosen to annhilate the elements  below the
C  triangular part of  A.
C
C  The vector  u( k ) is returned in the kth element of  ZETA and in the
C  kth column of A, such that zeta( k ) is in ZETA( k ) and the elements
C  of  z( k ) are in  a( k + 1, k ), ..., a( m, k ).  The elements of  R
C  are returned in the upper triangular part of  A.
C
C  Q is given by
C
C     Q = ( Q( n )*Q( n - 1 )*...*Q( 1 ) )'.
C
C  3. Parameters
C     ==========
C
C  M      - INTEGER.
C
C           On entry, M must specify the number of rows of  A. M must be
C           at least  n.
C
C           Unchanged on exit.
C
C  N      - INTEGER.
C
C           On entry, N must specify the number of columns of  A. N must
C           be  at  least zero. When  N = 0  then an immediate return is
C           effected.
C
C           Unchanged on exit.
C
C  A      - REAL             array of DIMENSION ( LDA, n ).
C
C           Before entry, the leading  M by N  part of the array  A must
C           contain the matrix to be factorized.
C
C           On exit, the  N by N upper triangular part of A will contain
C           the upper triangular matrix R and the  M by N strictly lower
C           triangular  part   of   A   will  contain  details   of  the
C           factorization as described above.
C
C  LDA    - INTEGER.
C
C           On entry, LDA  must  specify  the  leading dimension of  the
C           array  A  as declared in the calling (sub) program. LDA must
C           be at least  m.
C
C           Unchanged on exit.
C
C  ZETA   - REAL             array of DIMENSION at least ( n ).
C
C           On exit,  ZETA( k )  contains the scalar  zeta( k )  for the
C           kth  transformation.  If  T( k ) = I  then  ZETA( k ) = 0.0,
C           otherwise  ZETA( k )  contains  zeta( k ) as described above
C           and  zeta( k ) is always in the range  ( 1.0, sqrt( 2.0 ) ).
C
C  IFAIL  - INTEGER.
C
C           Before entry,  IFAIL  must contain one of the values -1 or 0
C           or 1 to specify noisy soft failure or noisy hard failure  or
C           silent soft failure. ( See Chapter P01 for further details.)
C
C           On successful  exit  IFAIL  will be  zero,  otherwise  IFAIL
C           will  be set to  -1  indicating that an  input parameter has
C           been  incorrectly  set. See  the  next section  for  further
C           details.
C
C  4. Diagnostic Information
C     ======================
C
C  IFAIL = -1
C
C     One or more of the following conditions holds:
C
C        M   .lt. N
C        N   .lt. 0
C        LDA .lt. M
C
C  If  on  entry,  IFAIL  was  either  -1 or 0  then  further diagnostic
C  information  will  be  output  on  the  error message  channel. ( See
C  routine  X04AAF. )
C
C  5. Further information
C     ===================
C
C  Following the use of this routine the operations
C
C        B := Q*B   and   B := Q'*B,
C
C  where  B  is an  m by k  matrix, can  be  performed  by calls to  the
C  NAG Library routine  F01QDF. The  operation  B := Q*B can be obtained
C  by the call:
C
C     IFAIL = 0
C     CALL F01QDF( 'No transpose', 'Separate', M, N, A, LDA, ZETA,
C    $             K, B, LDB, WORK, IFAIL )
C
C  and  B := Q'*B  can be obtained by the call:
C
C     IFAIL = 0
C     CALL F01QDF( 'Transpose', 'Separate', M, N, A, LDA, ZETA,
C    $             K, B, LDB, WORK, IFAIL )
C
C  In  both  cases  WORK  must be a  k  element array  that  is used  as
C  workspace. If  B  is a one-dimensional array (single column) then the
C  parameter  LDB  can be replaced by  M. See routine F01QDF for further
C  details.
C
C  The first k columns of the orthogonal matrix Q can either be obtained
C  by setting  B to the first k columns of the unit matrix and using the
C  first of the above two calls,  or by calling the  NAG Library routine
C  F01QEF, which overwrites the k columns of Q on the first k columns of
C  the array A.  Q is obtained by the call:
C
C     CALL F01QEF( 'Separate', M, N, K, A, LDA, ZETA, WORK, IFAIL )
C
C  As above WORK must be a k element array.  If K is larger than N, then
C  A must have been declared to have at least K columns.
C
C  Operations involving the matrix  R  can readily  be performed by  the
C  Level 2 BLAS  routines  DTRSV  and DTRMV  (see Chapter F06), but note
C  that no test for  near singularity  of  R  is incorporated in DTRSV .
C  If  R  is singular,  or nearly singular then the  NAG Library routine
C  F02WUF  can be  used to  determine  the  singular value decomposition
C  of  R.
C
C
C  Nag Fortran 77 Auxiliary linear algebra routine.
C
C  -- Written on 21-December-1985.
C     Sven Hammarling, Nag Central Office.
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE, ZERO
      PARAMETER         (ONE=1.0D+0,ZERO=0.0D+0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F01QCF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LDA, M, N
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), ZETA(*)
C     .. Local Scalars ..
      DOUBLE PRECISION  TEMP
      INTEGER           IERR, K, LA
C     .. Local Arrays ..
      CHARACTER*46      REC(1)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          DGEMV, DGER, F06FRF, P01ABY
C     .. Intrinsic Functions ..
      INTRINSIC         MIN
C     .. Executable Statements ..
C
C     Check the input parameters.
C
      IERR = 0
      IF (M.LT.N) CALL P01ABY(M,'M',IFAIL,IERR,SRNAME)
      IF (N.LT.0) CALL P01ABY(N,'N',IFAIL,IERR,SRNAME)
      IF (LDA.LT.M) CALL P01ABY(LDA,'LDA',IFAIL,IERR,SRNAME)
      IF (IERR.GT.0) THEN
         WRITE (REC,FMT=99999) IERR
         IFAIL = P01ABF(IFAIL,-1,SRNAME,1,REC)
         RETURN
      END IF
C
C     Perform the factorization.
C
      IF (N.EQ.0) THEN
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
         RETURN
      END IF
      LA = LDA
      DO 20 K = 1, MIN(M-1,N)
C
C        Use a  Householder reflection  to  zero the  kth column  of  A.
C        First set up the reflection.
C
         CALL F06FRF(M-K,A(K,K),A(K+1,K),1,ZERO,ZETA(K))
         IF ((ZETA(K).GT.ZERO) .AND. (K.LT.N)) THEN
            IF ((K+1).EQ.N) LA = M - K + 1
C
C           Temporarily  store  beta and  put  zeta( k )  in  a( k, k ).
C
            TEMP = A(K,K)
            A(K,K) = ZETA(K)
C
C           We now perform the operation  A := Q( k )*A.
C
C           Let  B  denote  the bottom  ( m - k + 1 ) by ( n - k )  part
C           of  A.
C
C           First form   work = B'*u.  ( work  is stored in the elements
C           ZETA( k + 1 ), ..., ZETA( n ). )
C
            CALL DGEMV('Transpose',M-K+1,N-K,ONE,A(K,K+1),LA,A(K,K),1,
     *                 ZERO,ZETA(K+1),1)
C
C           Now form  B := B - u*work'.
C
            CALL DGER(M-K+1,N-K,-ONE,A(K,K),1,ZETA(K+1),1,A(K,K+1),LA)
C
C           Restore beta.
C
            A(K,K) = TEMP
         END IF
   20 CONTINUE
C
C     Set the final  ZETA  when  m.eq.n.
C
      IF (M.EQ.N) ZETA(N) = ZERO
C
      IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
      RETURN
C
C
C     End of F01QCF. ( SGEQR )
C
99999 FORMAT ('    The input parameters contained ',I2,' error(s)')
      END
      SUBROUTINE F01QDF(TRANS,WHERET,M,N,A,LDA,ZETA,NCOLB,B,LDB,WORK,
     *                  IFAIL)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C
C  1. Purpose
C     =======
C
C  F01QDF performs one of the transformations
C
C     B := Q*B   or   B := Q'*B,
C
C  where  B is an  m by ncolb real matrix and  Q is an m by m orthogonal
C  matrix, given as the product of  Householder transformation matrices.
C
C  This  routine  is  intended  for  use  following  NAG Fortran Library
C  routine  F01QCF.
C
C  2. Description
C     ===========
C
C  Q is assumed to be given by
C
C     Q = ( Q( n )*Q( n - 1 )*...*Q( 1 ) )',
C
C  Q( k ) being given in the form
C
C     Q( k ) = ( I     0   ),
C              ( 0  T( k ) )
C
C  where
C
C     T( k ) = I - u( k )*u( k )'
C
C     u( k ) = ( zeta( k ) ),
C              (    z( k ) )
C
C  zeta( k )  is a scalar and  z( k )  is an  ( m - k )  element vector.
C
C  z( k )  must  be  supplied  in  the  kth  column  of  A  in  elements
C  a( k + 1, k ), ..., a( m, k )  and  zeta( k ) must be supplied either
C  in  a( k, k ) or in zeta( k ),  depending upon the parameter  WHERET.
C
C  To obtain Q explicitly B may be set to I and premultiplied by Q. This
C  is more efficient than obtaining Q'.
C
C  3. Parameters
C     ==========
C
C  TRANS  - CHARACTER*1.
C
C           On entry, TRANS  specifies the operation to be performed  as
C           follows.
C
C           TRANS = 'N' or 'n'  ( No transpose )
C
C              Perform the operation  B := Q*B.
C
C           TRANS = 'T' or 't' or 'C' or 'c'  ( Transpose )
C
C              Perform the operation  B := Q'*B.
C
C           Unchanged on exit.
C
C  WHERET - CHARACTER*1.
C
C           On entry,  WHERET  specifies where the elements of  zeta are
C           to be found as follows.
C
C           WHERET = 'I' or 'i'   ( In A )
C
C              The elements of zeta are in A.
C
C           WHERET = 'S' or 's'   ( Separate )
C
C              The elements of zeta are separate from A, in ZETA.
C
C           Unchanged on exit.
C
C  M      - INTEGER.
C
C           On entry, M  must specify the number of rows of A. M must be
C           at least n.
C
C           Unchanged on exit.
C
C  N      - INTEGER.
C
C           On entry, N  must specify the number of columns of A. N must
C           be  at least zero. When  N = 0  then an immediate return  is
C           effected.
C
C           Unchanged on exit.
C
C  A      - REAL             array of DIMENSION ( LDA, n ).
C
C           Before entry, the leading  M by N  stricly lower  triangular
C           part of the array  A  must contain details of the matrix  Q.
C           In  addition, when  WHERET = 'I' or 'i'  then  the  diagonal
C           elements of A must contain the elements of zeta as described
C           under the argument  ZETA  below.
C
C           When  WHERET = 'S' or 's'  then the diagonal elements of the
C           array  A  are referenced, since they are used temporarily to
C           store the  zeta( k ), but they contain their original values
C           on return.
C
C           Unchanged on exit.
C
C  LDA    - INTEGER.
C
C           On  entry, LDA  must specify  the leading dimension  of  the
C           array  A  as declared in the calling (sub) program. LDA must
C           be at least m.
C
C           Unchanged on exit.
C
C  ZETA   - REAL             array of  DIMENSION  at least  ( n ),  when
C           WHERET = 'S' or 's'.
C
C           Before entry with  WHERET = 'S' or 's', the array  ZETA must
C           contain  the  elements  of  zeta.  If  ZETA( k ) = 0.0  then
C           T( k )  is assumed  to be  I otherwise  ZETA( k ) is assumed
C           to contain zeta( k ).
C
C           When WHERET = 'I' or 'i', the array  ZETA is not referenced.
C
C           Unchanged on exit.
C
C  NCOLB  - INTEGER.
C
C           On  entry, NCOLB  must specify  the number of columns of  B.
C           NCOLB  must  be  at  least  zero.  When  NCOLB = 0  then  an
C           immediate return is effected.
C
C           Unchanged on exit.
C
C  B      - REAL             array of DIMENSION ( LDB, ncolb ).
C
C           Before entry, the leading  M by NCOLB  part of  the array  B
C           must  contain  the matrix to be  transformed.
C
C           On  exit,  B  is  overwritten  by  the  transformed  matrix.
C
C  LDB    - INTEGER.
C
C           On  entry, LDB  must specify  the  leading dimension of  the
C           array  B as declared in the calling (sub) program. LDB  must
C           be at least m.
C
C           Unchanged on exit.
C
C  WORK   - REAL             array of DIMENSION at least ( ncolb ).
C
C           Used as internal workspace.
C
C  IFAIL  - INTEGER.
C
C           Before entry,  IFAIL  must contain one of the values -1 or 0
C           or 1 to specify noisy soft failure or noisy hard failure  or
C           silent soft failure. ( See Chapter P01 for further details.)
C
C           On  successful exit  IFAIL  will be  zero,  otherwise  IFAIL
C           will  be set to   -1  indicating that an input parameter has
C           been  incorrectly  set. See  the  next  section  for further
C           details.
C
C  4. Diagnostic Information
C     ======================
C
C  IFAIL = -1
C
C     One or more of the following conditions holds:
C
C        TRANS  .ne. 'N' or 'n' or 'T' or 't' or 'C' or 'c'
C        WHERET .ne. 'I' or 'i' or 'S' or 's'
C        M      .lt. N
C        N      .lt. 0
C        LDA    .lt. M
C        NCOLB  .lt. 0
C        LDB    .lt. M
C
C  If  on  entry,  IFAIL  was either  -1 or 0  then  further  diagnostic
C  information  will  be  output  on  the  error message  channel. ( See
C  routine  X04AAF. )
C
C
C  Nag Fortran 77 Auxiliary linear algebra routine.
C
C  -- Written on 13-November-1987.
C     Sven Hammarling, Nag Central Office.
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE, ZERO
      PARAMETER         (ONE=1.0D+0,ZERO=0.0D+0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F01QDF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LDA, LDB, M, N, NCOLB
      CHARACTER*1       TRANS, WHERET
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), B(LDB,*), WORK(*), ZETA(*)
C     .. Local Scalars ..
      DOUBLE PRECISION  TEMP, ZETAK
      INTEGER           IERR, K, KK, LB
C     .. Local Arrays ..
      CHARACTER*46      REC(1)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          DGEMV, DGER, P01ABW, P01ABY
C     .. Intrinsic Functions ..
      INTRINSIC         MIN
C     .. Executable Statements ..
C
C     Check the input parameters.
C
      IERR = 0
      IF ((TRANS.NE.'N') .AND. (TRANS.NE.'n') .AND. (TRANS.NE.'T')
     *    .AND. (TRANS.NE.'t') .AND. (TRANS.NE.'C') .AND. (TRANS.NE.'c')
     *    ) CALL P01ABW(TRANS,'TRANS',IFAIL,IERR,SRNAME)
      IF ((WHERET.NE.'I') .AND. (WHERET.NE.'i') .AND. (WHERET.NE.'S')
     *     .AND. (WHERET.NE.'s')) CALL P01ABW(WHERET,'WHERET',IFAIL,
     *    IERR,SRNAME)
      IF (M.LT.N) CALL P01ABY(M,'M',IFAIL,IERR,SRNAME)
      IF (N.LT.0) CALL P01ABY(N,'N',IFAIL,IERR,SRNAME)
      IF (LDA.LT.M) CALL P01ABY(LDA,'LDA',IFAIL,IERR,SRNAME)
      IF (NCOLB.LT.0) CALL P01ABY(NCOLB,'NCOLB',IFAIL,IERR,SRNAME)
      IF (LDB.LT.M) CALL P01ABY(LDB,'LDB',IFAIL,IERR,SRNAME)
      IF (IERR.GT.0) THEN
         WRITE (REC,FMT=99999) IERR
         IFAIL = P01ABF(IFAIL,-1,SRNAME,1,REC)
         RETURN
      END IF
C
C     Perform the transformation.
C
      IF (MIN(N,NCOLB).EQ.0) THEN
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
         RETURN
      END IF
      LB = LDB
      DO 20 KK = 1, N
         IF ((TRANS.EQ.'T') .OR. (TRANS.EQ.'t') .OR. (TRANS.EQ.'C')
     *       .OR. (TRANS.EQ.'c')) THEN
C
C           Q'*B = Q( n )*...*Q( 2 )*Q( 1 )*B,
C
            K = KK
         ELSE
C
C           Q*B  = Q( 1 )'*Q( 2 )'*...*Q( n )'*B,
C
            K = N + 1 - KK
         END IF
         IF ((WHERET.EQ.'S') .OR. (WHERET.EQ.'s')) THEN
            ZETAK = ZETA(K)
         ELSE
            ZETAK = A(K,K)
         END IF
         IF (ZETAK.GT.ZERO) THEN
            TEMP = A(K,K)
            A(K,K) = ZETAK
            IF (NCOLB.EQ.1) LB = M - K + 1
C
C           Let C denote the bottom ( m - k + 1 ) by ncolb part of B.
C
C           First form  work = C'*u.
C
            CALL DGEMV('Transpose',M-K+1,NCOLB,ONE,B(K,1),LB,A(K,K),1,
     *                 ZERO,WORK,1)
C
C           Now form  C := C - u*work'.
C
            CALL DGER(M-K+1,NCOLB,-ONE,A(K,K),1,WORK,1,B(K,1),LB)
C
C           Restore the diagonal element of A.
C
            A(K,K) = TEMP
         END IF
   20 CONTINUE
C
      IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
      RETURN
C
C
C     End of F01QDF. ( SGEAPQ )
C
99999 FORMAT ('    The input parameters contained ',I2,' error(s)')
      END
      SUBROUTINE F01QEF(WHERET,M,N,NCOLQ,A,LDA,ZETA,WORK,IFAIL)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C     MARK 14C REVISED. IER-885 (NOV 1990).
C
C  1. Purpose
C     =======
C
C  F01QEF  returns  the  first  ncolq columns  of the  m by m orthogonal
C  matrix   Q,   where   Q  is  given  as  the  product  of  Householder
C  transformation matrices.
C
C  This  routine  is  intended  for  use  following  NAG Fortran Library
C  routine  F01QCF.
C
C  2. Description
C     ===========
C
C  Q is assumed to be given by
C
C     Q = ( Q( n )*Q( n - 1 )*...*Q( 1 ) )',
C
C  Q( k ) being given in the form
C
C     Q( k ) = ( I     0   ),
C              ( 0  T( k ) )
C
C  where
C
C     T( k ) = I - u( k )*u( k )'
C
C     u( k ) = ( zeta( k ) ),
C              (    z( k ) )
C
C  zeta( k )  is a scalar and  z( k )  is an  ( m - k )  element vector.
C
C  z( k )  must  be  supplied  in  the  kth  column  of  A  in  elements
C  a( k + 1, k ), ..., a( m, k )  and  zeta( k ) must be supplied either
C  in  a( k, k ) or in zeta( k ),  depending upon the parameter  WHERET.
C
C  3. Parameters
C     ==========
C
C  WHERET - CHARACTER*1.
C
C           On entry,  WHERET  specifies where the elements of  zeta are
C           to be found as follows.
C
C           WHERET = 'I' or 'i'   ( In A )
C
C              The elements of zeta are in A.
C
C           WHERET = 'S' or 's'   ( Separate )
C
C              The elements of zeta are separate from A, in  ZETA.
C
C           Unchanged on exit.
C
C  M      - INTEGER.
C
C           On entry, M  must specify the number of rows of A. M must be
C           at least n.
C
C           Unchanged on exit.
C
C  N      - INTEGER.
C
C           On entry, N  must specify the number of columns of A. N must
C           be at least zero.
C
C           Unchanged on exit.
C
C  NCOLQ  - INTEGER.
C
C           On entry, NCOLQ  must specify the required number of columns
C           of Q.  NCOLQ must be at least zero and not be larger than m.
C           When   NCOLQ = 0  then  an  immediate  return  is  effected.
C
C           Unchanged on exit.
C
C  A      - REAL             array of DIMENSION ( LDA, nca ),  where nca
C           must be at least  max( n, ncolq ).
C
C           Before entry, the leading  M by N  stricly lower  triangular
C           part of the array  A  must contain details of the matrix  Q.
C           In  addition, when  WHERET = 'I' or 'i'  then  the  diagonal
C           elements of A must contain the elements of zeta as described
C           under the argument  ZETA  below.
C
C           On  exit, the  first  NCOLQ  columns  of  the  array  A  are
C           overwritten  by  the  first  ncolq  columns  of  the  m by m
C           orthogonal matrix  Q.
C
C           Unchanged on exit.
C
C  LDA    - INTEGER.
C
C           On  entry, LDA  must specify  the leading dimension  of  the
C           array  A  as declared in the calling (sub) program. LDA must
C           be at least m.
C
C           Unchanged on exit.
C
C  ZETA   - REAL             array of  DIMENSION  at least  ( n ),  when
C           WHERET = 'S' or 's'.
C
C           Before entry with  WHERET = 'S' or 's', the array  ZETA must
C           contain  the  elements  of  zeta.  If  ZETA( k ) = 0.0  then
C           T( k )  is assumed to be  I, otherwise  ZETA( k ) is assumed
C           to contain zeta( k ).
C
C           When WHERET = 'I' or 'i', the array  ZETA is not referenced.
C
C           Unchanged on exit.
C
C  WORK   - REAL             array of DIMENSION at least ( ncolq ).
C
C           Used as internal workspace.
C
C  IFAIL  - INTEGER.
C
C           Before entry,  IFAIL  must contain one of the values -1 or 0
C           or 1 to specify noisy soft failure or noisy hard failure  or
C           silent soft failure. ( See Chapter P01 for further details.)
C
C           On  successful exit  IFAIL  will be  zero,  otherwise  IFAIL
C           will  be set to   -1  indicating that an input parameter has
C           been  incorrectly  set. See  the  next  section  for further
C           details.
C
C  4. Diagnostic Information
C     ======================
C
C  IFAIL = -1
C
C     One or more of the following conditions holds:
C
C        WHERET .ne. 'I' or 'i' or 'S' or 's'
C        M      .lt. N
C        N      .lt. 0
C        NCOLQ  .lt. 0  .or.  NCOLQ .gt. M
C        LDA    .lt. M
C
C  If  on  entry,  IFAIL  was either  -1 or 0  then  further  diagnostic
C  information  will  be  output  on  the  error message  channel. ( See
C  routine  X04AAF. )
C
C
C  Nag Fortran 77 Auxiliary linear algebra routine.
C
C  -- Written on 13-November-1987.
C     Sven Hammarling, Nag Central Office.
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE, ZERO
      PARAMETER         (ONE=1.0D+0,ZERO=0.0D+0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F01QEF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LDA, M, N, NCOLQ
      CHARACTER*1       WHERET
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), WORK(*), ZETA(*)
C     .. Local Scalars ..
      DOUBLE PRECISION  ZETAK
      INTEGER           IERR, K, NCQ, P
C     .. Local Arrays ..
      CHARACTER*46      REC(1)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          F06FBF, F06QHF, P01ABW, P01ABY, DGEMV, DGER,
     *                  DSCAL
C     .. Intrinsic Functions ..
      INTRINSIC         MIN
C     .. Executable Statements ..
C
C     Check the input parameters.
C
      IERR = 0
      IF ((WHERET.NE.'I') .AND. (WHERET.NE.'i') .AND. (WHERET.NE.'S')
     *     .AND. (WHERET.NE.'s')) CALL P01ABW(WHERET,'WHERET',IFAIL,
     *    IERR,SRNAME)
      IF (M.LT.N) CALL P01ABY(M,'M',IFAIL,IERR,SRNAME)
      IF (N.LT.0) CALL P01ABY(N,'N',IFAIL,IERR,SRNAME)
      IF ((NCOLQ.LT.0) .OR. (NCOLQ.GT.M)) CALL P01ABY(NCOLQ,'NCOLQ',
     *    IFAIL,IERR,SRNAME)
      IF (LDA.LT.M) CALL P01ABY(LDA,'LDA',IFAIL,IERR,SRNAME)
      IF (IERR.GT.0) THEN
         WRITE (REC,FMT=99999) IERR
         IFAIL = P01ABF(IFAIL,-1,SRNAME,1,REC)
         RETURN
      END IF
C
C     Start to form Q. First set the elements above the leading diagonal
C     to zero.
C
      IF (NCOLQ.EQ.0) THEN
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
         RETURN
      END IF
      P = MIN(N,NCOLQ)
      IF (P.GT.1) CALL F06QHF('Upper',P-1,P-1,ZERO,ZERO,A(1,2),LDA)
      IF (NCOLQ.GT.N) THEN
         NCQ = NCOLQ - N
C
C        Set the last  ( ncolq - n ) columns of  Q  to those of the unit
C        matrix.
C
         CALL F06QHF('General',N,NCOLQ-N,ZERO,ZERO,A(1,N+1),LDA)
         CALL F06QHF('General',M-N,NCOLQ-N,ZERO,ONE,A(N+1,N+1),LDA)
      ELSE
         NCQ = 0
      END IF
      DO 20 K = P, 1, -1
C
C        Q*E( ncolq ) = Q( 1 )'*...*Q( p )'*E( ncolq ), where E( ncolq )
C        is the matrix containing the first ncolq columns of I.
C
         IF ((WHERET.EQ.'S') .OR. (WHERET.EQ.'s')) THEN
            ZETAK = ZETA(K)
         ELSE
            ZETAK = A(K,K)
         END IF
         IF (ZETAK.GT.ZERO) THEN
            A(K,K) = ZETAK
C
C           Let C denote the bottom ( m - k + 1 ) by ncq part of Q.
C
C           First form  work = C'*u.
C
            IF ((K.LT.M) .AND. (NCQ.GT.0)) THEN
               CALL DGEMV('Transpose',M-K+1,NCQ,ONE,A(K,K+1),LDA,A(K,K),
     *                    1,ZERO,WORK,1)
C
C              Now form  C := C - u*work'.
C
               CALL DGER(M-K+1,NCQ,-ONE,A(K,K),1,WORK,1,A(K,K+1),LDA)
            END IF
C
C           Now form the kth column of Q.
C
            CALL DSCAL(M-K+1,-ZETAK,A(K,K),1)
            A(K,K) = ONE + A(K,K)
         ELSE
            A(K,K) = ONE
            IF (K.LT.M) CALL F06FBF(M-K,ZERO,A(K+1,K),1)
         END IF
         NCQ = NCQ + 1
   20 CONTINUE
C
      IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
      RETURN
C
C
C     End of F01QEF. ( SGEFQ  )
C
99999 FORMAT ('    The input parameters contained ',I2,' error(s)')
      END
      SUBROUTINE F01QJF(M,N,A,LDA,ZETA,IFAIL)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C
C  1. Purpose
C     =======
C
C  F01QJF  finds the  RQ factorization  of the  real  m by n,  m .le. n,
C  matrix  A, so that  A is reduced to upper triangular form by means of
C  orthogonal transformations from the right.
C
C  2. Description
C     ===========
C
C  The m by n matrix A is factorized as
C
C     A = ( R  0 )*P'   when   m.lt.n,
C
C     A = R*P'          when   m = n,
C
C  where  P  is an  n by n orthogonal matrix and  R  is an  m by m upper
C  triangular matrix.
C
C  P  is  given  as a  sequence  of  Householder transformation matrices
C
C     P = P( m )*...*P( 2 )*P( 1 ),
C
C  the  ( m - k + 1 )th  transformation matrix,  P( k ),  being used  to
C  introduce zeros into the  kth row of A.  P( k ) has the form
C
C     P( k ) = I - u( k )*u( k )',
C
C  where
C
C     u( k ) = (    w( k ) ),
C              ( zeta( k ) )
C              (    0      )
C              (    z( k ) )
C
C  zeta( k )  is a scalar,  w( k ) is an  ( k - 1 )  element  vector and
C  z( k ) is an ( n - m ) element vector.  u( k ) is chosen to annhilate
C  the elements in the kth row of A.
C
C  The vector  u( k ) is returned in the kth element of  ZETA and in the
C  kth row of  A, such that  zeta( k ) is in  ZETA( k ), the elements of
C  w( k )  are in  a( k, 1 ), ..., a( k, k - 1 )  and  the  elements  of
C  z( k ) are in  a( k, m + 1 ), ..., a( k, n ).  The elements of  R are
C  returned in the  upper triangular part of  A.
C
C  3. Parameters
C     ==========
C
C  M      - INTEGER.
C
C           On entry, M must specify the number of rows of  A. M must be
C           at  least  zero. When  M = 0  then  an  immediate return  is
C           effected.
C
C           Unchanged on exit.
C
C  N      - INTEGER.
C
C           On entry, N must specify the number of columns of  A. N must
C           be at least m.
C
C           Unchanged on exit.
C
C  A      - REAL             array of DIMENSION ( LDA, n ).
C
C           Before entry, the leading  M by N  part of the array  A must
C           contain the matrix to be factorized.
C
C           On exit, the  M by M upper triangular part of A will contain
C           the  upper triangular  matrix  R,  and the  M by M  strictly
C           lower  triangular  part  of   A  and  the   M  by  ( N - M )
C           rectangular part of  A  to the right of the upper triangular
C           part will contain details of the  factorization as described
C           above.
C
C  LDA    - INTEGER.
C
C           On entry, LDA  must  specify  the  leading dimension of  the
C           array  A  as declared in the calling (sub) program. LDA must
C           be at least  m.
C
C           Unchanged on exit.
C
C  ZETA   - REAL             array of DIMENSION at least ( m ).
C
C           On exit,  ZETA( k )  contains the scalar  zeta( k )  for the
C           ( m - k + 1 )th   transformation.     If   P( k ) = I   then
C           ZETA( k ) = 0.0,   otherwise  ZETA( k )  contains  zeta( k )
C           as  described above  and  zeta( k )  is always in the  range
C           ( 1.0, sqrt( 2.0 ) ).
C
C  IFAIL  - INTEGER.
C
C           Before entry,  IFAIL  must contain one of the values -1 or 0
C           or 1 to specify noisy soft failure or noisy hard failure  or
C           silent soft failure. ( See Chapter P01 for further details.)
C
C           On successful  exit  IFAIL  will be  zero,  otherwise  IFAIL
C           will  be set to  -1  indicating that an  input parameter has
C           been  incorrectly  set. See  the  next section  for  further
C           details.
C
C  4. Diagnostic Information
C     ======================
C
C  IFAIL = -1
C
C     One or more of the following conditions holds:
C
C        M   .lt. 0
C        N   .lt. M
C        LDA .lt. M
C
C  If  on  entry,  IFAIL  was  either  -1 or 0  then  further diagnostic
C  information  will  be  output  on  the  error message  channel. ( See
C  routine  X04AAF. )
C
C  5. Further information
C     ===================
C
C  The first  k rows  of the  orthogonal matrix  P'  can be  obtained by
C  by calling NAG Library routine F01QKF, which overwrites the k rows of
C  P'  on the first  k rows of the array A.  P' is obtained by the call:
C
C     IFAIL = 0
C     CALL F01QKF( 'Separate', M, N, K, A, LDA, ZETA, WORK, IFAIL )
C
C  WORK must be a  max( m - 1, k - m, 1 ) element array.  If K is larger
C  than  M,  then  A  must have been declared to have at least  K  rows.
C
C  Operations involving the matrix  R  can readily  be performed by  the
C  Level 2 BLAS  routines  DTRSV and DTRMV , (see Chapter F06), but note
C  that no test for  near singularity of  R  is incorporated in  DTRSV .
C  If  R  is singular,  or nearly singular then the  NAG Library routine
C  F02WUF  can be  used to  determine  the  singular value decomposition
C  of  R.
C
C
C  Nag Fortran 77 Auxiliary linear algebra routine.
C
C  -- Written on 17-November-1987.
C     Sven Hammarling, Nag Central Office.
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE, ZERO
      PARAMETER         (ONE=1.0D+0,ZERO=0.0D+0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F01QJF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LDA, M, N
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), ZETA(*)
C     .. Local Scalars ..
      DOUBLE PRECISION  BETA
      INTEGER           IERR, K, MP1
C     .. Local Arrays ..
      CHARACTER*46      REC(1)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          DGEMV, DGER, F02WEX, P01ABY
C     .. Executable Statements ..
C
C     Check the input parameters.
C
      IERR = 0
      IF (M.LT.0) CALL P01ABY(M,'M',IFAIL,IERR,SRNAME)
      IF (N.LT.M) CALL P01ABY(N,'N',IFAIL,IERR,SRNAME)
      IF (LDA.LT.M) CALL P01ABY(LDA,'LDA',IFAIL,IERR,SRNAME)
      IF (IERR.GT.0) THEN
         WRITE (REC,FMT=99999) IERR
         IFAIL = P01ABF(IFAIL,-1,SRNAME,1,REC)
         RETURN
      END IF
C
C     Perform the factorization.
C
      IF (N.EQ.0) THEN
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
         RETURN
      END IF
      IF (M.LT.N) THEN
         MP1 = M + 1
      ELSE
         MP1 = M
      END IF
      DO 20 K = M, 1, -1
C
C        Use  a  Householder  reflection  to  zero  the  kth row  of  A.
C        First set up the reflection.
C
         BETA = A(K,K)
         CALL F02WEX(K-1,N-M,BETA,A(K,1),LDA,A(K,MP1),LDA,ZERO,ZETA(K))
         IF (ZETA(K).GT.ZERO) THEN
C
C           Put  zeta( k ) in a( k, k ).
C
            A(K,K) = ZETA(K)
C
C           We now perform the operation    A := A*P( k ).
C
C           Let  A1  denote the first k columns and  A2  denote the last
C           ( n - m ) columns of the first ( k - 1 ) rows of A and let x
C           be given by
C
C              x = (    w( k ) ).
C                  ( zeta( k ) )
C
C           Form  v = A1*x  in  ZETA.
C
            CALL DGEMV('No transpose',K-1,K,ONE,A,LDA,A(K,1),LDA,ZERO,
     *                 ZETA,1)
C
C           Now form  v := A2*z( k ) + v  in ZETA.
C
            CALL DGEMV('No transpose',K-1,N-M,ONE,A(1,MP1),LDA,A(K,MP1),
     *                 LDA,ONE,ZETA,1)
C
C           Now form  A1 := A1 - v*x'
C           and       A2 := A2 - v*z( k )'.
C
            CALL DGER(K-1,K,-ONE,ZETA,1,A(K,1),LDA,A,LDA)
            CALL DGER(K-1,N-M,-ONE,ZETA,1,A(K,MP1),LDA,A(1,MP1),LDA)
         END IF
         A(K,K) = BETA
   20 CONTINUE
C
      IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
      RETURN
C
C
C     End of F01QJF. ( DGERQ )
C
99999 FORMAT ('    The input parameters contained ',I2,' error(s)')
      END
      SUBROUTINE F01QKF(WHERET,M,N,NROWP,A,LDA,ZETA,WORK,IFAIL)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C
C  1. Purpose
C     =======
C
C  F01QKF  returns the first  nrowp rows of the n by n orthogonal matrix
C  P',  where  P  is given as the product of  Householder transformation
C  matrices.
C
C  This  routine  is  intended  for  use  following  NAG Fortran Library
C  routine  F01QJF.
C
C  2. Description
C     ===========
C
C  P is assumed to be given by
C
C     P = P( m )*P( m - 1 )*...*P( 1 ),
C
C  where
C
C     P( k ) = I - u( k )*u( k )',
C
C     u( k ) = (    w( k ) ),
C              ( zeta( k ) )
C              (    0      )
C              (    z( k ) )
C
C  zeta( k )  is a scalar,  w( k )  is a  ( k - 1 )  element vector  and
C  z( k )  is an  ( n - m ) element vector.
C
C  w( k )  must be supplied in the kth row of A in  elements  a( k, 1 ),
C  ..., a( k, k - 1 ).   z( k ) must be  supplied  in  the  kth  row  of
C  A  in elements  a( k, m + 1 ), ..., a( k, n )  and  zeta( k ) must be
C  supplied  either in  a( k, k )  or in  ZETA( k ),  depending upon the
C  parameter WHERET.
C
C  3. Parameters
C     ==========
C
C  WHERET - CHARACTER*1.
C
C           On entry,  WHERET  specifies where the elements of  zeta are
C           to be found as follows.
C
C           WHERET = 'I' or 'i'   ( In A )
C
C              The elements of zeta are in A.
C
C           WHERET = 'S' or 's'   ( Separate )
C
C              The  elements of  zeta  are  separate  from  A, in  ZETA.
C
C           Unchanged on exit.
C
C  M      - INTEGER.
C
C           On entry, M  must specify the number of rows of A. M must be
C           at least zero.
C
C           Unchanged on exit.
C
C  N      - INTEGER.
C
C           On entry, N  must specify the number of columns of A. N must
C           be at least m.
C
C           Unchanged on exit.
C
C  NROWP  - INTEGER.
C
C           On entry,  NROWP  must  specify  the required number of rows
C           of P.  NROWP must be at least zero and not be larger than n.
C           When   NROWP = 0  then  an  immediate  return  is  effected.
C
C           Unchanged on exit.
C
C  A      - REAL             array of DIMENSION ( LDA, n ).
C
C           Before entry, the leading  M by M  strictly lower triangular
C           part of the array A, and the M by ( N - M ) rectangular part
C           of A with top left hand corner at element A( 1, M + 1 ) must
C           contain  details  of  the  matrix   P.   In  addition,  when
C           WHERET = 'I' or 'i'  then  the  diagonal elements of  A must
C           contain the elements of zeta.
C
C           On exit, the first NROWP rows of the array A are overwritten
C           by the first  NROWP  rows  of the  n by n  orthogonal matrix
C           P'.
C
C           Unchanged on exit.
C
C  LDA    - INTEGER.
C
C           On  entry, LDA  must specify  the leading dimension  of  the
C           array  A  as declared in the calling (sub) program. LDA must
C           be at least max(m,nrowp).
C
C           Unchanged on exit.
C
C  ZETA   - REAL             array of  DIMENSION  at least  ( m ),  when
C           WHERET = 'S' or 's'.
C
C           Before entry with  WHERET = 'S' or 's', the array  ZETA must
C           contain  the  elements  of  zeta.  If  ZETA( k ) = 0.0  then
C           P( k )  is assumed to be I, otherwise  ZETA( k )  is assumed
C           to contain zeta( k ).
C
C           When  WHERET = 'I' or 'i', the array ZETA is not referenced.
C
C           Unchanged on exit.
C
C  WORK   - REAL             array  of  DIMENSION  at  least  ( lwork ),
C           where  lwork = max( m - 1, nrowp - m, 1 ).
C
C           Used as internal workspace.
C
C  IFAIL  - INTEGER.
C
C           Before entry,  IFAIL  must contain one of the values -1 or 0
C           or 1 to specify noisy soft failure or noisy hard failure  or
C           silent soft failure. ( See Chapter P01 for further details.)
C
C           On  successful exit  IFAIL  will be  zero,  otherwise  IFAIL
C           will  be set to   -1  indicating that an input parameter has
C           been  incorrectly  set. See  the  next  section  for further
C           details.
C
C  4. Diagnostic Information
C     ======================
C
C  IFAIL = -1
C
C     One or more of the following conditions holds:
C
C        WHERET .ne. 'I' or 'i' or 'S' or 's'
C        M      .lt. 0
C        N      .lt. M
C        NROWP  .lt. 0  .or.  NROWP .gt. N
C        LDA    .lt. M
C
C  If  on  entry,  IFAIL  was either  -1 or 0  then  further  diagnostic
C  information  will  be  output  on  the  error message  channel. ( See
C  routine  X04AAF. )
C
C
C  Nag Fortran 77 Auxiliary linear algebra routine.
C
C  -- Written on 3-December-1987.
C     Sven Hammarling and Mick Pont, Nag Central Office.
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE, ZERO
      PARAMETER         (ONE=1.0D+0,ZERO=0.0D+0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F01QKF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LDA, M, N, NROWP
      CHARACTER*1       WHERET
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), WORK(*), ZETA(*)
C     .. Local Scalars ..
      DOUBLE PRECISION  ZETAK
      INTEGER           IERR, K, MP1, NRP
C     .. Local Arrays ..
      CHARACTER*46      REC(1)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          DGEMV, DGER, DSCAL, F06FBF, F06QHF, P01ABW,
     *                  P01ABY
C     .. Intrinsic Functions ..
      INTRINSIC         MAX
C     .. Executable Statements ..
C
C     Check the input parameters.
C
      IERR = 0
      IF ((WHERET.NE.'I') .AND. (WHERET.NE.'i') .AND. (WHERET.NE.'S')
     *     .AND. (WHERET.NE.'s')) CALL P01ABW(WHERET,'WHERET',IFAIL,
     *    IERR,SRNAME)
      IF (M.LT.0) CALL P01ABY(M,'M',IFAIL,IERR,SRNAME)
      IF (N.LT.M) CALL P01ABY(N,'N',IFAIL,IERR,SRNAME)
      IF ((NROWP.LT.0) .OR. (NROWP.GT.N)) CALL P01ABY(NROWP,'NROWP',
     *    IFAIL,IERR,SRNAME)
      IF (LDA.LT.MAX(M,NROWP)) CALL P01ABY(LDA,'LDA',IFAIL,IERR,SRNAME)
      IF (IERR.GT.0) THEN
         WRITE (REC,FMT=99999) IERR
         IFAIL = P01ABF(IFAIL,-1,SRNAME,1,REC)
         RETURN
      END IF
C
      IF (NROWP.EQ.0) THEN
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
         RETURN
      END IF
      IF (N.GT.M) THEN
         MP1 = M + 1
      ELSE
         MP1 = M
      END IF
C
C     Start to form P. First set the elements above the leading diagonal
C     to zero.
C
      IF (M.GT.1) CALL F06QHF('Upper',M-1,M-1,ZERO,ZERO,A(1,2),LDA)
      IF (NROWP.GT.M) THEN
         NRP = NROWP - M
C
C        Set the last  ( nrowp - m )  rows of  P  to  those  of the unit
C        matrix.
C
         CALL F06QHF('General',NRP,M,ZERO,ZERO,A(MP1,1),LDA)
         CALL F06QHF('General',NRP,N-M,ZERO,ONE,A(MP1,MP1),LDA)
      ELSE
         NRP = 0
      END IF
      DO 20 K = 1, M
C
C        E( nrowp )*P' = E( nrowp )*P( 1 )'*...*P( m )',
C
C        where E( nrowp )  is the matrix containing the first nrowp rows
C        of I.
C
         IF ((WHERET.EQ.'S') .OR. (WHERET.EQ.'s')) THEN
            ZETAK = ZETA(K)
         ELSE
            ZETAK = A(K,K)
         END IF
C
C        If  ZETA( k ) .eq. zero  then P( k ) is special.
C
         IF (ZETAK.GT.ZERO) THEN
            A(K,K) = ZETAK
C
C           At the k( th ) step, we partition the matrix
C
C              B = E( nrowp )*P( 1 )'*...*P( k - 1 )',
C
C           as
C
C              B =   ( B1 0 B2 ),
C                    (  0 I  0 )
C                    ( B3 0 B4 )
C
C           where  B1  has dimensions  k by k,  B2  has dimensions  k by
C           ( n - m ),  B3  has dimensions  ( n - m ) by k  and  B4  has
C           dimensions  ( n - m ) by ( n - m ).  Also,  we partition the
C           vector  u( k )  as
C
C              u( k ) = ( u1 ).
C                       (  0 )
C                       ( u2 )
C
C           First form  v1 as all but the last element of B1*u1 + B2*u2,
C           and store it in  work( 1 ), ..., work( k - 1 ).
C
            CALL DGEMV('No transpose',K-1,K-1,ONE,A,LDA,A(K,1),LDA,ZERO,
     *                 WORK,1)
            CALL DGEMV('No transpose',K-1,N-M,ONE,A(1,MP1),LDA,A(K,MP1),
     *                 LDA,ONE,WORK,1)
C
C           Now  form  all  but  the   last  row   of  the  new   B1  as
C           B1 := B1 - v1*u1'.
C
            CALL DGER(K-1,K,-ONE,WORK,1,A(K,1),LDA,A,LDA)
C
C           Form  all   but   the   last  row   of   the   new   B2   as
C           B2 := B2 - v1*u2'.
C
            CALL DGER(K-1,N-M,-ONE,WORK,1,A(K,MP1),LDA,A(1,MP1),LDA)
C
C           Then form   v2 = B4*u2 + B3*u1,  and store it in  work( 1 ),
C           ..., work( nrp ).
C
            CALL DGEMV('No transpose',NRP,N-M,ONE,A(MP1,MP1),LDA,
     *                 A(K,MP1),LDA,ZERO,WORK(K),1)
            CALL DGEMV('No transpose',NRP,K-1,ONE,A(MP1,1),LDA,A(K,1),
     *                 LDA,ONE,WORK(K),1)
C
C           Form the new  B3  as  B3 := B3 - v2*u1'.
C
            CALL DGER(NRP,K,-ONE,WORK(K),1,A(K,1),LDA,A(MP1,1),LDA)
C
C           Form the new  B4  as  B4 := B4 - v2*u2'.
C
            CALL DGER(NRP,N-M,-ONE,WORK(K),1,A(K,MP1),LDA,A(MP1,MP1),
     *                LDA)
C
C           Now form the last rows of the new  B1 and B2.
C
            CALL DSCAL(K,-ZETAK,A(K,1),LDA)
            A(K,K) = ONE + A(K,K)
            CALL DSCAL(N-M,-ZETAK,A(K,MP1),LDA)
         ELSE
            A(K,K) = ONE
            CALL F06FBF(K-1,ZERO,A(K,1),LDA)
            CALL F06FBF(N-M,ZERO,A(K,MP1),LDA)
         END IF
   20 CONTINUE
C
      IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
      RETURN
C
C
C     End of F01QKF. ( SGEFP )
C
99999 FORMAT ('    The input parameters contained ',I2,' error(s)')
      END
      SUBROUTINE F02EAZ(AMAX,RMIN,RMAX,SIGMA,SCALE)
C     MARK 16 RELEASE. NAG COPYRIGHT 1992.
C
C     F02EAZ determines a scaling factor SIGMA such that if AMAX
C     lies outside the range RMIN to RMAX, then AMAX*SIGMA lies within
C     this range (except that SIGMA must not overflow or underflow).
C     SIGMA is constrained to be a power of the base of
C     floating-point arithmetic.
C
C     SCALE is set to .TRUE. if scaling is required.
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO, ONE
      PARAMETER         (ZERO=0.0D+0,ONE=1.0D+0)
C     .. Scalar Arguments ..
      DOUBLE PRECISION  AMAX, RMAX, RMIN, SIGMA
      LOGICAL           SCALE
C     .. Local Scalars ..
      DOUBLE PRECISION  BASE, FAC, SIGLOG
      INTEGER           IPSIG
C     .. External Functions ..
      INTEGER           X02BHF, X02BKF, X02BLF
      EXTERNAL          X02BHF, X02BKF, X02BLF
C     .. Intrinsic Functions ..
      INTRINSIC         INT, LOG, MIN, MOD
C     .. Executable Statements ..
C
      BASE = X02BHF()
      IF (AMAX.GT.RMAX) THEN
C
C        SIGMA should be the largest power of the base <= RMAX/AMAX
C
         SCALE = .TRUE.
         SIGLOG = LOG(AMAX) - LOG(RMAX)
         FAC = ONE/BASE
      ELSE IF (AMAX.LT.RMIN .AND. AMAX.GT.ZERO) THEN
C
C        SIGMA should be the smallest power of the base > RMIN/AMAX
C
         SCALE = .TRUE.
         SIGLOG = LOG(RMIN) - LOG(AMAX)
         FAC = BASE
      ELSE
         SCALE = .FALSE.
      END IF
      SIGMA = ONE
      IF (SCALE) THEN
         IPSIG = MIN(INT(SIGLOG/LOG(BASE))+1,-X02BKF(),X02BLF()-1)
C
C        SIGMA = FAC**IPSIG
C
         GO TO 40
   20    CONTINUE
         FAC = FAC*FAC
   40    IF (MOD(IPSIG,2).GT.0) SIGMA = SIGMA*FAC
         IPSIG = IPSIG/2
         IF (IPSIG.GT.0) GO TO 20
      END IF
      RETURN
      END
      SUBROUTINE F02EBF(JOB,N,A,LDA,WR,WI,VR,LDVR,VI,LDVI,WORK,LWORK,
     *                  IFAIL)
C     MARK 16 RELEASE. NAG COPYRIGHT 1992.
C
C     F02EBF computes all the eigenvalues, and optionally all the
C     eigenvectors, of a real general matrix A.
C
C     F02EBF is a driver routine which calls computational routines
C     from LAPACK in Chapter F08.
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO, ONE
      PARAMETER         (ZERO=0.0D+0,ONE=1.0D+0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F02EBF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LDA, LDVI, LDVR, LWORK, N
      CHARACTER         JOB
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), VI(LDVI,*), VR(LDVR,*), WI(*),
     *                  WORK(LWORK), WR(*)
C     .. Local Scalars ..
      DOUBLE PRECISION  AMAX, CS, R, RMAX, SCL, SIGMA, SN
      INTEGER           I, IBAL, IERR, IHI, ILO, IMAX, INFO, ITAU, IWRK,
     *                  J, LWRK, M, NREC
      LOGICAL           SCALE, WANTV
      CHARACTER         COMPZ, JOB2
C     .. Local Arrays ..
      LOGICAL           SELECT(1)
      CHARACTER*80      REC(2)
C     .. External Functions ..
      DOUBLE PRECISION  DNRM2, F06BNF, F06RAF, X02AJF, X02AMF
      INTEGER           IDAMAX, P01ABF
      EXTERNAL          DNRM2, F06BNF, F06RAF, X02AJF, X02AMF, IDAMAX,
     *                  P01ABF
C     .. External Subroutines ..
      EXTERNAL          DCOPY, DGEBAK, DGEBAL, DGEHRD, DHSEQR, DORGHR,
     *                  DROT, DSCAL, DSWAP, DTREVC, F02EAZ, F06QFF,
     *                  F08HEW, P01ABW, P01ABY
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN, SQRT
C     .. Executable Statements ..
C
C     Test the input parameters
C
      WANTV = (JOB.EQ.'V') .OR. (JOB.EQ.'v')
C
      IERR = 0
      NREC = 0
      IF ( .NOT. WANTV .AND. JOB.NE.'N' .AND. JOB.NE.'n')
     *    CALL P01ABW(JOB,'JOB',IFAIL,IERR,SRNAME)
      IF (N.LT.0) CALL P01ABY(N,'N',IFAIL,IERR,SRNAME)
      IF (LDA.LT.MAX(1,N)) CALL P01ABY(LDA,'LDA',IFAIL,IERR,SRNAME)
      IF (WANTV .AND. LDVR.LT.MAX(1,N) .OR. LDVR.LT.1) CALL P01ABY(LDVR,
     *    'LDVR',IFAIL,IERR,SRNAME)
      IF (WANTV .AND. LDVI.LT.MAX(1,N) .OR. LDVI.LT.1) CALL P01ABY(LDVI,
     *    'LDVI',IFAIL,IERR,SRNAME)
      IF (LWORK.LT.MAX(1,4*N)) CALL P01ABY(LWORK,'LWORK',IFAIL,IERR,
     *                              SRNAME)
C
      IF (IERR.GT.0) THEN
         WRITE (REC,FMT=99999) IERR
         IERR = 1
         NREC = 1
         GO TO 200
      END IF
C
C     Get machine constants
C
      RMAX = SQRT(X02AJF()/X02AMF())
C
C     Scale matrix so that maximum magnitude of an element lies
C     in the range ONE to RMAX
C
      AMAX = F06RAF('Max',N,N,A,LDA,WORK)
      CALL F02EAZ(AMAX,ONE,RMAX,SIGMA,SCALE)
      IF (SCALE) THEN
         DO 20 J = 1, N
            CALL DSCAL(N,SIGMA,A(1,J),1)
   20    CONTINUE
      END IF
C
      IBAL = 1
      ITAU = N + IBAL
      IWRK = N + ITAU
      LWRK = LWORK - IWRK + 1
C
C     Balance the matrix
C
      CALL DGEBAL('Both',N,A,LDA,ILO,IHI,WORK(IBAL),INFO)
C
C     Reduce to upper Hessenberg form
C
      CALL DGEHRD(N,ILO,IHI,A,LDA,WORK(ITAU),WORK(IWRK),LWRK,INFO)
C
      IF (WANTV) THEN
C
C        Copy Householder vectors to VR
C
         CALL F06QFF('Lower',N,N,A,LDA,VR,LDVR)
C
C        Generate the orthogonal matrix Q in VR
C
         CALL DORGHR(N,ILO,IHI,VR,LDVR,WORK(ITAU),WORK(IWRK),LWRK,INFO)
      END IF
C
C     Compute eigenvalues, and the complete Schur factorization if
C     eigenvectors are required
C
      IF (WANTV) THEN
         JOB2 = 'S'
         COMPZ = 'V'
      ELSE
         JOB2 = 'E'
         COMPZ = 'N'
      END IF
      CALL DHSEQR(JOB2,COMPZ,N,ILO,IHI,A,LDA,WR,WI,VR,LDVR,WORK(IWRK),
     *            LWRK,IERR)
C
      IF (IERR.NE.0) THEN
         WRITE (REC,FMT=99998) IERR - 1
         IERR = 2
         NREC = 2
         GO TO 200
      END IF
C
      IF (SCALE) THEN
C
C        Rescale real parts of eigenvalues
C
         CALL DSCAL(N,ONE/SIGMA,WR,1)
C
         IF ( .NOT. WANTV) THEN
C
C           Rescale imaginary parts of eigenvalues
C
            CALL DSCAL(N,ONE/SIGMA,WI,1)
         ELSE
C
C           Rescale Schur form
C
            DO 40 J = 1, N
               CALL DSCAL(MIN(J+1,N),ONE/SIGMA,A(1,J),1)
   40       CONTINUE
            IF (SIGMA.GT.ONE) THEN
C
C              Adjust Schur form if rescaling toward underflow has
C              resulted in a 2-by-2 block with A(I+1,I).ne.0 and
C              A(I,I+1).eq.0.
C
               DO 60 I = ILO, IHI - 1
                  IF (A(I+1,I).NE.ZERO .AND. A(I,I+1).EQ.ZERO) THEN
C
C                    Interchange rows and columns I and I+1 in Schur
C                    form, and columns I and I+1 of Schur vectors
C
                     CALL DSWAP(I-1,A(1,I),1,A(1,I+1),1)
                     IF (I.LT.N-1) CALL DSWAP(N-I-1,A(I,I+2),LDA,
     *                                        A(I+1,I+2),LDA)
                     A(I,I+1) = A(I+1,I)
                     A(I+1,I) = ZERO
                     CALL DSWAP(N,VR(1,I),1,VR(1,I+1),1)
                  END IF
   60          CONTINUE
            END IF
C
C           Recompute imaginary parts of eigenvalues after rescaling
C
            DO 80 I = ILO, IHI
               WI(I) = ZERO
   80       CONTINUE
            DO 100 I = ILO, IHI - 1
               IF (A(I+1,I).NE.ZERO) THEN
                  WI(I) = SQRT(ABS(A(I+1,I)))*SQRT(ABS(A(I,I+1)))
                  WI(I+1) = -WI(I)
               END IF
  100       CONTINUE
         END IF
      END IF
C
      IF (WANTV) THEN
C
C        Compute eigenvectors of balanced matrix
C
         IWRK = IBAL + N
         CALL DTREVC('Right','Overwrite',SELECT,N,A,LDA,VI,LDVI,VR,LDVR,
     *               N,M,WORK(IWRK),INFO)
C
C        Transform eigenvectors back to those of original matrix
C
         CALL DGEBAK('Both','Right',N,ILO,IHI,WORK(IBAL),N,VR,LDVR,INFO)
C
C        Normalize eigenvectors to have unit 2-norm and so that
C        element of largest absolute value is real and positive;
C        store real parts in VR and imaginary parts in VI
C
         DO 180 J = 1, N
            IF (WI(J).EQ.ZERO) THEN
               I = IDAMAX(N,VR(1,J),1)
               SCL = DNRM2(N,VR(1,J),1)
               IF (VR(I,J).LT.ZERO)
     *            SCL = -SCL
               CALL DSCAL(N,ONE/SCL,VR(1,J),1)
               DO 120 I = 1, N
                  VI(I,J) = ZERO
  120          CONTINUE
            ELSE IF (WI(J).GT.ZERO) THEN
               SCL = F06BNF(DNRM2(N,VR(1,J),1),DNRM2(N,VR(1,J+1),1))
               CALL DSCAL(N,ONE/SCL,VR(1,J),1)
               CALL DSCAL(N,ONE/SCL,VR(1,J+1),1)
               DO 140 I = 1, N
                  WORK(I) = VR(I,J)**2 + VR(I,J+1)**2
  140          CONTINUE
               IMAX = IDAMAX(N,WORK,1)
               CALL F08HEW(VR(IMAX,J),VR(IMAX,J+1),CS,SN,R)
               IF (R.LT.ZERO) THEN
                  CS = -CS
                  SN = -SN
               END IF
               CALL DROT(N,VR(1,J),1,VR(1,J+1),1,CS,SN)
               VR(IMAX,J+1) = ZERO
               CALL DCOPY(N,VR(1,J+1),1,VI(1,J),1)
               CALL DCOPY(N,VR(1,J),1,VR(1,J+1),1)
               DO 160 I = 1, N
                  VI(I,J+1) = -VI(I,J)
  160          CONTINUE
            END IF
  180    CONTINUE
      END IF
C
  200 CONTINUE
      IFAIL = P01ABF(IFAIL,IERR,SRNAME,NREC,REC)
      RETURN
C
99999 FORMAT (' ** The input parameters contained ',I2,' error(s)')
99998 FORMAT (' ** The QR algorithm failed to converge:',/' ** ',I6,
     *       ' eigenvalues have converged')
      END
      SUBROUTINE F02SWZ(N,A,LDA,D,E,NCOLY,Y,LDY,WANTQ,Q,LDQ,IFAIL)
C     MARK 18 RELEASE. NAG COPYRIGHT 1997.
C
C     Originally called F02SWF.
C
C  1. Purpose
C     =======
C
C  F02SWZ  reduces the  n by n upper triangular matrix  R  to bidiagonal
C  form by means of orthogonal transformations.
C
C  2. Description
C     ===========
C
C  The n by n upper triangular matrix R is factorized as
C
C     R = Q*B*P',
C
C  where  Q and P  are  n by n orthogonal matrices and  B  is an  n by n
C  bidiagonal matrix.
C
C  Optionally the matrices Q and/or the matrix Z given by
C
C     Z = Q'*Y,
C
C  where  Y  is an  n by ncoly matrix, can also be returned. Information
C  on the  matrix  P  is returned  in the  upper triangular part  of the
C  array A.
C
C  R  is reduced to the bidiagonal matrix  B by applying plane rotations
C  from the  right  to introduce the required  zeros and applying  plane
C  rotations from the left to maintain the  zeros in the lower triangle.
C
C  At the  kth step,  the  zeros are introduced into the  kth row of  R,
C  k = 1, 2, ..., n - 2,  by a backward sequence of rotations in  planes
C  ( j - 1, j ), j = n, n - 1, ..., k + 2, the jth rotation,  P( k, j ),
C  being chosen  to  introduce a  zero  into the  ( k, j ) element. This
C  rotation  introduces  an  unwanted  element  into  the   ( j, j - 1 )
C  position, which is eliminated by a rotation, Q( k, j ), from the left
C  in the ( j - 1, j ) plane. Thus at the kth step we have
C
C     R( k ) = Q( k )*R( k - 1 )*P( k )',
C
C  where
C
C     Q( k ) = Q( k, k + 2 )*...*Q( k, n )   and
C     P( k ) = P( k, k + 2 )*...*P( k, n ),
C
C  with
C
C     R( 0 ) = R   and   R( n - 2 ) = B.
C
C  The two by two rotation parts of  P( k, j )  and  Q( k, j )  have the
C  form
C
C     (  c  s ).
C     ( -s  c )
C
C  The value  t,  where  t  is the  tangent  of the  angle  that defines
C  P( k, j ),  is returned in the element  a( k, j ).  The corresponding
C  c and s  may be recovered from  t  by a call to routine  F06BCF.  See
C  section 5  for information on computing  P' and/or P'*X  for a  given
C  matrix  X.
C
C  The matrices Q and P are given by
C
C     Q' = Q( n - 2 )*...*Q( 2 )*Q( 1 )   and
C     P' = P( n - 2 )*...*P( 2 )*P( 1 ).
C
C  3. Parameters
C     ==========
C
C  N      - INTEGER.
C
C           On entry, N specifies the order of the matrix  R.  N must be
C           at least  zero.  When  N = 0  then  an  immediate return  is
C           effected.
C
C           Unchanged on exit.
C
C  A      - REAL             array of DIMENSION ( LDA, n )
C
C           Before entry, the leading  N by N  upper triangular  part of
C           the array  A  must contain the  upper triangular  matrix  R.
C
C           On exit, the  N by N  upper triangular  part of the array  A
C           above the  first super-diagonal  will contain information on
C           the matrix  P, as described in section 2 above. The diagonal
C           elements of  A  return the  diagonal elements of  B  and the
C           elements  of  the  first  super-diagonal  of  A  return  the
C           super-diagonal elements of  B. The strictly lower triangular
C           part of A is not referenced.
C
C  LDA    - INTEGER.
C
C           On  entry,  LDA  must specify  the leading dimension  of the
C           array  A as declared in the calling (sub) program. LDA  must
C           be at least N.
C
C           Unchanged on exit.
C
C  D      - REAL             array of DIMENSION at least ( n ).
C
C           On  exit,   D  contains  the  n  diagonal  elements  of  the
C           bidiagonal matrix B, with  d( i ) = b( i, i ).
C
C  E      - REAL             array    of      DIMENSION      at    least
C           ( max( 1, n - 1 ) ).
C
C           On exit, E contains the ( n - 1 ) super-diagonal elements of
C           the  bidiagonal  matrix  B,  with    e( i ) = b( i, i + 1 ),
C           i = 1, 2, ..., n - 1.
C
C  NCOLY  - INTEGER.
C
C           On entry,  NCOLY  must specify the  number of columns of the
C           matrix  Y  and must be at least  zero.  When  NCOLY = 0  the
C           array  Y  is not referenced.
C
C           Unchanged on exit.
C
C  Y      - REAL             array of DIMENSION ( LDY, ncoly ).
C
C           Before entry with  NCOLY .gt. 0, the leading n by ncoly part
C           of the array  Y  must contain the  matrix to be  transformed
C           and  on  exit  Y  is overwritten  by the  n by ncoly  matrix
C           Q'*Y.
C
C           When  NCOLY = 0  the array  Y  is not referenced.
C
C  LDY    - INTEGER.
C
C           On  entry,  LDY  must specify  the leading dimension  of the
C           array  Y  as declared  in the  calling  (sub) program.  When
C           NCOLY .gt. 0  then LDY must be at least n.
C
C           Unchanged on exit.
C
C  WANTQ  - LOGICAL.
C
C           On entry, WANTQ must be .TRUE. if the orthogonal matrix Q is
C           required and must be .FALSE. otherwise.
C
C           Unchanged on exit.
C
C  Q      - REAL             array of DIMENSION ( LDQ, n ).
C
C           On exit with WANTQ as .TRUE., the leading n by n part of the
C           array Q will contain the orthogonal matrix Q.
C
C           When  WANTQ  is .FALSE.  the  array  Q  is  not  referenced.
C
C  LDQ    - INTEGER.
C
C           On  entry,  LDQ  must specify  the leading dimension  of the
C           array Q as declared in the calling (sub) program. When WANTQ
C           is .TRUE. then LDQ must be at least n.
C
C           Unchanged on exit.
C
C  IFAIL  - INTEGER.
C
C           Before entry,  IFAIL  must contain one of the values -1 or 0
C           or 1 to specify noisy soft failure or noisy hard failure  or
C           silent soft failure. ( See Chapter P01 for further details.)
C
C           On  successful exit  IFAIL  will be  zero,  otherwise  IFAIL
C           will  be set to  -1  indicating that an  input parameter has
C           been  incorrectly  set. See  the  next  section  for further
C           details.
C
C  4. Diagnostic Information
C     ======================
C
C  IFAIL = -1
C
C     One or more of the following conditions holds:
C
C        N     .lt. 0
C        LDA   .lt. N
C        NCOLY .lt. 0
C        NCOLY .gt. 0     and  LDY .lt. N
C        WANTQ  is  true  and  LDQ .lt. N
C
C  If  on  entry,  IFAIL  was either  -1 or 0  then  further  diagnostic
C  information  will  be  output  on  the  error message  channel. ( See
C  routine  X04AAF. )
C
C  5. Further information
C     ===================
C
C  Following the use of this routine the matrices  P'*X and/or P' may be
C  obtained by calls to the auxiliary linear algebra routine F02SXZ. The
C  matrix  W = P'*X,  where  X is an  nrowx by n matrix, may be found by
C  the call
C
C     IFAIL = 0
C     CALL F02SXZ( N, A, LDA, NROWX, X, LDX, WORK, IFAIL )
C
C  for which  W  will be  overwritten on  X.  WORK  must be an  array of
C  length  at  least  2*( n - 1 )  and  is used  as  internal workspace.
C
C  The matrix P' may be found by the call
C
C     IFAIL = 0
C     CALL F02SXZ( N, A, LDA, 0, DUMMY, 1, WORK, IFAIL )
C
C  where  A must be as returned from  F02SWZ.  P' will be overwritten on
C  A and  DUMMY  is an array of  length at least  1, which will  not  be
C  referenced by  this call.  WORK  is as  for  the  previous call.  See
C  routine  F02SXZ  for further details.
C
C
C  Nag auxiliary linear algebra routine.
C
C  -- Written on 22-July-1987.
C     Sven Hammarling, Nag Central Office.
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE, ZERO
      PARAMETER         (ONE=1.0D+0,ZERO=0.0D+0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F02SWZ')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LDA, LDQ, LDY, N, NCOLY
      LOGICAL           WANTQ
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), D(*), E(*), Q(LDQ,*), Y(LDY,*)
C     .. Local Scalars ..
      INTEGER           I, IERR, J, K
C     .. Local Arrays ..
      CHARACTER*80      REC(1)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          DCOPY, F06FQF, F06QTF, F06QXF, P01ABY
C     .. Executable Statements ..
C
C     Check the input parameters.
C
      IERR = 0
      IF (N.LT.0) CALL P01ABY(N,'N',IFAIL,IERR,SRNAME)
      IF (LDA.LT.N) CALL P01ABY(LDA,'LDA',IFAIL,IERR,SRNAME)
      IF (NCOLY.LT.0) CALL P01ABY(NCOLY,'NCOLY',IFAIL,IERR,SRNAME)
      IF ((NCOLY.GT.0) .AND. (LDY.LT.N)) CALL P01ABY(LDY,'LDY',IFAIL,
     *    IERR,SRNAME)
      IF ((WANTQ) .AND. (LDQ.LT.N)) CALL P01ABY(LDQ,'LDQ',IFAIL,IERR,
     *    SRNAME)
      IF (IERR.GT.0) THEN
         WRITE (REC,FMT=99999) IERR
         IFAIL = P01ABF(IFAIL,-1,SRNAME,1,REC)
         RETURN
      END IF
C
C     Perform the factorization. First reduce R to C.
C
      IF (N.EQ.0) THEN
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
         RETURN
      END IF
      DO 20 K = 1, N - 2
C
C        Set up  the  rotations  that put the  zeros  into the  kth row.
C        The cosines and sines that define  P( k ) are returned in e and
C        d.
C
         CALL F06FQF('Variable pivot','Backwards',N-K-1,A(K,K+1),
     *               A(K,K+2),LDA,E(K+1),D(K+1))
C
C        Form  R( k ) = Q( k )*R( k - 1 )*P( k )'. The cosines and sines
C        that define Q( k ) are overwritten on e and d.
C
         CALL F06QTF('Right side',N-K,1,N-K,E(K+1),D(K+1),A(K+1,K+1),
     *               LDA)
C
C        Form Q( k )*Y.
C
         IF (NCOLY.GT.0) CALL F06QXF('Left side','Variable pivot',
     *                               'Backwards',N,NCOLY,K+1,N,E,D,Y,
     *                               LDY)
C
C        If Q is required store the cosines and sines that define Q( k )
C        in the kth row and column of Q.
C
         IF (WANTQ) THEN
            CALL DCOPY(N-K-1,E(K+1),1,Q(K,K+2),LDQ)
            CALL DCOPY(N-K-1,D(K+1),1,Q(K+2,K),1)
         END IF
   20 CONTINUE
      IF (WANTQ) THEN
C
C        Form the matrix Q as
C
C           Q = Q( 1 )'*...*Q( n - 2 )'*I.
C
         IF (N.GT.1) THEN
            Q(N,N) = ONE
            Q(N-1,N) = ZERO
            Q(N,N-1) = ZERO
            IF (N.GT.2) THEN
               DO 80 K = N - 2, 1, -1
                  Q(K+1,K+1) = ONE
                  Q(K,K+1) = ZERO
                  DO 40 J = K + 2, N
                     D(J-1) = Q(K,J)
                     Q(K,J) = ZERO
   40             CONTINUE
                  Q(K+1,K) = ZERO
                  DO 60 I = K + 2, N
                     E(I-1) = -Q(I,K)
                     Q(I,K) = ZERO
   60             CONTINUE
                  CALL F06QXF('Left side','Variable pivot','Forward',
     *                        N-K,N-K,1,N-K,D(K+1),E(K+1),Q(K+1,K+1),
     *                        LDQ)
   80          CONTINUE
            END IF
         END IF
         Q(1,1) = ONE
      END IF
C
C     Put the elements of B into the arrays D and E.
C
      DO 100 K = 1, N - 1
         D(K) = A(K,K)
         E(K) = A(K,K+1)
  100 CONTINUE
      D(N) = A(N,N)
C
      IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
      RETURN
C
C
C     End of F02SWZ. ( SUTBI )
C
99999 FORMAT ('    The input parameters contained ',I2,' error(s)')
      END
      SUBROUTINE F02SXZ(N,A,LDA,NCOLY,Y,LDY,WORK,IFAIL)
C     MARK 18 RELEASE. NAG COPYRIGHT 1979.
C
C     Originally called F02SXF.
C
C  1. Purpose
C     =======
C
C  F02SXZ returns either the matrix Z given by
C
C     Z = P'*Y,
C
C  where  Y is an  n by ncoly matrix and  P is the right-hand orthogonal
C  matrix  associated  with the  transformation of an  upper  triangular
C  matrix to bidiagonal form, or the matrix  P'  itself.
C
C  This routine must be preceded by a call to routine F02SWZ.
C
C  2. Description
C     ===========
C
C  Routine  F02SWZ factorizes the  n by n upper triangular matrix  R  as
C
C     R = Q*B*P',
C
C  where  Q and P  are  n by n orthogonal matrices and  B  is an  n by n
C  bidiagonal matrix and information on the matrix  P is returned in the
C  upper triangular part of the array A. Following a call to F02SWZ this
C  routine may be used to find either the  n by ncoly  matrix  Z  or the
C  n by n orthogonal matrix P'.
C
C  3. Parameters
C     ==========
C
C  N      - INTEGER.
C
C           On entry, N specifies the order of the matrix  R.  N must be
C           at least  zero.  When  N = 0  then  an  immediate return  is
C           effected.
C
C           Unchanged on exit.
C
C  A      - REAL             array of DIMENSION ( LDA, n )
C
C           Before entry, the leading  N by N  upper triangular  part of
C           the array  A  must contain information on the matrix  P,  as
C           returned  by  routine  F02SWZ.
C
C           On exit  with   NCOLY .gt. 0,  the  array  A  is  unchanged.
C           On exit  with   NCOLY = 0,  the leading  N by N  part of the
C           array  A  is overwritten by the matrix  P'.
C
C  LDA    - INTEGER.
C
C           On  entry,  LDA  must specify  the leading dimension  of the
C           array  A as declared in the calling (sub) program. LDA  must
C           be at least N.
C
C           Unchanged on exit.
C
C  NCOLY  - INTEGER.
C
C           On entry ,  NCOLY  must specify the number of columns of the
C           matrix  Y  and must be at least  zero. When  NCOLY = 0  then
C           the array  Y  is not referenced, but instead the array  A is
C           overwritten by the matrix  P'.
C
C           Unchanged on exit.
C
C  Y      - REAL             array of DIMENSION ( LDY, ncoly ).
C
C           Before entry with  NCOLY .gt. 0, the leading n by ncoly part
C           of the array Y must contain the matrix to be transformed and
C           on exit  Y  is overwritten by the  n by ncoly  matrix  P'*Y.
C
C           When  NCOLY = 0  then the array  Y is not referenced.
C
C
C  LDY    - INTEGER.
C
C           On  entry,  LDY  must specify  the leading dimension  of the
C           array  Y  as  declared  in the  calling (sub) program.  When
C           NCOLY .gt. 0  then LDY must be at least n.
C
C           Unchanged on exit.
C
C  WORK   - REAL             array    of      DIMENSION      at    least
C           max( 1, 2*( n - 1 ) ).
C
C           Used as internal workspace.
C
C  IFAIL  - INTEGER.
C
C           Before entry,  IFAIL  must contain one of the values -1 or 0
C           or 1 to specify noisy soft failure or noisy hard failure  or
C           silent soft failure. ( See Chapter P01 for further details.)
C
C           On  successful exit  IFAIL  will be  zero,  otherwise  IFAIL
C           will  be set to  -1  indicating that an  input parameter has
C           been  incorrectly  set. See  the  next  section  for further
C           details.
C
C  4. Diagnostic Information
C     ======================
C
C  IFAIL = -1
C
C     One or more of the following conditions holds:
C
C        N     .lt. 0
C        LDA   .lt. N
C        NCOLY .lt. 0
C        NCOLY .gt. 0  and  LDY .lt. N
C
C  If  on  entry,  IFAIL  was either  -1 or 0  then  further  diagnostic
C  information  will  be  output  on  the  error message  channel. ( See
C  routine  X04AAF. )
C
C
C  Nag auxiliary linear algebra routine.
C
C  -- Written on 22-July-1987.
C     Sven Hammarling, Nag Central Office.
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE, ZERO
      PARAMETER         (ONE=1.0D+0,ZERO=0.0D+0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F02SXZ')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LDA, LDY, N, NCOLY
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), WORK(*), Y(LDY,*)
C     .. Local Scalars ..
      INTEGER           IERR, J, K
C     .. Local Arrays ..
      CHARACTER*80      REC(1)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          F06BCF, F06FBF, F06QXF, P01ABY
C     .. Executable Statements ..
C
C     Check the input parameters.
C
      IERR = 0
      IF (N.LT.0) CALL P01ABY(N,'N',IFAIL,IERR,SRNAME)
      IF (LDA.LT.N) CALL P01ABY(LDA,'LDA',IFAIL,IERR,SRNAME)
      IF (NCOLY.LT.0) CALL P01ABY(NCOLY,'NCOLY',IFAIL,IERR,SRNAME)
      IF ((NCOLY.GT.0) .AND. (LDY.LT.N)) CALL P01ABY(LDY,'LDY',IFAIL,
     *    IERR,SRNAME)
      IF (IERR.GT.0) THEN
         WRITE (REC,FMT=99999) IERR
         IFAIL = P01ABF(IFAIL,-1,SRNAME,1,REC)
         RETURN
      END IF
      IF (N.EQ.0) THEN
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
         RETURN
      END IF
      IF (NCOLY.GT.0) THEN
C
C        Form Z as
C
C           Z = P( n - 2 )*...*P( 2 )*P( 1 )*Y.
C
         DO 40 K = 1, N - 2
C
C           Recover the rotations that put the zeros into the kth row of
C           R. The cosines and sines that define  P( k ) are returned in
C           work( 1 ), ..., work( n - 1 )       and      work( n ), ...,
C           work( 2*( n - 1 ) ).
C
            DO 20 J = K + 2, N
               CALL F06BCF(A(K,J),WORK(J-1),WORK(N+J-2))
   20       CONTINUE
C
C           Form P( k )*Y.
C
            CALL F06QXF('Left','Variable pivot','Backwards',N,NCOLY,K+1,
     *                  N,WORK,WORK(N),Y,LDY)
   40    CONTINUE
      ELSE
C
C        Form P' as
C
C           P' = I*( P( n - 2 )*...*P( 2 )*P( 1 ) ).
C
         IF (N.GT.1) THEN
            A(N,N) = ONE
            A(N-1,N) = ZERO
            A(N,N-1) = ZERO
            IF (N.GT.2) THEN
               DO 80 K = N - 2, 1, -1
                  A(K+1,K+1) = ONE
                  A(K,K+1) = ZERO
                  DO 60 J = K + 2, N
                     CALL F06BCF(-A(K,J),WORK(J-1),WORK(N+J-2))
                     A(K,J) = ZERO
   60             CONTINUE
                  CALL F06FBF(N-K,ZERO,A(K+1,K),1)
                  CALL F06QXF('Right','Variable pivot','Forward',N-K,
     *                        N-K,1,N-K,WORK(K+1),WORK(N+K),A(K+1,K+1),
     *                        LDA)
   80          CONTINUE
            END IF
         END IF
         A(1,1) = ONE
      END IF
C
      IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
      RETURN
C
C
C     End of F02SXZ. ( SBIAP  )
C
99999 FORMAT ('    The input parameters contained ',I2,' error(s)')
      END
      SUBROUTINE F02SYZ(N,D,E,NCOLB,B,LDB,NROWY,Y,LDY,NCOLZ,Z,LDZ,WORK,
     *                  IFAIL)
C     MARK 18 RELEASE. NAG COPYRIGHT 1997.
C
C     Originally called F02SYF.
C
C  1. Purpose
C     =======
C
C  F02SYZ  reduces  an  n by n  real bidiagonal matrix  to diagonal form
C  by  means  of  orthogonal transformations.  The  transformations  may
C  optionally be applied to given real matrices.
C
C  2. Description
C     ===========
C
C  The n by n bidiagonal matrix A is factorized as
C
C     A = Q*S*P',
C
C  where  Q and P  are  n by n orthogonal matrices and  S  is an  n by n
C  diagonal matrix  with  non-negative diagonal elements.  This  is  the
C  singular value decomposition  of the matrix A.
C
C  The diagonal elements of  S are the singular values of  A and will be
C  arranged in descending order. The columns of Q and P are the left and
C  right singular vectors of A respectively.
C
C  Optionally the matrices  C and/or Y and/or Z  given by
C
C     C = Q'*B,   W = Y*Q,   X = P'*Z,
C
C  where  B  is an  n by ncolb  matrix, Y  is an  nrowy by n  matrix and
C  Z  is an  n by ncolz  matrix, can also be returned.
C
C  The factorization is obtained by the  Golub-Reinsch version of the QR
C  algorithm.
C
C  3. Parameters
C     ==========
C
C  N      - INTEGER.
C
C           On entry, N specifies the order of the matrix  A.  N must be
C           at least  zero.  When  N = 0  then  an  immediate return  is
C           effected.
C
C           Unchanged on exit.
C
C  D      - REAL array of DIMENSION at least ( n ).
C
C           On entry, D must contain the diagonal elements of the n by n
C           bidiagonal matrix A such that
C
C              d( i ) = a( i, i ), i = 1, 2, ..., n.
C
C           On exit, D contains the  n singular values of  A arranged in
C           descending order of magnitude so that
C
C              d( 1 ) .ge. d( 2 ) .ge. ... .ge. d( n ) .ge. 0.
C
C  E      - REAL array of DIMENSION at least ( max( 1, n - 1 ) ).
C
C           On  entry,  E  must  contain  the  ( n - 1 )  super-diagonal
C           elements of the bidiagonal matrix A, with
C
C              e( i ) = a( i, i + 1 ), i = 1, 2, ..., n - 1.
C
C           E  is  used  as  internal  workspace  by  F02SYZ  and so the
C           elements are changed on exit.
C
C  NCOLB  - INTEGER.
C
C           On entry,  NCOLB  must specify the  number of columns of the
C           matrix  B  and must be at least  zero.  When  NCOLB = 0  the
C           array B is not referenced.
C
C           Unchanged on exit.
C
C  B      - REAL             array of DIMENSION ( LDB, ncolb ).
C
C           Before entry with  NCOLB .gt. 0, the leading n by ncolb part
C           of the array B must contain the matrix to be transformed and
C           on exit  B  is overwritten by the  n by ncolb  matrix  Q'*B.
C
C           When  NCOLB = 0  the array  B  is not referenced.
C
C  LDB    - INTEGER.
C
C           On  entry,  LDB  must specify  the leading dimension  of the
C           array  B  as declared  in the  calling  (sub) program.  When
C           NCOLB .gt. 0  then LDB must be at least N.
C
C           Unchanged on exit.
C
C  NROWY  - INTEGER.
C
C           On entry,  NROWY  must specify  the  number of  rows  of the
C           matrix  Y  and must be at least  zero.  When  NROWY = 0  the
C           array Y is not referenced.
C
C           Unchanged on exit.
C
C  Y      - REAL             array of DIMENSION ( LDY, n ).
C
C           Before entry with  NROWY .gt. 0, the leading nrowy by n part
C           of the array Y must contain the matrix to be transformed and
C           on  exit  Y  is overwritten  by the  nrow by n  matrix  Y*Q.
C
C           When  NROWY = 0  the array  Y  is not referenced.
C
C  LDY    - INTEGER.
C
C           On  entry,  LDY  must specify  the leading dimension  of the
C           array  Y  as declared  in the  calling  (sub) program.  When
C           NROWY .gt. 0  then LDY must be at least NROWY.
C
C           Unchanged on exit.
C
C  NCOLZ  - INTEGER.
C
C           On entry,  NCOLZ  must specify the  number of columns of the
C           matrix  Z  and must be at least  zero.  When  NCOLZ = 0  the
C           array Z is not referenced.
C
C           Unchanged on exit.
C
C  Z      - REAL             array of DIMENSION ( LDZ, ncolz ).
C
C           Before entry with  NCOLZ .gt. 0, the leading n by ncolz part
C           of the array Z must contain the matrix to be transformed and
C           on exit  Z  is overwritten by the  n by ncolz  matrix  P'*Z.
C
C           When  NCOLZ = 0  the array  Z  is not referenced.
C
C  LDZ    - INTEGER.
C
C           On  entry,  LDZ  must specify  the leading dimension  of the
C           array  Z  as declared  in the  calling  (sub) program.  When
C           NCOLZ .gt. 0  then LDZ must be at least N.
C
C           Unchanged on exit.
C
C  WORK   - REAL array of DIMENSION at least ( max( 1, lwork ) ),  where
C           lwork must be at least zero when  ncolb = nrowy = ncolz = 0,
C           lwork must be at least   2*( n - 1 )   when  either  ncolb =
C           nrowy = 0  and  nrowz is positive, or  nrowz = 0  and one or
C           both of  ncolb and  nrowy  are positive, and  lwork  must be
C           at least  4*( n - 1 )  when one  or both of  ncolb and nrowy
C           are positive and  ncolz  is positive.
C
C           The array  WORK  is used as  internal workspace  by  F02SYZ.
C           On exit,  WORK( 1 )  contains the total number of iterations
C           taken by the QR algorithm.
C
C  IFAIL  - INTEGER.
C
C           Before entry,  IFAIL  must contain one of the values -1 or 0
C           or 1  to specify noisy soft failure or noisy hard failure or
C           silent soft failure. ( See Chapter P01 for further details.)
C
C           On  successful exit  IFAIL  will be  zero,  otherwise  IFAIL
C           will be set to a  non-zero value  indicating either  that an
C           input parameter  has been  incorrectly set,  or that the  QR
C           algorithm  is not  converging.  See  the  next  section  for
C           further details.
C
C  4. Diagnostic Information
C     ======================
C
C  IFAIL = -1
C
C     One or more of the following conditions holds:
C
C        N     .lt. 0
C        NCOLB .lt. 0
C        LDB   .lt. N      and  NCOLB .gt. 0
C        NROWY .lt. 0
C        LDY   .lt. NROWY  and  NROWY .gt. 0
C        NCOLZ .lt. 0
C        LDZ   .lt. N      and  NCOLZ .gt. 0
C
C  IFAIL .gt. 0
C
C     The  QR algorithm  has failed to converge in  50*N iterations.  In
C     this   case  d( 1 ), d( 2 ), ..., d( IFAIL )  may  not  have  been
C     found correctly  and the remaining singular values  may not be the
C     smallest.  The matrix  A will nevertheless have been factorized as
C     A = Q*E*P',  where  E is a bidiagonal matrix with  d( 1 ), d( 2 ),
C     ..., d( n )  as  the  diagonal elements  and  e( 1 ), e( 2 ), ...,
C     e( n - 1 )  as the super-diagonal elements.
C
C     This failure is not likely to occur.
C
C  If  on  entry,  IFAIL  was either  -1 or 0  then  further  diagnostic
C  information  will  be  output  on  the  error message  channel. ( See
C  routine  X04AAF. )
C
C  5. Further Information
C     ===================
C
C  This routine  can be  used in conjunction  with routines  F02SWZ  and
C  F02SXZ   to  find  the  singular  value  decomposition  of  an  upper
C  triangular matrix.
C
C
C  Nag Fortran 77 Auxiliary linear algebra routine.
C
C  -- Written on 4-September-1987.
C     Sven Hammarling and Jeremy Du Croz, Nag Central Office.
C
C
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F02SYZ')
      DOUBLE PRECISION  QTR, ZERO
      PARAMETER         (QTR=0.25D+0,ZERO=0.0D+0)
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LDB, LDY, LDZ, N, NCOLB, NCOLZ, NROWY
C     .. Array Arguments ..
      DOUBLE PRECISION  B(LDB,*), D(*), E(*), WORK(*), Y(LDY,*),
     *                  Z(LDZ,*)
C     .. Local Scalars ..
      DOUBLE PRECISION  AMAX, CS, DMAX, EKM2, SN, TEMP
      INTEGER           I, IERR, ITER, IW1, IW2, IW3, J, K, L, MAXIT, P
      LOGICAL           FORCE, WANTB, WANTY, WANTZ
C     .. Local Arrays ..
      CHARACTER*80      REC(2)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          DSCAL, F02XUS, F02XUT, F02XUU, F02XUV, F02XUW,
     *                  F06FGF, F06QKF, F06QXF, P01ABY
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX
C     .. Executable Statements ..
C
C     Check the input parameters.
C
      WORK(1) = ZERO
      WANTB = NCOLB .GT. 0
      WANTY = NROWY .GT. 0
      WANTZ = NCOLZ .GT. 0
      IERR = 0
      IF (N.LT.0) CALL P01ABY(N,'N',IFAIL,IERR,SRNAME)
      IF (NCOLB.LT.0) CALL P01ABY(NCOLB,'NCOLB',IFAIL,IERR,SRNAME)
      IF ((WANTB) .AND. (LDB.LT.N)) CALL P01ABY(LDB,'LDB',IFAIL,IERR,
     *    SRNAME)
      IF (NROWY.LT.0) CALL P01ABY(NROWY,'NROWY',IFAIL,IERR,SRNAME)
      IF ((WANTY) .AND. (LDY.LT.NROWY)) CALL P01ABY(LDY,'LDY',IFAIL,
     *    IERR,SRNAME)
      IF (NCOLZ.LT.0) CALL P01ABY(NCOLZ,'NCOLZ',IFAIL,IERR,SRNAME)
      IF ((WANTZ) .AND. (LDZ.LT.N)) CALL P01ABY(LDZ,'LDZ',IFAIL,IERR,
     *    SRNAME)
      IF (IERR.GT.0) THEN
         WRITE (REC,FMT=99999) IERR
         IFAIL = P01ABF(IFAIL,-1,SRNAME,1,REC)
         RETURN
      END IF
      IF (N.EQ.0) THEN
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
         RETURN
      END IF
C
C     Find the size  of the  element  of  largest absolute value of  A.
C
      AMAX = ABS(D(1))
      DO 20 I = 2, N
         AMAX = MAX(AMAX,ABS(D(I)),ABS(E(I-1)))
   20 CONTINUE
C
C     Scale the matrix A by AMAX.
C
      IF (AMAX.GT.ZERO) THEN
         CALL DSCAL(N,1/AMAX,D,1)
         CALL DSCAL(N-1,1/AMAX,E,1)
      END IF
C
C     Split up the workspace.
C
      IW1 = 1
      IW2 = 1
      IW3 = 1
      IF ((WANTB) .OR. (WANTY)) THEN
         IW1 = N
         IF (WANTZ) THEN
            IW2 = (N-1) + IW1
            IW3 = (N-1) + IW2
         END IF
      ELSE IF (WANTZ) THEN
         IW3 = N
      END IF
C
C     Start the  QR algorithm.  A singular value is found for each value
C     of k.
C
      MAXIT = 50*N
      ITER = 1
      K = N
C+    WHILE( ( K.GT.1 ).AND.( ITER.LE.MAXIT ) )LOOP
   40 IF ((K.GT.1) .AND. (ITER.LE.MAXIT)) THEN
C
C        Test  to see if there is a  split,  or if we can force a split.
C        On exit from  F02XUT,  force will be  true  if we can  force  a
C        split and  p .gt. 0  means that  e( p )  is negligible, or will
C        be negligible after forcing the split.
C
         CALL F02XUT(ZERO,K,D,E,FORCE,P)
         L = P + 1
         IF (FORCE) THEN
            IF (P.EQ.K) THEN
C
C              Force a zero singular value in d( k ).
C
               CALL F02XUS(K,D,E,WANTZ,WORK(IW2),WORK(IW3))
               IF (WANTZ) CALL F06QXF('Left','Bottom','Backward',N,
     *                                NCOLZ,1,K,WORK(IW2),WORK(IW3),Z,
     *                                LDZ)
            ELSE
C
C              Force a split.
C
               CALL F02XUW(P,K,D,E,(WANTB) .OR. (WANTY),WORK,WORK(IW1))
               IF (WANTB) CALL F06QXF('Left','Top','Forward',N,NCOLB,P,
     *                                K,WORK,WORK(IW1),B,LDB)
               IF (WANTY) CALL F06QXF('Right','Top','Forward',NROWY,N,P,
     *                                K,WORK,WORK(IW1),Y,LDY)
            END IF
         END IF
         IF (L.GE.K) THEN
C
C           We have converged to a singular value.
C
            K = K - 1
         ELSE
C
C           Perform a QR step. First determine the shift.
C
            IF (K.GT.(L+1)) THEN
               EKM2 = E(K-2)
            ELSE
               EKM2 = ZERO
            END IF
            CALL F02XUU(-1,D(L),E(L),D(K-1),D(K),EKM2,E(K-1),CS,SN)
            CALL F02XUV('Non-zero',L,K,D,E,CS,SN,(WANTB) .OR. (WANTY),
     *                  WORK,WORK(IW1),WANTZ,WORK(IW2),WORK(IW3))
            IF (WANTB) CALL F06QXF('Left','Variable','Forward',N,NCOLB,
     *                             L,K,WORK,WORK(IW1),B,LDB)
            IF (WANTY) CALL F06QXF('Right','Variable','Forward',NROWY,N,
     *                             L,K,WORK,WORK(IW1),Y,LDY)
            IF (WANTZ) CALL F06QXF('Left','Variable','Forward',N,NCOLZ,
     *                             L,K,WORK(IW2),WORK(IW3),Z,LDZ)
            ITER = ITER + 1
         END IF
         GO TO 40
      END IF
C+    END WHILE
C
C     Unscale the matrix.
C
      IF (AMAX.GT.ZERO) THEN
         CALL DSCAL(N,AMAX,D,1)
         CALL DSCAL(N-1,AMAX,E,1)
      END IF
C
C     Make the singular values non-negative.
C
      DO 60 I = K, N
         IF (D(I).LT.ZERO) THEN
            D(I) = -D(I)
            IF (WANTB) CALL F06FGF(NCOLB,B(I,1),LDB)
            IF (WANTY) CALL F06FGF(NROWY,Y(1,I),1)
         END IF
   60 CONTINUE
C
C     Sort the singular values into descending order.
C
      DO 80 J = 1, K - 1
         WORK(J) = J + QTR
   80 CONTINUE
      DO 120 J = K, N
         DMAX = D(J)
         L = J
         DO 100 I = J + 1, N
            IF (D(I).GT.DMAX) THEN
               DMAX = D(I)
               L = I
            END IF
  100    CONTINUE
         WORK(J) = L + QTR
         IF (L.GT.J) THEN
            TEMP = D(J)
            D(J) = D(L)
            D(L) = TEMP
         END IF
  120 CONTINUE
      IF (WANTB) CALL F06QKF('Left','Transpose',N,WORK,NCOLB,B,LDB)
      IF (WANTY) CALL F06QKF('Right','No Transpose',N,WORK,NROWY,Y,LDY)
      IF (WANTZ) CALL F06QKF('Left','Transpose',N,WORK,NCOLZ,Z,LDZ)
      WORK(1) = ITER
      IF (K.EQ.1) THEN
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
      ELSE
         WRITE (REC,FMT=99998) K
         IFAIL = P01ABF(IFAIL,K,SRNAME,2,REC)
      END IF
      RETURN
C
C
C     End of F02SYZ. ( SBIQR )
C
99999 FORMAT ('    The input parameters contained ',I2,' error(s)')
99998 FORMAT ('    The QR algorithm has failed to converge.',/'    ',I6,
     *       ' singular values have NOT been found.')
      END
      SUBROUTINE F02WEF(M,N,A,LDA,NCOLB,B,LDB,WANTQ,Q,LDQ,SV,WANTP,PT,
     *                  LDPT,WORK,IFAIL)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     MARK 14 REVISED. IER-789 (DEC 1989).
C     MARK 14B REVISED. IER-834 (MAR 1990).
C
C  1. Purpose
C     =======
C
C  F02WEF  returns all, or part, of the  singular value decomposition of
C  a general real matrix.
C
C  2. Description
C     ===========
C
C  The m by n matrix A is factorized as
C
C     A = Q*D*P',
C
C  where
C
C     D = ( S ),      m .gt. n,
C         ( 0 )
C
C     D =   S,        m .eq. n,
C
C     D = ( S  0 ),   m .lt. n,
C
C  Q is an  m by m orthogonal matrix,  P is an  n by n orthogonal matrix
C  and  S  is a  min( m, n ) by min( m, n )  diagonal matrix  with  non-
C  negative diagonal elements, sv( 1 ), sv( 2 ), ..., sv( min( m, n ) ),
C  ordered such that
C
C     sv( 1 ) .ge. sv( 2 ) .ge. ... .ge. sv( min( m, n ) ) .ge. 0.
C
C  The first min( m, n ) columns of Q are the left-hand singular vectors
C  of A, the diagonal elements of S are the singular values of A and the
C  first min( m, n ) columns of P are the right-hand singular vectors of
C  A.
C
C  Either or both of the left-hand and right-hand singular vectors of  A
C  may be requested and the matrix
C  C given by
C
C     C = Q'*B,
C
C  where B is an m by ncolb given matrix, may also be requested.
C
C  The  routine  obtains  the  singular  value  decomposition  by  first
C  reducing  A  to  upper  triangular  form  by  means  of   Householder
C  transformations, from the left when  m .ge. n and from the right when
C  m .lt. n.  The  upper triangular form  is then reduced to  bidiagonal
C  form by  Givens plane rotations and finally the  QR algorithm is used
C  to obtain the  singular value decomposition  of the  bidiagonal form.
C
C  3. Parameters
C     ==========
C
C  M      - INTEGER.
C
C           On entry, M must specify the number of rows of the matrix A.
C           M  must be  at least  zero.  When  M = 0  then an  immediate
C           return is effected.
C
C           Unchanged on exit.
C
C  N      - INTEGER.
C
C           On entry, N must specify the number of columns of the matrix
C           A.  N must be at least zero.  When  N = 0  then an immediate
C           return is effected.
C
C           Unchanged on exit.
C
C  A      - REAL             array of DIMENSION ( LDA, n ).
C
C           Before entry, the leading  M by N  part of the array  A must
C           contain the matrix  A  whose singular value decomposition is
C           required.
C
C           If  m .ge. n  and  WANTQ is .TRUE.  then on exit, the M by N
C           part of A will contain the first n columns of the orthogonal
C           matrix  Q.
C
C           If  m .lt. n  and  WANTP is .TRUE.  then on exit, the M by N
C           part of  A  will contain the first  m rows of the orthogonal
C           matrix  P'.
C
C           If   m .ge. n  and   WANTQ is .FALSE.  and   WANTP is .TRUE.
C           then on exit, the  min( M, N ) by N  part of  A will contain
C           the first  min( m, n )  rows  of the  orthogonal matrix  P'.
C
C           Otherwise  the   M by N  part  of  A  is  used  as  internal
C           workspace.
C
C  LDA    - INTEGER.
C
C           On entry, LDA  must  specify  the  leading dimension of  the
C           array  A  as declared in the calling (sub) program. LDA must
C           be at least  m.
C
C           Unchanged on exit.
C
C  NCOLB  - On entry,  NCOLB  must specify the  number of columns of the
C           matrix  B  and must be at least  zero.  When  NCOLB = 0  the
C           array  B  is not referenced.
C
C  B      - REAL             array of DIMENSION ( LDB, ncolb ).
C
C           Before entry with  NCOLB .gt. 0, the leading M by NCOLB part
C           of the array  B  must contain the  matrix to be  transformed
C           and  on exit,  B  is overwritten  by the  m by ncolb  matrix
C           Q'*B.
C
C  LDB    - INTEGER.
C
C           On entry, LDB  must  specify  the  leading dimension of  the
C           array  B  as declared  in the  calling  (sub) program.  When
C           NCOLB .gt. 0  then LDB must be at least  m.
C
C           Unchanged on exit.
C
C  WANTQ  - LOGICAL.
C
C           On entry,  WANTQ  must be .TRUE.  if the  left-hand singular
C           vectors are required. If  WANTQ is .FALSE.  then  the  array
C           Q  is not referenced.
C
C           Unchanged on exit.
C
C  Q      - REAL             array of DIMENSION ( LDQ, m ).
C
C           On exit  with  M .lt. N  and  WANTQ as .TRUE.,  the  leading
C           M by M  part  of the  array  Q  will contain  the orthogonal
C           matrix Q. Otherwise the array  Q is not referenced.
C
C  LDQ    - INTEGER.
C
C           On entry, LDQ  must  specify  the  leading dimension of  the
C           array  Q  as declared  in the  calling  (sub) program.  When
C           M .lt. N  and  WANTQ is .TRUE.,  LDQ  must  be at  least  m.
C
C           Unchanged on exit.
C
C  SV     - REAL array of DIMENSION at least ( min( m, n ) ).
C
C           On exit, the array  SV will contain the min( m, n ) diagonal
C           elements of the matrix  S.
C
C  WANTP  - LOGICAL.
C
C           On entry,  WANTP must be .TRUE.  if the  right-hand singular
C           vectors are  required.  If  WANTP is .FALSE.  then the array
C           PT  is not referenced.
C
C           Unchanged on exit.
C
C  PT     - REAL             array of DIMENSION ( LDPT, n ).
C
C           On exit  with  M .ge. N  and  WANTQ and WANTP as .TRUE., the
C           leading  N by N  part  of the  array  PT  will  contain  the
C           orthogonal  matrix  P'.   Otherwise  the  array  PT  is  not
C           referenced.
C
C  LDPT   - INTEGER.
C
C           On entry,  LDPT  must specify the  leading dimension  of the
C           array  PT  as declared  in the  calling (sub) program.  When
C           M .ge. N  and  WANTQ and WANTP are .TRUE.,  LDPT  must be at
C           least  n.
C
C           Unchanged on exit.
C
C  WORK   - REAL array of DIMENSION at least ( lwork ), where lwork must
C           be as given in the following table:
C
C              M .ge. N
C
C                 WANTQ is .TRUE.  and   WANTP is .TRUE.
C
C                    lwork = max(n**2 + 5*( n - 1 ), n + ncolb, 4)
C
C                 WANTQ is .TRUE.  and  WANTP is .FALSE.
C
C                    lwork = max(n**2 + 4*( n - 1 ) + 1, n + ncolb, 4)
C
C                 WANTQ is .FALSE.  and  WANTP is .TRUE.
C
C                    lwork = max( 3*( n - 1 ), 2 )   when   NCOLB   =  0
C                    lwork = max( 5*( n - 1 ), 2 )   when   NCOLB .gt. 0
C
C                 WANTQ is .FALSE.  and  WANTP is .FALSE.
C
C                    lwork = max( 2*( n - 1 ), 2 )   when  NCOLB   =  0
C                    lwork = max( 3*( n - 1 ), 2 )   when  NCOLB .gt. 0
C
C              M .lt. N
C
C                 WANTQ is .TRUE.  and   WANTP is .TRUE.
C
C                    lwork = max( m**2 + 5*( m - 1 ), 2 )
C
C                 WANTQ is .TRUE.  and  WANTP is .FALSE.
C
C                    lwork = max( 3*( m - 1 ), 1 )
C
C                 WANTQ is .FALSE.  and  WANTP is .TRUE.
C
C                    lwork = max( m**2 + 3*( m - 1 ), 2 )
C                                                  when  NCOLB   =  0
C                    lwork = max( m**2 + 5*( m - 1 ), 2 )
C                                                  when  NCOLB .gt. 0
C
C                 WANTQ is .FALSE.  and  WANTP is .FALSE.
C
C                    lwork = max( 2*( m - 1 ), 1 )    when  NCOLB   =  0
C                    lwork = max( 3*( m - 1 ), 1 )    when  NCOLB .gt. 0
C
C           The array  WORK  is used as  internal  workspace by  F02WEF.
C           On exit,  WORK( min( m, n ) )  contains the  total number of
C           iterations taken by the QR algorithm.
C
C  IFAIL  - INTEGER.
C
C           Before entry,  IFAIL  must contain one of the values -1 or 0
C           or 1 to specify noisy soft failure or noisy hard failure  or
C           silent soft failure. ( See Chapter P01 for further details.)
C
C           On successful  exit  IFAIL  will be  zero,  otherwise  IFAIL
C           will be set to a  non-zero value  indicating either  that an
C           input parameter  has been  incorrectly set,  or that the  QR
C           algorithm  is not  converging.  See  the  next  section  for
C           further details.
C
C  4. Diagnostic Information
C     ======================
C
C  IFAIL = -1
C
C     One or more of the following conditions holds:
C
C        M     .lt. 0
C        N     .lt. 0
C        LDA   .lt. M
C        NCOLB .lt. 0
C        LDB   .lt. M  and  NCOLB .gt. 0
C        LDQ   .lt. M  and  M     .lt. N  and  WANTQ is true
C        LDPT  .lt. N  and  M     .ge. N  and  WANTQ is true
C                                         and  WANTP is true
C
C  IFAIL .gt. 0
C
C     The  QR  algorithm  has  failed  to  converge  in   50*min( M, N )
C     iterations.  In this case  sv( 1 ), sv( 2 ), ..., sv( IFAIL )  may
C     not  have been found correctly  and the remaining  singular values
C     may not be the smallest. The matrix  A will nevertheless have been
C     factorized  as   A = Q*E*P',  where  the  leading   min( m, n ) by
C     min( m, n )  part  of  E  is  a  bidiagonal matrix  with  sv( 1 ),
C     sv( 2 ), ..., sv( min( m, n ) )   as  the  diagonal  elements  and
C     work( 1 ), work( 2 ), ..., work( min( m, n ) - 1 )  as the  super-
C     diagonal elements.
C
C     This failure is not likely to occur.
C
C  If  on  entry,  IFAIL  was  either  -1 or 0  then  further diagnostic
C  information  will  be  output  on  the  error message  channel. ( See
C  routine  X04AAF. )
C
C  5. Further information
C     ===================
C
C  Following the use of this routine the rank of A may be estimated by
C  a call to the INTEGER function F06KLF.  The statement:
C
C     IRANK = F06KLF( MIN( M, N ), SV, 1, TOL )
C
C  returns  the value  ( k - 1 ), in  IRANK,  where  k  is the  smallest
C  integer  for  which   sv( k ) .lt. tol*sv( 1 ),   where  tol  is  the
C  tolerance supplied in  TOL, so that  IRANK is an estimate of the rank
C  of  S  and thus also of  A.  If  TOL is supplied as negative then the
C  relative machine precision ( see routine X02AJF ) is used in place of
C  TOL.
C
C
C  Nag Fortran 77 Auxiliary linear algebra routine.
C
C  -- Written on 12-January-1988.
C     Sven Hammarling, Nag Central Office.
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE, ZERO
      PARAMETER         (ONE=1.0D+0,ZERO=0.0D+0)
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F02WEF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LDA, LDB, LDPT, LDQ, M, N, NCOLB
      LOGICAL           WANTP, WANTQ
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), B(LDB,*), PT(LDPT,*), Q(LDQ,*), SV(*),
     *                  WORK(*)
C     .. Local Scalars ..
      INTEGER           I, IER, IERR, J, K1, K2, K3, K4
C     .. Local Arrays ..
      CHARACTER*47      REC(2)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          F01QEF, F01QCF, F01QDF, F01QJF, F01QKF, F02WUF,
     *                  F06QFF, P01ABY, DCOPY, DGEMV
C     .. Intrinsic Functions ..
      INTRINSIC         MIN
C     .. Executable Statements ..
C
C     Check the input parameters.
C
      IF ((M.EQ.0) .OR. (N.EQ.0)) THEN
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
         RETURN
      END IF
      IERR = 0
      IF (M.LT.0) CALL P01ABY(M,'M',IFAIL,IERR,SRNAME)
      IF (N.LT.0) CALL P01ABY(N,'N',IFAIL,IERR,SRNAME)
      IF (LDA.LT.M) CALL P01ABY(LDA,'LDA',IFAIL,IERR,SRNAME)
      IF (NCOLB.LT.0) CALL P01ABY(NCOLB,'NCOLB',IFAIL,IERR,SRNAME)
      IF ((LDB.LT.M) .AND. (NCOLB.GT.0)) CALL P01ABY(LDB,'LDB',IFAIL,
     *    IERR,SRNAME)
      IF ((LDQ.LT.M) .AND. (M.LT.N) .AND. (WANTQ)) CALL P01ABY(LDQ,
     *    'LDQ',IFAIL,IERR,SRNAME)
      IF ((LDPT.LT.N) .AND. (M.GE.N) .AND. (WANTQ) .AND. (WANTP))
     *    CALL P01ABY(LDPT,'LDPT',IFAIL,IERR,SRNAME)
      IF (IERR.GT.0) THEN
         WRITE (REC,FMT=99999) IERR
         IFAIL = P01ABF(IFAIL,-1,SRNAME,1,REC)
         RETURN
      END IF
C
C     Split up the workspace array  WORK. When m.ge.n then  k1 marks the
C     start of  theta  ( see routine F01QCF ) and when  m.lt.n  then  k3
C     marks the start of theta ( see routine F01QJF ). When WORK is used
C     to hold a matrix, the matrix always starts at WORK( 1 ).  k3 marks
C     the start of the workspace in the calls to  F02WUF.
C
      IF (M.GE.N) THEN
         IF (WANTQ) THEN
            IF (WANTP) THEN
               K1 = 1
               K2 = 1 + N
               K3 = 1 + N**2
               K4 = K3 + N
            ELSE
               K1 = 1 + MAX(N**2,NCOLB)
               K2 = 1
               K3 = N + K1
               K4 = K3 + N
            END IF
         ELSE
            K1 = 1
            K2 = 1 + N
            K3 = 1
         END IF
      ELSE IF (WANTP) THEN
         K3 = 1 + M**2
         K4 = K3 + M
      ELSE
         K3 = 1
      END IF
C
C     Perform the factorization.
C
      IERR = 1
      IER = 0
      IF (M.GE.N) THEN
C
C        Find the QR factorization of  A  and form  Q'*B.
C
         CALL F01QCF(M,N,A,LDA,WORK(K1),IER)
         IF (NCOLB.GT.0) CALL F01QDF('Transpose','Separate',M,N,A,LDA,
     *                               WORK(K1),NCOLB,B,LDB,WORK(K2),IER)
         IF (WANTQ) THEN
            IF (WANTP) THEN
C
C              Copy R into PT, form the orthogonal matrix, Q1, of the QR
C              factorization  in   A   and  find  the   SVD,   given  by
C              R = Q2*D*P'.
C
               CALL F06QFF('Upper triangular',N,N,A,LDA,PT,LDPT)
               CALL F01QEF('Separate',M,N,N,A,LDA,WORK(K1),WORK(K2),IER)
               CALL F02WUF(N,PT,LDPT,NCOLB,B,LDB,.TRUE.,WORK,N,SV,
     *                     .TRUE.,WORK(K3),IERR)
            ELSE
C
C              Find the  SVD of  R  given by  R = Q2*D*P'  and form  the
C              othogonal  matrix,  Q1,  of the  QR factorization  in  A.
C
               CALL F02WUF(N,A,LDA,NCOLB,B,LDB,.TRUE.,WORK,N,SV,.FALSE.,
     *                     WORK(K3),IERR)
               CALL F01QEF('Separate',M,N,N,A,LDA,WORK(K1),WORK(K4),IER)
            END IF
C
C           Form  Q = Q1*Q2,  row by row using  Q' = Q2'*Q1'.
C
            DO 20 I = 1, M
               CALL DCOPY(N,A(I,1),LDA,WORK(K4),1)
               CALL DGEMV('Transpose',N,N,ONE,WORK,N,WORK(K4),1,ZERO,
     *                    A(I,1),LDA)
   20       CONTINUE
         ELSE
C
C           Find the SVD of R.
C
            CALL F02WUF(N,A,LDA,NCOLB,B,LDB,.FALSE.,Q,LDQ,SV,WANTP,WORK,
     *                  IERR)
         END IF
      ELSE
C
C        Find the RQ factorization of A.
C
         CALL F01QJF(M,N,A,LDA,WORK(K3),IER)
         IF (WANTP) THEN
C
C           Copy  R into  WORK,  form the orthogonal matrix, P1', of the
C           RQ factorization  in  A  and  find the  SVD  of  R  given by
C           R = Q*D*P2'.
C
            CALL F06QFF('Upper triangular',M,M,A,LDA,WORK,M)
            CALL F01QKF('Separate',M,N,M,A,LDA,WORK(K3),WORK(K4),IER)
            CALL F02WUF(M,WORK,M,NCOLB,B,LDB,WANTQ,Q,LDQ,SV,.TRUE.,
     *                  WORK(K3),IERR)
C
C           Form  P' = P2'*P1'.
C
            DO 40 J = 1, N
               CALL DCOPY(M,A(1,J),1,WORK(K4),1)
               CALL DGEMV('No transpose',M,M,ONE,WORK,M,WORK(K4),1,ZERO,
     *                    A(1,J),1)
   40       CONTINUE
         ELSE
C
C           Find the SVD of R.
C
            CALL F02WUF(M,A,LDA,NCOLB,B,LDB,WANTQ,Q,LDQ,SV,.FALSE.,WORK,
     *                  IERR)
         END IF
      END IF
      IF (K3.GT.1) CALL DCOPY(MIN(M,N),WORK(K3),1,WORK,1)
      IF (IERR.NE.0) THEN
         WRITE (REC,FMT=99998) IERR
         IFAIL = P01ABF(IFAIL,IERR,SRNAME,2,REC)
      ELSE
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
      END IF
      RETURN
C
C
C     End of F02WEF.
C
99999 FORMAT ('    The input parameters contained ',I2,' error(s)')
99998 FORMAT ('    The QR algorithm has failed to converge.',/'    ',I6,
     *       ' singular values have NOT been found.')
      END
      SUBROUTINE F02WEX(NX,NY,ALPHA,X,INCX,Y,INCY,TOL,ZETA)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     MARK 14A REVISED. IER-687 (DEC 1989).
C     MARK 18 REVISED (THREAD SAFETY). (SEP 1996).
C
C  F02WEX  generates  details  of  a  Householder reflection  such  that
C
C     P*(   x   ) = (   0  ),   P'*P = I.
C       ( alpha )   ( beta ),
C       (   y   )   (   0  )
C
C  P is given in the form
C
C     P = I - (   w  )*( w'  zeta  z' ),
C             ( zeta )
C             (   z  )
C
C  where  w is an nx element vector, z is an ny element vector, and zeta
C  is a scalar that satisfies
C
C     1.0 .le. zeta .le. sqrt( 2.0 ).
C
C  zeta is returned in ZETA unless the vector v given by
C
C     v = ( x )
C         ( y )
C
C  is such that
C
C     max( abs( v( i ) ) ) .le. max( tol, eps*abs( alpha ) ),
C
C  where  eps  is the  relative machine precision  and  tol  is the user
C  supplied tolerance  TOL, in which case  ZETA  is returned as  0.0 and
C  P  can be taken to be the unit matrix.
C
C  beta  is  overwritten on  alpha,  w  is overwritten on  x  and  z  is
C  overwritten on  y.
C
C  The  routine  may be  called  with  either  or  both  nx = 0, ny = 0.
C
C
C  Nag Fortran 77 O( n ) basic linear algebra routine.
C
C  -- Written on 17-November-1987.
C     Sven Hammarling, Nag Central Office.
C
C
C     .. Parameters ..
      DOUBLE PRECISION ONE, ZERO
      PARAMETER        (ONE=1.0D+0,ZERO=0.0D+0)
C     .. Scalar Arguments ..
      DOUBLE PRECISION ALPHA, TOL, ZETA
      INTEGER          INCX, INCY, NX, NY
C     .. Array Arguments ..
      DOUBLE PRECISION X(*), Y(*)
C     .. Local Scalars ..
      DOUBLE PRECISION BETA, EPS, SCALE, SSQ
C     .. External Functions ..
      DOUBLE PRECISION X02AJF
      EXTERNAL         X02AJF
C     .. External Subroutines ..
      EXTERNAL         F06FJF, F06FRF, DSCAL
C     .. Intrinsic Functions ..
      INTRINSIC        ABS, MAX, SQRT
C     .. Executable Statements ..
      IF (NX.LT.1) THEN
         CALL F06FRF(NY,ALPHA,Y,INCY,TOL,ZETA)
      ELSE IF (NY.LT.1) THEN
         CALL F06FRF(NX,ALPHA,X,INCX,TOL,ZETA)
      ELSE
C
         EPS = X02AJF()
C
         SSQ = ONE
         SCALE = ZERO
         CALL F06FJF(NX,X,INCX,SCALE,SSQ)
         CALL F06FJF(NY,Y,INCY,SCALE,SSQ)
C
C        Treat  cases  where   SCALE = zero,   SCALE is negligible   and
C        ALPHA = zero  specially.  Note that
C
C           SCALE = max( abs( v( i ) ) ).
C
         IF ((SCALE.EQ.ZERO) .OR. (SCALE.LE.MAX(TOL,EPS*ABS(ALPHA))))
     *       THEN
            ZETA = ZERO
         ELSE IF (ALPHA.EQ.ZERO) THEN
            ZETA = ONE
            ALPHA = SCALE*SQRT(SSQ)
            CALL DSCAL(NX,-1/ALPHA,X,INCX)
            CALL DSCAL(NY,-1/ALPHA,Y,INCY)
         ELSE
            IF (SCALE.LT.ABS(ALPHA)) THEN
               BETA = ABS(ALPHA)*SQRT(1+SSQ*(SCALE/ALPHA)**2)
            ELSE
               BETA = SCALE*SQRT(SSQ+(ALPHA/SCALE)**2)
            END IF
            ZETA = SQRT((BETA+ABS(ALPHA))/BETA)
            IF (ALPHA.GT.ZERO) BETA = -BETA
            CALL DSCAL(NX,-1/(ZETA*BETA),X,INCX)
            CALL DSCAL(NY,-1/(ZETA*BETA),Y,INCY)
            ALPHA = BETA
         END IF
      END IF
C
      RETURN
C
C     End of F02WEX. ( SGRFG2 )
C
      END
      SUBROUTINE F02WUF(N,A,LDA,NCOLB,B,LDB,WANTQ,Q,LDQ,SV,WANTP,WORK,
     *                  IFAIL)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C     MARK 18 REVISED. IER-1883 (MAY 1997).
C
C  1. Purpose
C     =======
C
C  F02WUF  returns all, or part, of the  singular value decomposition of
C  a real upper triangular matrix.
C
C  2. Description
C     ===========
C
C  The n by n upper triangular matrix R is factorized as
C
C     R = Q*S*P',
C
C  where  Q and P  are  n by n orthogonal matrices and  S  is an  n by n
C  diagonal  matrix   with  non-negative  diagonal  elements,   sv( 1 ),
C  sv( 2 ), ..., sv( n ), ordered such that
C
C     sv( 1 ) .ge. sv( 2 ) .ge. ... .ge. sv( n ) .ge. 0.
C
C  The  columns of  Q  are the  left-hand  singular vectors  of  R,  the
C  diagonal elements of  S are the singular values of  R and the columns
C  of  P are the right-hand singular vectors of  R.
C
C  Either or both of Q and P' may be requested and the matrix C given by
C
C     C = Q'*B,
C
C  where B is an n by ncolb given matrix, may also be requested.
C
C  The  routine  obtains  the  singular  value  decomposition  by  first
C  reducing  R  to  bidiagonal form  by means of  Givens plane rotations
C  and  then  using  the  QR algorithm  to  obtain  the  singular  value
C  decomposition  of the  bidiagonal form.
C
C  3. Parameters
C     ==========
C
C  N      - INTEGER.
C
C           On entry,  N must specify the order of the matrix R.  N must
C           be  at  least zero. When  N = 0  then an immediate return is
C           effected.
C
C           Unchanged on exit.
C
C  A      - REAL             array of DIMENSION ( LDA, n ).
C
C           Before entry,  the leading  N by N  upper triangular part of
C           the array  A  must contain the  upper triangular  matrix  R.
C
C           If  WANTP is .TRUE.  then on exit, the N by N part of A will
C           contain  the  n by n  orthogonal matrix  P',  otherwise  the
C           N by N  upper triangular  part  of  A  is  used as  internal
C           workspace,  but  the  strictly lower triangular  part  of  A
C           is not referenced.
C
C  LDA    - INTEGER.
C
C           On entry, LDA  must  specify  the  leading dimension of  the
C           array  A  as declared in the calling (sub) program. LDA must
C           be at least  n.
C
C           Unchanged on exit.
C
C  NCOLB  - On entry,  NCOLB  must specify the  number of columns of the
C           matrix  B  and must be at least  zero.  When  NCOLB = 0  the
C           array  B  is not referenced.
C
C  B      - REAL             array of DIMENSION ( LDB, ncolb ).
C
C           Before entry with  NCOLB .gt. 0, the leading N by NCOLB part
C           of the array  B  must contain the  matrix to be  transformed
C           and  on exit,  B  is overwritten  by the  n by ncolb  matrix
C           Q'*B.
C
C  LDB    - INTEGER.
C
C           On entry, LDB  must  specify  the  leading dimension of  the
C           array  B  as declared  in the  calling  (sub) program.  When
C           NCOLB .gt. 0  then LDB must be at least  n.
C
C           Unchanged on exit.
C
C  WANTQ  - LOGICAL.
C
C           On entry,  WANTQ must be .TRUE. if the matrix Q is required.
C           If  WANTQ is .FALSE.  then  the array  Q  is not referenced.
C
C           Unchanged on exit.
C
C  Q      - REAL             array of DIMENSION ( LDQ, n ).
C
C           On exit with  WANTQ as .TRUE.,  the leading  N by N  part of
C           the array Q will contain the orthogonal matrix Q.  Otherwise
C           the array  Q  is not referenced.
C
C  LDQ    - INTEGER.
C
C           On entry, LDQ  must  specify  the  leading dimension of  the
C           array  Q  as declared  in the  calling  (sub) program.  When
C           WANTQ is .TRUE.,  LDQ  must be at least n.
C
C           Unchanged on exit.
C
C  SV     - REAL array of DIMENSION at least ( n ).
C
C           On exit, the array  SV will contain the  n diagonal elements
C           of the matrix S.
C
C  WANTP  - LOGICAL.
C
C           On entry, WANTP must be .TRUE. if the matrix P' is required,
C           in which case  P'  is overwritten on the array A,  otherwise
C           WANTP must be .FALSE..
C
C           Unchanged on exit.
C
C  WORK   - REAL array of DIMENSION at least  ( max( 1, lwork ) ), where
C           lwork must satisfy:
C
C              lwork = 2*( n - 1 ) when
C                 ncolb = 0  and  WANTQ and WANTP are .FALSE.,
C
C              lwork = 3*( n - 1 ) when
C                 either  ncolb = 0  and  WANTQ is .FALSE.  and
C                 WANTP is .TRUE.,  or  WANTP is .FALSE.  and  one or
C                 both of  ncolb .gt. 0  and  WANTQ is .TRUE.
C
C              lwork = 5*( n - 1 ) otherwise.
C
C           The array   WORK  is used as  internal workspace by  F06XUF.
C           On exit,  WORK( n )  contains the total number of iterations
C           taken by the QR algorithm.
C
C  IFAIL  - INTEGER.
C
C           Before entry,  IFAIL  must contain one of the values -1 or 0
C           or 1 to specify noisy soft failure or noisy hard failure  or
C           silent soft failure. ( See Chapter P01 for further details.)
C
C           On successful  exit  IFAIL  will be  zero,  otherwise  IFAIL
C           will be set to a  non-zero value  indicating either  that an
C           input parameter  has been  incorrectly set,  or that the  QR
C           algorithm  is not  converging.  See  the  next  section  for
C           further details.
C
C  4. Diagnostic Information
C     ======================
C
C  IFAIL = -1
C
C     One or more of the following conditions holds:
C
C        N     .lt. 0
C        LDA   .lt. N
C        NCOLB .lt. 0
C        LDB   .lt. N  and  NCOLB .gt. 0
C        LDQ   .lt. N  and  WANTQ  is  true
C
C  IFAIL .gt. 0
C
C     The  QR algorithm  has failed to converge in  50*N iterations.  In
C     this  case  sv( 1 ), sv( 2 ), ..., sv( IFAIL )  may not  have been
C     found correctly  and the remaining singular values  may not be the
C     smallest.  The matrix  R will nevertheless have been factorized as
C     R = Q*E*P', where E is a bidiagonal matrix with  sv( 1 ), sv( 2 ),
C     ..., sv( n )  as the  diagonal elements and  work( 1 ), work( 2 ),
C     ..., work( n - 1 )  as the super-diagonal elements.
C
C     This failure is not likely to occur.
C
C  If  on  entry,  IFAIL  was  either  -1 or 0  then  further diagnostic
C  information  will  be  output  on  the  error message  channel. ( See
C  routine  X04AAF. )
C
C  5. Further information
C     ===================
C
C  Following the use of this routine the rank of R may be estimated by
C  a call to the INTEGER function F06KLF.  The statement:
C
C     IRANK = F06KLF( N, SV, 1, TOL )
C
C  returns  the value  ( k - 1 ), in  IRANK,  where  k  is the  smallest
C  integer  for  which   sv( k ) .lt. tol*sv( 1 ),   where  tol  is  the
C  tolerance supplied in  TOL, so that  IRANK is an estimate of the rank
C  of  S  and thus also of  R.  If  TOL is supplied as negative then the
C  relative machine precision ( see routine X02AJF ) is used in place of
C  TOL.
C
C
C  Nag Fortran 77 Auxiliary linear algebra routine.
C
C  -- Written on 10-January-1988.
C     Sven Hammarling, Nag Central Office.
C
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F02WUF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LDA, LDB, LDQ, N, NCOLB
      LOGICAL           WANTP, WANTQ
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), B(LDB,*), Q(LDQ,*), SV(*), WORK(*)
C     .. Local Scalars ..
      INTEGER           IERR, NCOLP, NCOLQ
C     .. Local Arrays ..
      DOUBLE PRECISION  DUMMY(1)
      CHARACTER*80      REC(2)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          F02SWZ, F02SXZ, F02SYZ, P01ABY
C     .. Executable Statements ..
C
C     Check the input parameters.
C
      IERR = 0
      IF (N.LT.0) CALL P01ABY(N,'N',IFAIL,IERR,SRNAME)
      IF (LDA.LT.N) CALL P01ABY(LDA,'LDA',IFAIL,IERR,SRNAME)
      IF (NCOLB.LT.0) CALL P01ABY(NCOLB,'NCOLB',IFAIL,IERR,SRNAME)
      IF ((LDB.LT.N) .AND. (NCOLB.GT.0)) CALL P01ABY(LDB,'LDB',IFAIL,
     *    IERR,SRNAME)
      IF ((LDQ.LT.N) .AND. (WANTQ)) CALL P01ABY(LDQ,'LDQ',IFAIL,IERR,
     *    SRNAME)
      IF (IERR.GT.0) THEN
         WRITE (REC,FMT=99999) IERR
         IFAIL = P01ABF(IFAIL,-1,SRNAME,1,REC)
         RETURN
      END IF
      IF (N.EQ.0) THEN
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
         RETURN
      END IF
C
C     Perform the factorization.
C
C     First  reduce  the  matrix  R  to  bidiagonal form.  The  diagonal
C     elements  will  be  in   SV  and  the  super-diagonals  in   WORK.
C
      CALL F02SWZ(N,A,LDA,SV,WORK,NCOLB,B,LDB,WANTQ,Q,LDQ,IERR)
      IF (WANTP) THEN
         CALL F02SXZ(N,A,LDA,0,DUMMY,1,WORK(N),IERR)
         NCOLP = N
      ELSE
         NCOLP = 0
      END IF
      IF (WANTQ) THEN
         NCOLQ = N
      ELSE
         NCOLQ = 0
      END IF
C
C     Next find the SVD of the bidiagonal matrix.
C
      IERR = 1
      CALL F02SYZ(N,SV,WORK,NCOLB,B,LDB,NCOLQ,Q,LDQ,NCOLP,A,LDA,WORK(N),
     *            IERR)
      IF (IERR.NE.0) THEN
         WRITE (REC,FMT=99998) IERR
         IFAIL = P01ABF(IFAIL,IERR,SRNAME,2,REC)
      ELSE
         IFAIL = P01ABF(IFAIL,0,SRNAME,0,REC)
      END IF
      RETURN
C
C
C     End of F02WUF. ( SUTQR )
C
99999 FORMAT ('    The input parameters contained ',I2,' error(s)')
99998 FORMAT ('    The QR algorithm has failed to converge.',/'    ',I6,
     *       ' singular values have NOT been found.')
      END
      SUBROUTINE F02XUS(N,D,E,WANTCS,C,S)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C  F02XUS  annihilates the element a( n - 1, n )  of a bidiagonal matrix
C  A, on the assumption that  a( n, n ) is negligible, by applying plane
C  rotations from the right.  Thus  F02XUS  performs  the transformation
C
C     A := A*P',
C
C  where  A  is  a  bidiagonal matrix,  with  diagonal elements  d( 1 ),
C  d( 2 ), ..., d( n )   and  super-diagonal  elements   e( 1 ), e( 2 ),
C  ..., e( n - 1 ),  and  P  is an  orthogonal matrix,  consisting  of a
C  sequence of plane rotations
C
C     P = P( 1 )*...*P( n - 2 )*P( n - 1 ),
C
C  where  P( k ) is a plane rotation for the ( k, k + 1 ) plane. The two
C  by two part of the plane rotation matrix  P( k )  will be of the form
C
C     R( k ) = (  c( k )  s( k ) ).
C              ( -s( k )  c( k ) )
C
C  If  WANTCS  is supplied as true then  c( k ) and s( k )  are returned
C  in  the  arrays  C and S,   otherwise  the  arrays  C and S  are  not
C  referenced.
C
C  The element  e( n - 1 ) = a( n - 1, n )  is returned as  zero.
C
C  No check  is made  by this  routine to see if  d( n ) = a( n, n )  is
C  actually negligible. If this assumption is not valid then the nth row
C  of  A*P'  will contain non-negligible elements,  although this row is
C  not formed by the routine.
C
C  If  n.le.1  then an immediate return is effected.
C
C  Nag Fortran 77 basic linear algebra routine.
C
C  -- Written on 6-August-1987.
C     Sven Hammarling, Nag Central Office.
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO
      PARAMETER         (ZERO=0.0D+0)
C     .. Scalar Arguments ..
      INTEGER           N
      LOGICAL           WANTCS
C     .. Array Arguments ..
      DOUBLE PRECISION  C(*), D(*), E(*), S(*)
C     .. Local Scalars ..
      DOUBLE PRECISION  CS, SN, TEMP
      INTEGER           I
C     .. External Subroutines ..
      EXTERNAL          F06BAF
C     .. Executable Statements ..
C
      IF (N.GT.1) THEN
         I = N - 1
         TEMP = E(I)
         E(I) = ZERO
         CALL F06BAF(D(I),TEMP,CS,SN)
         IF (WANTCS) THEN
            C(I) = CS
            S(I) = SN
         END IF
         DO 20 I = N - 2, 1, -1
            TEMP = -SN*E(I)
            E(I) = CS*E(I)
            CALL F06BAF(D(I),TEMP,CS,SN)
            IF (WANTCS) THEN
               C(I) = CS
               S(I) = SN
            END IF
   20    CONTINUE
      END IF
      RETURN
C
C     End of F02XUS. ( SBIZRO )
C
      END
      SUBROUTINE F02XUT(TEST,N,D,E,FORCE,P)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     MARK 18 REVISED (THREAD SAFETY). (SEP 1996).
C
C  F02XUT  tests a bidiagonal matrix to see if there is a split, or if a
C  split can be forced.
C
C  The bidiagonal matrix must be supplied in the arrays D and E with the
C  diagonal  elements  in  d( 1 ), d( 2 ), ..., d( n )  and  the  super-
C  diagonal  elements  in  e( 1 ), e( 2 ), ..., e( n - 1 ).  The  arrays
C  are unaltered on exit.
C
C  The  bidiagonal matrix  is  searched  from the  bottom backwards  for
C  negligible elements  and  P  returns  the  row  in  which  the  first
C  negligible element is found. If no negligible element is found then
C  P = 0  is returned.
C
C  If  d( p ) is negligible then  FORCE  is set to true, indicating that
C  a  split  can be forced,  otherwise  FORCE  is returned as false.  If
C  FORCE  is  returned as  false  and  P  is  returned  as positive then
C  e( p ) is negligible.
C
C  When   test .le. 0.0   then  a  local test  is  used  and  d( p )  is
C  regarded as negligible if
C
C    abs( d( p ) ) .le. eps*( max( abs( e( p ) ), abs( e( p - 1 ) ) ) ),
C
C  where  e( n ) = e( 0 ) = 0.0   and   eps   is  the  relative  machine
C  precision as returned by routine  X02AJF, or if
C
C    abs( d( p ) ) .lt. flmin/eps,
C
C  where  flmin  is the  underflow  threshold  as  returned  by  routine
C  X02AKF, and similarly  e( p )  is regarded as negligible if
C
C    abs( e( p ) ) .le. eps*( max( abs( d( p + 1 ) ), abs( d( p ) ) ) ),
C
C  or if
C
C    abs( e( p ) ) .lt. flmin/eps.
C
C  When   test .gt. 0.0  then  a  global test  is  used  and  d( p )  is
C  regarded as negligible if
C
C    abs( d( p ) ) .lt. eps*test,
C
C  and similarly  e( p )  is regarded as negligible if
C
C    abs( e( p ) ) .lt. eps*test.
C
C  n  must be at least zero.
C
C
C  Nag Fortran 77 basic linear algebra routine.
C
C  -- Written on 1-October-1987.
C     Sven Hammarling, Nag Central Office.
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO
      PARAMETER         (ZERO=0.0D+0)
C     .. Scalar Arguments ..
      DOUBLE PRECISION  TEST
      INTEGER           N, P
      LOGICAL           FORCE
C     .. Array Arguments ..
      DOUBLE PRECISION  D(*), E(*)
C     .. Local Scalars ..
      DOUBLE PRECISION  ABSD, ABSDI, ABSE, ABSEI, AMAX, DMAX, EMAX, EPS,
     *                  FLMIN, NEGL, SMALL
      INTEGER           I
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AKF
      EXTERNAL          X02AJF, X02AKF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX
C     .. Executable Statements ..
      EPS = X02AJF()
      FLMIN = X02AKF()
      SMALL = FLMIN/EPS
C
      FORCE = .FALSE.
      I = N
      IF (TEST.LE.ZERO) THEN
         IF (N.EQ.1) THEN
            IF (ABS(D(N)).LT.SMALL) THEN
               FORCE = .TRUE.
               GO TO 60
            END IF
         ELSE
            ABSD = ABS(D(N))
            ABSE = ABS(E(N-1))
            AMAX = MAX(ABSD,ABSE)
            IF ((ABSD.LE.EPS*AMAX) .OR. (AMAX.LT.SMALL)) THEN
               FORCE = .TRUE.
               GO TO 60
            END IF
            DO 20 I = N - 1, 2, -1
               ABSDI = ABS(D(I))
               DMAX = MAX(ABSDI,ABSD)
               AMAX = MAX(DMAX,ABSE)
               IF ((ABSE.LE.EPS*DMAX) .OR. (AMAX.LT.SMALL)) GO TO 60
               ABSEI = ABS(E(I-1))
               EMAX = MAX(ABSE,ABSEI)
               AMAX = MAX(EMAX,ABSDI)
               IF ((ABSDI.LE.EPS*EMAX) .OR. (AMAX.LT.SMALL)) THEN
                  FORCE = .TRUE.
                  GO TO 60
               END IF
               ABSD = ABSDI
               ABSE = ABSEI
   20       CONTINUE
            ABSDI = ABS(D(1))
            DMAX = MAX(ABSDI,ABSD)
            AMAX = MAX(DMAX,ABSE)
            IF ((ABSE.LE.EPS*DMAX) .OR. (AMAX.LT.SMALL)) GO TO 60
            AMAX = MAX(ABSE,ABSDI)
            IF ((ABSDI.LE.EPS*ABSE) .OR. (AMAX.LT.SMALL)) THEN
               FORCE = .TRUE.
               GO TO 60
            END IF
         END IF
      ELSE
         NEGL = EPS*TEST
         IF (ABS(D(N)).LT.NEGL) THEN
            FORCE = .TRUE.
            GO TO 60
         END IF
         DO 40 I = N - 1, 1, -1
            IF (ABS(E(I)).LT.NEGL) GO TO 60
            IF (ABS(D(I)).LT.NEGL) THEN
               FORCE = .TRUE.
               GO TO 60
            END IF
   40    CONTINUE
      END IF
      I = 0
   60 CONTINUE
      P = I
      RETURN
C
C     End of F02XUT. ( SBITST )
C
      END
      SUBROUTINE F02XUU(JOB,D1,E1,DNM1,DN,ENM2,ENM1,C,S)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     MARK 18 REVISED (THREAD SAFETY). (SEP 1996).
C
C  F02XUU  determines  the  shift parameters,  c and s,  for  the  first
C  rotation to be performed in a QR step applied to a bidiagonal matrix.
C
C  c and s  are such that
C
C     (  c  s )*( d1**2 - shift ) := ( x )
C     ( -s  c ) (     d1*e1     )    ( 0 )
C
C  and  shift  is  determined  by the  value  of the  parameter  job  as
C  follows:
C
C     When  JOB =  0  then
C
C        shift = 0.
C
C     When  JOB =  1  then
C
C        shift  is the  eigenvalue closest  to the element  a( 2, 2 ) of
C        the matrix A given by
C
C           A = ( dnm1**2 + enm2**2    dnm1*enm1     ).
C               (     dnm1*enm1      dn**2 + enm1**2 )
C
C     When  JOB = -1  then
C
C        shift  is the eigenvalue closest to the element  a( 2, 2 ) of
C        the matrix A given by
C
C           A = ( dnm1**2 + enm1**2  dn*enm1 ).
C               (       dn*enm1       dn**2  )
C
C     When  JOB =  2  then
C
C        shift  is the  smallest eigenvalue  of the  matrix  A  given by
C
C           A = ( dnm1**2 + enm2**2    dnm1*enm1     ).
C               (     dnm1*enm1      dn**2 + enm1**2 )
C
C     When  JOB = -2  then
C
C        shift  is the  smallest eigenvalue  of the  matrix  A  given by
C
C           A = ( dnm1**2 + enm1**2  dn*enm1 ).
C               (       dn*enm1       dn**2  )
C
C
C  Nag Fortran 77 basic linear algebra routine.
C
C  -- Written on 14-September-1987.
C     Sven Hammarling.
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE, ZERO
      PARAMETER         (ONE=1.0D+0,ZERO=0.0D+0)
C     .. Scalar Arguments ..
      DOUBLE PRECISION  C, D1, DN, DNM1, E1, ENM1, ENM2, S
      INTEGER           JOB
C     .. Local Scalars ..
      DOUBLE PRECISION  A, APLUSC, B, BOT, CORR, F, RSQEPS, SHIFT,
     *                  SQTEPS, TOP
      LOGICAL           FAIL
C     .. External Functions ..
      DOUBLE PRECISION  F06BLF, X02AJF
      EXTERNAL          F06BLF, X02AJF
C     .. External Subroutines ..
      EXTERNAL          F06BAF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, SIGN, SQRT
C     .. Executable Statements ..
      SQTEPS = SQRT(X02AJF())
      RSQEPS = 1/SQTEPS
C
      IF (JOB.EQ.0) THEN
         A = D1
         B = E1
      ELSE IF (JOB.EQ.1) THEN
         IF (ENM1.EQ.ZERO) THEN
            CORR = ZERO
         ELSE
            TOP = (DNM1-DN)*(DNM1+DN) + (ENM2-ENM1)*(ENM2+ENM1)
            IF (TOP.EQ.ZERO) THEN
               CORR = ENM1*(DNM1-ENM1)
            ELSE
               BOT = 2*DNM1*ENM1
               F = F06BLF(TOP,BOT,FAIL)
               IF (FAIL) THEN
                  CORR = -ENM1**2
               ELSE
                  IF (ABS(F).LT.SQTEPS) THEN
                     BOT = F + SIGN(ONE,F)
                  ELSE IF (ABS(F).GT.RSQEPS) THEN
                     BOT = 2*F
                  ELSE
                     BOT = F + SIGN(ONE,F)*SQRT(1+F**2)
                  END IF
                  CORR = ENM1*(DNM1/BOT-ENM1)
               END IF
            END IF
         END IF
         IF (D1.NE.ZERO) THEN
            A = (ONE-DN/D1)*(D1+DN) + CORR/D1
            B = E1
         ELSE
            A = ONE
            B = ZERO
         END IF
      ELSE IF (JOB.EQ.(-1)) THEN
         TOP = (DN*ENM1)**2
         IF (TOP.EQ.ZERO) THEN
            CORR = ZERO
         ELSE
            F = ((DNM1-DN)*(DNM1+DN)+ENM1**2)/2
            BOT = F + SIGN(ONE,F)*SQRT(TOP+F**2)
            CORR = F06BLF(TOP,BOT,FAIL)
         END IF
         IF (D1.NE.ZERO) THEN
            A = (ONE-DN/D1)*(D1+DN) + CORR/D1
            B = E1
         ELSE
            A = ONE
            B = ZERO
         END IF
      ELSE IF (JOB.EQ.2) THEN
         TOP = 2*((DN*DNM1)**2+(DN*ENM2)**2+(ENM2*ENM1)**2)
         IF (TOP.EQ.ZERO) THEN
            SHIFT = ZERO
         ELSE
            F = ((DNM1-DN)*(DNM1+DN)+(ENM2-ENM1)*(ENM2+ENM1))**2 +
     *          (2*DNM1*ENM1)**2
            APLUSC = DNM1**2 + DN**2 + ENM2**2 + ENM1**2
            BOT = APLUSC + SIGN(ONE,APLUSC)*SQRT(F)
            SHIFT = F06BLF(TOP,BOT,FAIL)
         END IF
         IF (D1.NE.ZERO) THEN
            A = D1 - SHIFT/D1
            B = E1
         ELSE
            A = ONE
            B = ZERO
         END IF
      ELSE IF (JOB.EQ.(-2)) THEN
         TOP = 2*((DN*DNM1)**2)
         IF (TOP.EQ.ZERO) THEN
            SHIFT = ZERO
         ELSE
            F = ((DNM1-DN)**2+ENM1**2)*((DNM1+DN)**2+ENM1**2)
            APLUSC = DNM1**2 + DN**2 + ENM1**2
            BOT = APLUSC + SIGN(ONE,APLUSC)*SQRT(F)
            SHIFT = F06BLF(TOP,BOT,FAIL)
         END IF
         IF (D1.NE.ZERO) THEN
            A = D1 - SHIFT/D1
            B = E1
         ELSE
            A = ONE
            B = ZERO
         END IF
      END IF
      CALL F06BAF(A,B,C,S)
C
      RETURN
C
C     End of F02XUU. ( SBISFT )
C
      END
      SUBROUTINE F02XUV(SHIFT,M,N,D,E,C,S,WANTLT,CL,SL,WANTRT,CR,SR)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C  F02XUV performs a QR step on a bidiagonal matrix A.
C
C  When  SHIFT = 'N' or 'n'  ( Non-zero ),  then the parameters  c and s
C  must define the  initial right hand  plane rotation  to be used,  but
C  when  SHIFT = 'Z' or 'z'  ( Zero ), then the initial right hand plane
C  is determined by F02XUV so that
C
C     ( d( m )  0 ) := ( d( m )  e( m ) )*( c  -s )
C                                         ( s   c )
C
C  and c and s need not be supplied.
C
C  In either case,  plane rotations are then performed  alternately from
C  the  left and right  in order to  recover  the  bidiagonal form.  The
C  bidiagonal matrix  must be  supplied  with the  diagonal elements  in
C  d( m ), d( m + 1 ), ..., d( n )  and the  super-diagonal elements  in
C  e( m ), e( m + 1 ), ..., e( n - 1 ). When  m  is greater than  unity,
C  the assumption is that   e( m - 1 ) = 0.0.
C
C  Thus F02XUV performs the transformation
C
C     A := Q*A*P',
C
C  where  Q and P  are  orthogonal matrices.  P and Q  each consist of a
C  sequence of plane rotations
C
C     P = P( n - 1 )*...*P( m + 1 )*P( m )
C
C     Q = Q( n - 1 )*...*Q( m + 1 )*Q( m ),
C
C  where Q( k ) and P( k ) are each plane rotations for the ( k, k + 1 )
C  plane. The two by two part of the plane rotation matrix  Q( k )  will
C  be of the form
C
C     Q2 = (  cl( k )  sl( k ) ),
C          ( -sl( k )  cl( k ) )
C
C  and  if  WANTLT  is supplied as  true  then  cl( k ) and sl( k )  are
C  returned in the  corresponding elements of the arrays  CL and SL.  If
C  WANTLT  is supplied as false then  CL and SL  are not referenced. The
C  two by two  part of the plane rotation matrix  P( k )  will be of the
C  form
C
C     P2 = (  cr( k )  sr( k ) ),
C          ( -sr( k )  cr( k ) )
C
C  and  if  WANTRT  is supplied as  true  then  cr( k ) and sr( k )  are
C  returned in the corresponding elements of the arrays  CR and SR. Note
C  that  cr( m ) = c  and  sr( m ) = s. If  WANTRT  is supplied as false
C  then  CR and SR  are not referenced.
C
C  If  m.le.0  or  n.le.m  then an immediate return is effected.
C
C
C  Nag Fortran 77 basic linear algebra routine.
C
C  -- Written on 10-August-1987.
C     Sven Hammarling, Nag Central Office.
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  C, S
      INTEGER           M, N
      LOGICAL           WANTLT, WANTRT
      CHARACTER*1       SHIFT
C     .. Array Arguments ..
      DOUBLE PRECISION  CL(*), CR(*), D(*), E(*), SL(*), SR(*)
C     .. Local Scalars ..
      DOUBLE PRECISION  CO, CS, EI, SI, SN, TEMP
      INTEGER           I
C     .. External Subroutines ..
      EXTERNAL          F06BAF
C     .. Executable Statements ..
      IF ((M.GT.0) .AND. (M.LT.N)) THEN
         IF ((SHIFT.EQ.'N') .OR. (SHIFT.EQ.'n')) THEN
            IF (WANTRT) THEN
               CR(M) = C
               SR(M) = S
            END IF
            TEMP = C*D(M) + S*E(M)
            E(M) = C*E(M) - S*D(M)
            D(M) = TEMP
            TEMP = S*D(M+1)
            D(M+1) = C*D(M+1)
            DO 20 I = M, N - 2
               CALL F06BAF(D(I),TEMP,CS,SN)
               IF (WANTLT) THEN
                  CL(I) = CS
                  SL(I) = SN
               END IF
               TEMP = CS*E(I) + SN*D(I+1)
               D(I+1) = CS*D(I+1) - SN*E(I)
               E(I) = TEMP
               TEMP = SN*E(I+1)
               E(I+1) = CS*E(I+1)
               CALL F06BAF(E(I),TEMP,CS,SN)
               IF (WANTRT) THEN
                  CR(I+1) = CS
                  SR(I+1) = SN
               END IF
               TEMP = CS*D(I+1) + SN*E(I+1)
               E(I+1) = CS*E(I+1) - SN*D(I+1)
               D(I+1) = TEMP
               TEMP = SN*D(I+2)
               D(I+2) = CS*D(I+2)
   20       CONTINUE
            CALL F06BAF(D(N-1),TEMP,CS,SN)
            IF (WANTLT) THEN
               CL(N-1) = CS
               SL(N-1) = SN
            END IF
            TEMP = CS*E(N-1) + SN*D(N)
            D(N) = CS*D(N) - SN*E(N-1)
            E(N-1) = TEMP
         ELSE
            CALL F06BAF(D(M),E(M),C,S)
            IF (WANTRT) THEN
               CR(M) = C
               SR(M) = S
            END IF
            TEMP = S*D(M+1)
            D(M+1) = C*D(M+1)
            DO 40 I = M, N - 2
               CALL F06BAF(D(I),TEMP,CO,SI)
               IF (WANTLT) THEN
                  CL(I) = CO
                  SL(I) = SI
               END IF
               EI = D(I+1)
               TEMP = E(I+1)
               CALL F06BAF(EI,TEMP,CS,SN)
               IF (WANTRT) THEN
                  CR(I+1) = CS
                  SR(I+1) = SN
               END IF
               E(I) = SI*EI
               D(I+1) = CO*EI
               TEMP = SN*D(I+2)
               D(I+2) = CS*D(I+2)
   40       CONTINUE
            CALL F06BAF(D(N-1),TEMP,CS,SN)
            IF (WANTLT) THEN
               CL(N-1) = CS
               SL(N-1) = SN
            END IF
            E(N-1) = SN*D(N)
            D(N) = CS*D(N)
         END IF
      END IF
      RETURN
C
C     End of F02XUV. ( SBIQR1 )
C
      END
      SUBROUTINE F02XUW(M,N,D,E,WANTCS,C,S)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C  F02XUW annihilates the element  a( m, m + 1 )  of a bidiagonal matrix
C  A, on the assumption that  a( m, m ) is negligible, by applying plane
C  rotations from the  left.  Thus  F02XUW  performs  the transformation
C
C     A := P*A,
C
C  where  A  is  a  bidiagonal matrix,  with  diagonal elements  d( 1 ),
C  d( 2 ), ..., d( n )   and  super-diagonal  elements   e( 1 ), e( 2 ),
C  ..., e( n - 1 ),  and  P  is an  orthogonal matrix,  consisting  of a
C  sequence of plane rotations
C
C     P = P( m )*...*P( n - 2 )*P( n - 1 ),
C
C  where  P( k ) is a plane rotation for the ( k, k + 1 ) plane. The two
C  by two part of the plane rotation matrix  P( k )  will be of the form
C
C     R( k ) = (  c( k )  s( k ) ).
C              ( -s( k )  c( k ) )
C
C  If  WANTCS  is supplied as true then  c( k ) and s( k )  are returned
C  in  the  arrays  C and S,   otherwise  the  arrays  C and S  are  not
C  referenced.
C
C  The element  e( m ) = a( m, m + 1 )  is returned as  zero.
C
C  No check  is made  by this  routine to see if  d( m ) = a( m, m )  is
C  actually negligible.  If this  assumption  is not valid then the  mth
C  column of  P*A  will contain  non-negligible elements,  although this
C  column is not formed by the routine.
C
C  If  m.le.0 or m.ge.n  then an immediate return is effected.
C
C
C  Nag Fortran 77 basic linear algebra routine.
C
C  -- Written on 6-August-1987.
C     Sven Hammarling, Nag Central Office.
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO
      PARAMETER         (ZERO=0.0D+0)
C     .. Scalar Arguments ..
      INTEGER           M, N
      LOGICAL           WANTCS
C     .. Array Arguments ..
      DOUBLE PRECISION  C(*), D(*), E(*), S(*)
C     .. Local Scalars ..
      DOUBLE PRECISION  CS, SN, TEMP
      INTEGER           I
C     .. External Subroutines ..
      EXTERNAL          F06BAF
C     .. Executable Statements ..
C
      IF ((M.GT.0) .AND. (M.LT.N)) THEN
         I = M
         TEMP = E(I)
         E(I) = ZERO
         CALL F06BAF(D(I+1),TEMP,CS,SN)
         IF (WANTCS) THEN
            C(I) = CS
            S(I) = -SN
         END IF
         DO 20 I = M + 1, N - 1
            TEMP = -SN*E(I)
            E(I) = CS*E(I)
            CALL F06BAF(D(I+1),TEMP,CS,SN)
            IF (WANTCS) THEN
               C(I) = CS
               S(I) = -SN
            END IF
   20    CONTINUE
      END IF
      RETURN
C
C     End of F02XUW. ( SBIFRC )
C
      END
      SUBROUTINE F06AAZ ( SRNAME, INFO )
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     MARK 15 REVISED. IER-915 (APR 1991).
C     .. Scalar Arguments ..
      INTEGER            INFO
      CHARACTER*13       SRNAME
C     ..
C
C  Purpose
C  =======
C
C  F06AAZ  is an error handler for the Level 2 BLAS routines.
C
C  It is called by the Level 2 BLAS routines if an input parameter is
C  invalid.
C
C  Parameters
C  ==========
C
C  SRNAME - CHARACTER*13.
C           On entry, SRNAME specifies the name of the routine which
C           called F06AAZ.
C
C  INFO   - INTEGER.
C           On entry, INFO specifies the position of the invalid
C           parameter in the parameter-list of the calling routine.
C
C
C  Auxiliary routine for Level 2 Blas.
C
C  Written on 20-July-1986.
C
C     .. Local Scalars ..
      INTEGER            IERR, IFAIL
      CHARACTER*4        VARBNM
C     .. Local Arrays ..
      CHARACTER*80       REC (1)
C     .. External Functions ..
      INTEGER            P01ACF
      EXTERNAL           P01ACF
C     ..
C     .. Executable Statements ..
      WRITE (REC (1),99999) SRNAME, INFO
      IF (SRNAME(1:3).EQ.'F06') THEN
         IERR = -1
         VARBNM = '    '
      ELSE
         IERR = -INFO
         VARBNM = 'INFO'
      END IF
      IFAIL = 0
      IFAIL = P01ACF (IFAIL, IERR, SRNAME(1:6), VARBNM, 1, REC)
C
      RETURN
C
99999 FORMAT ( ' ** On entry to ', A13, ' parameter number ', I2,
     $         ' had an illegal value' )
C
C     End of F06AAZ.
C
      END
      SUBROUTINE F06BAF( A, B, C, S )
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     .. Scalar Arguments ..
      DOUBLE PRECISION   A, B, C, S
C     ..
C
C  Nag  Fortran 77  version of the  SROTG BLAS,  except that c is always
C  returned as non-negative and  b  is overwritten by the tangent of the
C  angle that defines the plane rotation.
C
C  c and s are given as
C
C     c = 1.0/sqrt( 1.0 + t**2 ),   s = c*t   where   t = b/a.
C
C  When  abs( b ) .le. eps*abs( a ),  where  eps is the relative machine
C  precision as  returned by routine  X02AJF,  then  c and s  are always
C  returned as
C
C     c = 1.0  and  s = 0.0
C
C  and when  abs( a ) .le. eps*abs( b ) then c and s are always returned
C  as
C
C     c = 0.0  and  s = sign( t ).
C
C  Note that t is always returned as  b/a, unless this would overflow in
C  which  case the value  sign( t )*flmax  is returned,  where  flmax is
C  the value given by  1/X02AMF( ).
C
C  c and s  can be reconstructed from the tangent,  t,  by a call to the
C  Nag basic linear algebra routine F06BCF.
C
C
C  Nag Fortran 77 O( 1 ) basic linear algebra routine.
C
C  -- Written on 3-January-1986.
C     Sven Hammarling, Nag Central Office.
C
C
C     .. Parameters ..
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
C     .. Local Scalars ..
      DOUBLE PRECISION   T
      LOGICAL            FAIL
C     .. External Functions ..
      DOUBLE PRECISION   F06BLF
      EXTERNAL           F06BLF
C     .. External Subroutines ..
      EXTERNAL           F06BCF
C     ..
C     .. Executable Statements ..
      IF( B.EQ.ZERO )THEN
         C  = ONE
         S  = ZERO
      ELSE
         T  = F06BLF( B, A, FAIL )
         CALL F06BCF( T, C, S )
         A  = C*A + S*B
         B  = T
      END IF
C
      RETURN
C
C     End of F06BAF. ( SROTGC )
C
      END
      SUBROUTINE F06BCF( T, C, S )                                              
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.                                      
C     MARK 13 REVISED. IER-602 (MAR 1988).                                      
C     MARK 18 REVISED (THREAD SAFETY). (SEP 1996).                              
C     .. Scalar Arguments ..                                                    
      DOUBLE PRECISION   C, S, T                                                
C     ..                                                                        
C                                                                               
C  F06BCF returns values c and s such that                                      
C                                                                               
C     c = cos( theta ),   s = sin( theta )                                      
C                                                                               
C  for a given value of                                                         
C                                                                               
C     t = tan( theta ).                                                         
C                                                                               
C  c is always non-negative and s has the same sign as t, so that               
C                                                                               
C     c = 1.0/sqrt( 1.0 + t**2 ),   s = t/sqrt( 1.0 + t**2 ).                   
C                                                                               
C  Nag Fortran 77 O( 1 ) basic linear algebra routine.                          
C                                                                               
C  -- Written on 28-February-1986.                                              
C     Sven Hammarling, Nag Central Office.                                      
C  -- Modified 19-August-1987.                                                  
C     Sven Hammarling and Jeremy Du Croz, Nag Central Office.                   
C        No longer sets s to zero when t is less than eps.                      
C                                                                               
C                                                                               
C     .. Parameters ..                                                          
      DOUBLE PRECISION   ONE                                                    
      PARAMETER        ( ONE = 1.0D+0 )                                         
      DOUBLE PRECISION RRTEPS,RTEPS
      PARAMETER (RRTEPS =9.49062656242516D+7)
      PARAMETER (RTEPS =1.05367121277235D-8)
C     .. Local Scalars ..                                                       
      DOUBLE PRECISION   ABST                                                   
C     .. Intrinsic Functions ..                                                 
      INTRINSIC          ABS, SIGN, SQRT                                        
C     ..                                                                        
C     .. Executable Statements ..                                               
C                                                                               
      ABST = ABS( T )                                                           
      IF( ABST.LT.RTEPS )THEN                                                   
         C = ONE                                                                
         S = T                                                                  
      ELSE IF( ABST.GT.RRTEPS )THEN                                             
         C = 1/ABST                                                             
         S = SIGN( ONE, T )                                                     
      ELSE                                                                      
         C = 1/SQRT( 1 + ABST**2 )                                              
         S = C*T                                                                
      END IF                                                                    
C                                                                               
      RETURN                                                                    
C                                                                               
C     End of F06BCF. ( SCSG )                                                   
C                                                                               
      END                                                                       
      DOUBLE PRECISION FUNCTION F06BLF( A, B, FAIL )                            
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.                                      
C     MARK 18 REVISED (THREAD SAFETY). (SEP 1996).                              
C     .. Scalar Arguments ..                                                    
      DOUBLE PRECISION                  A, B                                    
      LOGICAL                           FAIL                                    
C     ..                                                                        
C                                                                               
C  F06BLF returns the value div given by                                        
C                                                                               
C     div = ( a/b                 if a/b does not overflow,                     
C           (                                                                   
C           ( 0.0                 if a .eq. 0.0,                                
C           (                                                                   
C           ( sign( a/b )*flmax   if a .ne. 0.0  and a/b would overflow,        
C                                                                               
C  where  flmax  is a large value, via the function name. In addition if        
C  a/b would overflow then  fail is returned as true, otherwise  fail is        
C  returned as false.                                                           
C                                                                               
C  Note that when  a and b  are both zero, fail is returned as true, but        
C  div  is returned as  0.0. In all other cases of overflow  div is such        
C  that  abs( div ) = flmax.                                                    
C                                                                               
C  When  b = 0  then  sign( a/b )  is taken as  sign( a ).                      
C                                                                               
C  Nag Fortran 77 O( 1 ) basic linear algebra routine.                          
C                                                                               
C  -- Written on 26-October-1982.                                               
C     Sven Hammarling, Nag Central Office.                                      
C                                                                               
C                                                                               
C     .. Parameters ..                                                          
      DOUBLE PRECISION      ONE         , ZERO                                  
      PARAMETER           ( ONE = 1.0D+0, ZERO = 0.0D+0 )                       
      DOUBLE PRECISION FLMAX, FLMIN
      PARAMETER (FLMAX =4.49423283715580D+307)
      PARAMETER (FLMIN =2.22507385850721D-308)
C     .. Local Scalars ..                                                       
      DOUBLE PRECISION      ABSB, DIV                                           
C     .. Intrinsic Functions ..                                                 
      INTRINSIC             ABS, SIGN                                           
C     ..                                                                        
C     .. Executable Statements ..                                               
      IF( A.EQ.ZERO )THEN                                                       
         DIV = ZERO                                                             
         IF( B.EQ.ZERO )THEN                                                    
            FAIL = .TRUE.                                                       
         ELSE                                                                   
            FAIL = .FALSE.                                                      
         END IF                                                                 
      ELSE                                                                      
C                                                                               
         IF( B.EQ.ZERO )THEN                                                    
            DIV  =  SIGN( FLMAX, A )                                            
            FAIL = .TRUE.                                                       
         ELSE                                                                   
            ABSB = ABS( B )                                                     
            IF( ABSB.GE.ONE )THEN                                               
               FAIL = .FALSE.                                                   
               IF( ABS( A ).GE.ABSB*FLMIN )THEN                                 
                  DIV = A/B                                                     
               ELSE                                                             
                  DIV = ZERO                                                    
               END IF                                                           
            ELSE                                                                
               IF( ABS( A ).LE.ABSB*FLMAX )THEN                                 
                  FAIL = .FALSE.                                                
                  DIV  =  A/B                                                   
               ELSE                                                             
                  FAIL = .TRUE.                                                 
                  DIV  = FLMAX                                                  
                  IF( ( ( A.LT.ZERO ).AND.( B.GT.ZERO ) ).OR.                   
     $                ( ( A.GT.ZERO ).AND.( B.LT.ZERO ) )     )                 
     $               DIV = -DIV                                                 
               END IF                                                           
            END IF                                                              
         END IF                                                                 
      END IF                                                                    
C                                                                               
      F06BLF = DIV                                                              
      RETURN                                                                    
C                                                                               
C     End of F06BLF. ( SDIV )                                                   
C                                                                               
      END                                                                       
      DOUBLE PRECISION FUNCTION F06BNF( A, B )
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     .. Scalar Arguments ..
      DOUBLE PRECISION                  A, B
C     ..
C
C  F06BNF returns the value
C
C     p = sqrt( a*a + b*b )
C
C  via the function name.
C
C
C  Nag Fortran 77 O( 1 ) basic linear algebra routine.
C
C  -- Written on 17-January-1985.
C     Sven Hammarling, Nag Central Office.
C
C
C     .. Parameters ..
      DOUBLE PRECISION      ZERO
      PARAMETER           ( ZERO = 0.0D+0 )
C     .. Local Scalars ..
      DOUBLE PRECISION      P
C     .. Intrinsic Functions ..
      INTRINSIC             ABS, SQRT
C     ..
C     .. Executable Statements ..
      IF( A.EQ.ZERO )THEN
         P = ABS( B )
      ELSE IF( B.EQ.ZERO )THEN
         P = ABS( A )
      ELSE IF( ABS( A ).GE.ABS( B ) )THEN
         P = ABS( A )*SQRT( 1 + ( B/A )**2 )
      ELSE
         P = ABS( B )*SQRT( 1 + ( A/B )**2 )
      END IF
C
      F06BNF = P
      RETURN
C
C     End of F06BNF. ( SPYTH )
C
      END
      SUBROUTINE F06FBF( N, CONST, X, INCX )
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     .. Scalar Arguments ..
      DOUBLE PRECISION   CONST
      INTEGER            INCX, N
C     .. Array Arguments ..
      DOUBLE PRECISION   X( * )
C     ..
C
C  F06FBF performs the operation
C
C     x = const*e,   e' = ( 1  1 ... 1 ).
C
C
C  Nag Fortran 77 O( n ) basic linear algebra routine.
C
C  -- Written on 22-September-1983.
C     Sven Hammarling, Nag Central Office.
C
C
C     .. Parameters ..
      DOUBLE PRECISION   ZERO
      PARAMETER        ( ZERO = 0.0D+0 )
C     .. Local Scalars ..
      INTEGER            IX
C     ..
C     .. Executable Statements ..
      IF( N.GT.0 )THEN
         IF( CONST.NE.ZERO )THEN
            DO 10, IX = 1, 1 + ( N - 1 )*INCX, INCX
               X( IX ) = CONST
   10       CONTINUE
         ELSE
            DO 20, IX = 1, 1 + ( N - 1 )*INCX, INCX
               X( IX ) = ZERO
   20       CONTINUE
         END IF
      END IF
C
      RETURN
C
C     End of F06FBF. ( SLOAD )
C
      END
      SUBROUTINE F06FGF( N, X, INCX )
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     .. Scalar Arguments ..
      INTEGER            INCX, N
C     .. Array Arguments ..
      DOUBLE PRECISION   X( * )
C     ..
C
C  F06FGF performs the operation
C
C     x := -x
C
C
C  Nag Fortran 77 O( n ) basic linear algebra routine.
C
C  -- Written on 22-September-1983.
C     Sven Hammarling, Nag Central Office.
C
C
C     .. Local Scalars ..
      INTEGER            IX
C     ..
C     .. Executable Statements ..
      IF( N.GT.0 )THEN
         DO 10, IX = 1, 1 + ( N - 1 )*INCX, INCX
            X( IX ) = -X( IX )
   10    CONTINUE
      END IF
C
      RETURN
C
C     End of F06FGF. ( SNEGV )
C
      END
      SUBROUTINE F06FJF( N, X, INCX, SCALE, SUMSQ )
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     .. Scalar Arguments ..
      DOUBLE PRECISION   SCALE, SUMSQ
      INTEGER            INCX, N
C     .. Array Arguments ..
      DOUBLE PRECISION   X( * )
C     ..
C
C  F06FJF returns the values scl and smsq such that
C
C     ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
C
C  where x( i ) = X( 1 + ( i - 1 )*INCX ). The value of sumsq is assumed
C  to be at least unity and the value of smsq will then satisfy
C
C     1.0 .le. smsq .le. ( sumsq + n ) .
C
C  scale is assumed to be non-negative and scl returns the value
C
C     scl = max( scale, abs( x( i ) ) ) .
C
C  scale and sumsq must be supplied in SCALE and SUMSQ respectively.
C  scl and smsq are overwritten on SCALE and SUMSQ respectively.
C
C  The routine makes only one pass through the vector X.
C
C
C  Nag Fortran 77 O( n ) basic linear algebra routine.
C
C  -- Written on 22-October-1982.
C     Sven Hammarling, Nag Central Office.
C
C
C     .. Parameters ..
      DOUBLE PRECISION   ZERO
      PARAMETER        ( ZERO = 0.0D+0 )
C     .. Local Scalars ..
      DOUBLE PRECISION   ABSXI
      INTEGER            IX
C     .. Intrinsic Functions ..
      INTRINSIC          ABS
C     ..
C     .. Executable Statements ..
      IF( N.GT.0 )THEN
         DO 10, IX = 1, 1 + ( N - 1 )*INCX, INCX
            IF( X( IX ).NE.ZERO )THEN
               ABSXI = ABS( X( IX ) )
               IF( SCALE.LT.ABSXI )THEN
                  SUMSQ = 1     + SUMSQ*( SCALE/ABSXI )**2
                  SCALE = ABSXI
               ELSE
                  SUMSQ = SUMSQ +       ( ABSXI/SCALE )**2
               END IF
            END IF
   10    CONTINUE
      END IF
      RETURN
C
C     End of F06FJF. ( SSSQ )
C
      END
      SUBROUTINE F06FQF( PIVOT, DIRECT, N, ALPHA, X, INCX, C, S )
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     .. Scalar Arguments ..
      DOUBLE PRECISION   ALPHA
      INTEGER            INCX, N
      CHARACTER*1        DIRECT, PIVOT
C     .. Array Arguments ..
      DOUBLE PRECISION   C( * ), S( * ), X( * )
C     ..
C
C  F06FQF generates the parameters of an orthogonal matrix P such that
C
C     when   PIVOT = 'F' or 'f'   and   DIRECT = 'F' or 'f'
C     or     PIVOT = 'V' or 'v'   and   DIRECT = 'B' or 'b'
C
C        P*( alpha ) = ( beta ),
C          (   x   )   (   0  )
C
C     when   PIVOT = 'F' or 'f'   and   DIRECT = 'B' or 'b'
C     or     PIVOT = 'V' or 'v'   and   DIRECT = 'F' or 'f'
C
C        P*(   x   ) = (   0  ),
C          ( alpha ) = ( beta )
C
C  where alpha is a scalar and x is an n element vector.
C
C  When  PIVOT = 'F' or 'f'  ( fixed pivot )
C  and  DIRECT = 'F' or 'f'  ( forward sequence ) then
C
C     P is given as the sequence of plane rotation matrices
C
C        P = P( n )*P( n - 1 )*...*P( 1 )
C
C     where P( k ) is a plane rotation matrix for the ( 1, k + 1 ) plane
C     designed to annihilate the kth element of x.
C
C  When  PIVOT = 'V' or 'v'  ( variable pivot )
C  and  DIRECT = 'B' or 'b'  ( backward sequence ) then
C
C     P is given as the sequence of plane rotation matrices
C
C        P = P( 1 )*P( 2 )*...*P( n )
C
C     where P( k ) is a plane rotation matrix for the ( k, k + 1 ) plane
C     designed to annihilate the kth element of x.
C
C  When  PIVOT = 'F' or 'f'  ( fixed pivot )
C  and  DIRECT = 'B' or 'b'  ( backward sequence ) then
C
C     P is given as the sequence of plane rotation matrices
C
C        P = P( 1 )*P( 2 )*...*P( n )
C
C     where P( k ) is a plane rotation matrix for the ( k, n + 1 ) plane
C     designed to annihilate the kth element of x.
C
C  When  PIVOT = 'V' or 'v'  ( variable pivot )
C  and  DIRECT = 'F' or 'f'  ( forward sequence ) then
C
C     P is given as the sequence of plane rotation matrices
C
C        P = P( n )*P( n - 1 )*...*P( 1 )
C
C     where P( k ) is a plane rotation matrix for the ( k, k + 1 ) plane
C     designed to annihilate the kth element of x.
C
C  The routine returns the cosine, c( k ), and sine, s( k ) that define
C  the matrix P( k ), such that the two by two rotation part of P( k ),
C  R( k ), has the form
C
C     R( k ) = (  c( k )  s( k ) ).
C              ( -s( k )  c( k ) )
C
C  On entry, ALPHA must contain  the scalar alpha and on exit, ALPHA is
C  overwritten by beta. The cosines and sines are returned in the arrays
C  C and S and the vector x is overwritten by the tangents of the plane
C  rotations ( t( k ) = s( k )/c( k ) ).
C
C
C
C  Nag Fortran 77 O( n ) basic linear algebra routine.
C
C  -- Written on 19-April-1985.
C     Sven Hammarling, Nag Central Office.
C
C
C     .. Local Scalars ..
      INTEGER            I, IX
C     .. External Subroutines ..
      EXTERNAL           F06BAF
C     ..
C     .. Executable Statements ..
      IF( N.GT.0 )THEN
         IF( ( DIRECT.EQ.'B' ).OR.( DIRECT.EQ.'b' ) )THEN
            IX = 1 + ( N - 1 )*INCX
            IF( ( PIVOT.EQ.'V' ).OR.( PIVOT.EQ.'v' ) )THEN
               DO 10, I = N, 2, -1
                  CALL F06BAF( X( IX - INCX ), X( IX ), C( I ), S( I ) )
                  IX = IX - INCX
   10          CONTINUE
               CALL F06BAF( ALPHA, X( IX ), C( 1 ), S( 1 ) )
            ELSE IF( ( PIVOT.EQ.'F' ).OR.( PIVOT.EQ.'f' ) )THEN
C
C              Here we choose c and s so that
C
C                 ( alpha ) := (  c  s )*( alpha  )
C                 (   0   )    ( -s  c ) ( x( i ) )
C
C              which is equivalent to
C
C                 (   0   ) := ( c  -s )*( x( i ) )
C                 ( alpha )    ( s   c ) ( alpha  )
C
C              and so we need to return  s( i ) = -s  in order to make
C              R( i ) look like
C
C                 R( i ) = (  c( i )  s( i ) ).
C                          ( -s( i )  c( i ) )
C
               DO 20, I = N, 1, -1
                  CALL F06BAF( ALPHA, X( IX ), C( I ), S( I ) )
                  S( I )  = -S( I )
                  X( IX ) = -X( IX )
                  IX      =  IX      - INCX
   20          CONTINUE
            END IF
         ELSE IF( ( DIRECT.EQ.'F' ).OR.( DIRECT.EQ.'f' ) )THEN
            IX = 1
            IF( ( PIVOT.EQ.'V' ).OR.( PIVOT.EQ.'v' ) )THEN
C
C              Here we choose c and s so that
C
C                 ( x( i + 1 ) ) := (  c  s )*( x( i + 1 ) )
C                 (    0       )    ( -s  c ) ( x( i )     )
C
C              which is equivalent to
C
C                 (    0       ) := ( c  -s )*( x( i )     )
C                 ( x( i + 1 ) )    ( s   c ) ( x( i + 1 ) )
C
C              and so we need to return  s( i ) = -s  in order to make
C              R( i ) look like
C
C                 R( i ) = (  c( i )  s( i ) ).
C                          ( -s( i )  c( i ) )
C
               DO 30, I = 1, N - 1
                  CALL F06BAF( X( IX + INCX ), X( IX ), C( I ), S( I ) )
                  S( I )  = -S( I )
                  X( IX ) = -X( IX )
                  IX      =  IX      + INCX
   30          CONTINUE
               CALL F06BAF( ALPHA, X( IX ), C( N ), S( N ) )
               S( N )  = -S( N )
               X( IX ) = -X( IX )
            ELSE IF( ( PIVOT.EQ.'F' ).OR.( PIVOT.EQ.'f' ) )THEN
               DO 40, I = 1, N
                  CALL F06BAF( ALPHA, X( IX ), C( I ), S( I ) )
                  IX = IX + INCX
   40          CONTINUE
            END IF
         END IF
      END IF
C
      RETURN
C
C     End of F06FQF. ( SSROTG )
C
      END
      SUBROUTINE F06FRF( N, ALPHA, X, INCX, TOL, ZETA )
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     MARK 18 REVISED (THREAD SAFETY). (SEP 1996).
C     .. Scalar Arguments ..
      DOUBLE PRECISION   ALPHA, TOL, ZETA
      INTEGER            INCX, N
C     .. Array Arguments ..
      DOUBLE PRECISION   X( * )
C     ..
C
C  F06FRF generates details of a generalized Householder reflection such
C  that
C
C     P*( alpha ) = ( beta ),   P'*P = I.
C       (   x   )   (   0  )
C
C  P is given in the form
C
C     P = I - ( zeta )*( zeta  z' ),
C             (   z  )
C
C  where z is an n element vector and zeta is a scalar that satisfies
C
C     1.0 .le. zeta .le. sqrt( 2.0 ).
C
C  zeta is returned in ZETA unless x is such that
C
C     max( abs( x( i ) ) ) .le. max( eps*abs( alpha ), tol )
C
C  where eps is the relative machine precision and tol is the user
C  supplied value TOL, in which case ZETA is returned as 0.0 and P can
C  be taken to be the unit matrix.
C
C  beta is overwritten on alpha and z is overwritten on x.
C  the routine may be called with  n = 0  and advantage is taken of the
C  case where  n = 1.
C
C
C  Nag Fortran 77 O( n ) basic linear algebra routine.
C
C  -- Written on 30-August-1984.
C     Sven Hammarling, Nag Central Office.
C     This version dated 28-September-1984.
C
C
C     .. Parameters ..
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
C     .. Local Scalars ..
      DOUBLE PRECISION   BETA, EPS, SCALE, SSQ
C     .. External Functions ..
      DOUBLE PRECISION   X02AJF
      EXTERNAL           X02AJF
C     .. External Subroutines ..
      EXTERNAL           F06FJF, DSCAL
C     .. Intrinsic Functions ..
      INTRINSIC          ABS, MAX, SIGN, SQRT
C     ..
C     .. Executable Statements ..
      IF( N.LT.1 )THEN
         ZETA = ZERO
      ELSE IF( ( N.EQ.1 ).AND.( X( 1 ).EQ.ZERO ) )THEN
         ZETA = ZERO
      ELSE
C
         EPS   =  X02AJF( )
C
C        Treat case where P is a 2 by 2 matrix specially.
C
         IF( N.EQ.1 )THEN
C
C           Deal with cases where  ALPHA = zero  and
C           abs( X( 1 ) ) .le. max( EPS*abs( ALPHA ), TOL )  first.
C
            IF( ALPHA.EQ.ZERO )THEN
               ZETA   =  ONE
               ALPHA  =  ABS ( X( 1 ) )
               X( 1 ) = -SIGN( ONE, X( 1 ) )
            ELSE IF( ABS( X( 1 ) ).LE.MAX( EPS*ABS( ALPHA ), TOL ) )THEN
               ZETA   =  ZERO
            ELSE
               IF( ABS( ALPHA ).GE.ABS( X( 1 ) ) )THEN
                  BETA = ABS( ALPHA ) *SQRT( 1 + ( X( 1 )/ALPHA )**2 )
               ELSE
                  BETA = ABS( X( 1 ) )*SQRT( 1 + ( ALPHA/X( 1 ) )**2 )
               END IF
               ZETA = SQRT( ( ABS( ALPHA ) + BETA )/BETA )
               IF( ALPHA.GE.ZERO )
     $            BETA = -BETA
               X( 1 ) = -X( 1 )/( ZETA*BETA )
               ALPHA  = BETA
            END IF
         ELSE
C
C           Now P is larger than 2 by 2.
C
            SSQ   = ONE
            SCALE = ZERO
            CALL F06FJF( N, X, INCX, SCALE, SSQ )
C
C           Treat cases where  SCALE = zero,
C           SCALE .le. max( EPS*abs( ALPHA ), TOL )  and
C           ALPHA = zero  specially.
C           Note that  SCALE = max( abs( X( i ) ) ).
C
            IF( ( SCALE.EQ.ZERO ).OR.
     $          ( SCALE.LE.MAX( EPS*ABS( ALPHA ), TOL ) ) )THEN
               ZETA  = ZERO
            ELSE IF( ALPHA.EQ.ZERO )THEN
               ZETA  = ONE
               ALPHA = SCALE*SQRT( SSQ )
               CALL DSCAL( N, -1/ALPHA, X, INCX )
            ELSE
               IF( SCALE.LT.ABS( ALPHA ) )THEN
                  BETA = ABS( ALPHA )*SQRT( 1 + SSQ*( SCALE/ALPHA )**2 )
               ELSE
                  BETA = SCALE       *SQRT( SSQ +   ( ALPHA/SCALE )**2 )
               END IF
               ZETA = SQRT( ( BETA + ABS( ALPHA ) )/BETA )
               IF( ALPHA.GT.ZERO )
     $            BETA = -BETA
               CALL DSCAL( N, -1/( ZETA*BETA ), X, INCX )
               ALPHA = BETA
            END IF
         END IF
      END IF
C
      RETURN
C
C     End of F06FRF. ( SGRFG )
C
      END
      SUBROUTINE F06QFF( MATRIX, M, N, A, LDA, B, LDB )
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     .. Scalar Arguments ..
      CHARACTER*1        MATRIX
      INTEGER            M, N, LDA, LDB
C     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
C     ..
C
C  F06QFF  copies  the  m by n  matrix  A  into  the  m by n  matrix  B.
C
C  If   MATRIX = 'G' or 'g'   then  A  and  B  are  regarded as  general
C                             matrices,
C  if   MATRIX = 'U' or 'u'   then  A  and  B  are  regarded  as   upper
C                             triangular,  and only  elements  for which
C                             i.le.j  are referenced,
C  if   MATRIX = 'L' or 'l'   then  A  and  B  are  regarded  as   lower
C                             triangular,  and only  elements  for which
C                             i.ge.j  are referenced.
C
C
C  Nag Fortran 77 O( n**2 ) basic linear algebra routine.
C
C  -- Written on 21-November-1986.
C     Sven Hammarling, Nag Central Office.
C
C
C     .. Local Scalars ..
      INTEGER            I, J
C     .. Intrinsic Functions ..
      INTRINSIC          MIN
C     ..
C     .. Executable Statements ..
      IF( ( MATRIX.EQ.'G' ).OR.( MATRIX.EQ.'g' ) )THEN
         DO 20 J = 1, N
            DO 10 I = 1, M
               B( I, J ) = A( I, J )
   10       CONTINUE
   20    CONTINUE
      ELSE IF( ( MATRIX.EQ.'U' ).OR.( MATRIX.EQ.'u' ) )THEN
         DO 40 J = 1, N
            DO 30 I = 1, MIN( M, J )
               B( I, J ) = A( I, J )
   30       CONTINUE
   40    CONTINUE
      ELSE IF( ( MATRIX.EQ.'L' ).OR.( MATRIX.EQ.'l' ) )THEN
         DO 60 J = 1, MIN( M, N )
            DO 50 I = J, M
               B( I, J ) = A( I, J )
   50       CONTINUE
   60    CONTINUE
      END IF
C
      RETURN
C
C     End of F06QFF. ( SMCOPY )
C
      END
      SUBROUTINE F06QHF( MATRIX, M, N, CONST, DIAG, A, LDA )
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     .. Scalar Arguments ..
      CHARACTER*1        MATRIX
      DOUBLE PRECISION   CONST, DIAG
      INTEGER            LDA, M, N
C     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * )
C     ..
C
C  F06QHF forms the m by n matrix A given by
C
C     a( i, j ) = (  diag  i.eq.j,
C                 (
C                 ( const  i.ne.j.
C
C  If   MATRIX = 'G' or 'g'   then  A  is regarded  as a general matrix,
C  if   MATRIX = 'U' or 'u'   then  A  is regarded  as upper triangular,
C                             and only  elements  for which  i.le.j  are
C                             referenced,
C  if   MATRIX = 'L' or 'l'   then  A  is regarded  as lower triangular,
C                             and only  elements  for which  i.ge.j  are
C                             referenced.
C
C
C  Nag Fortran 77 O( n**2 ) basic linear algebra routine.
C
C  -- Written on 21-November-1986.
C     Sven Hammarling, Nag Central Office.
C
C
C     .. Local Scalars ..
      INTEGER            I, J
C     .. Intrinsic Functions ..
      INTRINSIC          MIN
C     ..
C     .. Executable Statements ..
      IF( ( MATRIX.EQ.'G' ).OR.( MATRIX.EQ.'g' ) )THEN
         DO 20 J = 1, N
            DO 10 I = 1, M
               A( I, J ) = CONST
   10       CONTINUE
   20    CONTINUE
         IF( CONST.NE.DIAG )THEN
            DO 30 I = 1, MIN( M, N )
               A( I, I ) = DIAG
   30       CONTINUE
         END IF
      ELSE IF( ( MATRIX.EQ.'U' ).OR.( MATRIX.EQ.'u' ) )THEN
         DO 50 J = 1, N
            DO 40 I = 1, MIN( M, J )
               A( I, J ) = CONST
   40       CONTINUE
   50    CONTINUE
         IF( CONST.NE.DIAG )THEN
            DO 60 I = 1, MIN( M, N )
               A( I, I ) = DIAG
   60       CONTINUE
         END IF
      ELSE IF( ( MATRIX.EQ.'L' ).OR.( MATRIX.EQ.'l' ) )THEN
         DO 80 J = 1, MIN( M, N )
            DO 70 I = J, M
               A( I, J ) = CONST
   70       CONTINUE
   80    CONTINUE
         IF( CONST.NE.DIAG )THEN
            DO 90 I = 1, MIN( M, N )
               A( I, I ) = DIAG
   90       CONTINUE
         END IF
      END IF
C
      RETURN
C
C     End of F06QHF. ( SMLOAD )
C
      END
      SUBROUTINE F06QKF( SIDE, TRANS, N, PERM, K, B, LDB )
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     .. Scalar Arguments ..
      INTEGER            K, LDB, N
      CHARACTER*1        SIDE, TRANS
C     .. Array Arguments ..
      DOUBLE PRECISION   PERM( * ), B( LDB, * )
C     ..
C
C  Purpose
C  =======
C
C  F06QKF performs one of the transformations
C
C     B := P'*B   or   B := P*B,   where B is an m by k matrix,
C
C  or
C
C     B := B*P'   or   B := B*P,   where B is a k by m matrix,
C
C  P being an m by m permutation matrix of the form
C
C     P = P( 1, index( 1 ) )*P( 2, index( 2 ) )*...*P( n, index( n ) ),
C
C  where  P( i, index( i ) ) is the permutation matrix that interchanges
C  items i and index( i ). That is P( i, index( i ) ) is the unit matrix
C  with rows and columns  i and  index( i )  interchanged. Of course, if
C  index( i ) = i  then  P( i, index( i ) ) = I.
C
C  This  routine is intended  for use in conjunction with  Nag auxiliary
C  routines  that  perform  interchange  operations,  such  as  sorting.
C
C  Parameters
C  ==========
C
C  SIDE   - CHARACTER*1.
C  TRANS
C           On entry,  SIDE  ( Left-hand side, or Right-hand side )  and
C           TRANS  ( Transpose, or No transpose )  specify the operation
C           to be performed as follows.
C
C           SIDE = 'L' or 'l'   and   TRANS = 'T' or 't'
C
C              Perform the operation   B := P'*B.
C
C           SIDE = 'L' or 'l'   and   TRANS = 'N' or 'n'
C
C              Perform the operation   B := P*B.
C
C           SIDE = 'R' or 'r'   and   TRANS = 'T' or 't'
C
C              Perform the operation   B := B*P'.
C
C           SIDE = 'R' or 'r'   and   TRANS = 'N' or 'n'
C
C              Perform the operation   B := B*P.
C
C           Unchanged on exit.
C
C  N      - INTEGER.
C
C           On entry, N must specify the value of n.  N must be at least
C           zero.  When  N = 0  then an  immediate  return  is effected.
C
C           Unchanged on exit.
C
C  PERM   - REAL             array of DIMENSION at least ( n ).
C
C           Before  entry,  PERM  must  contain  the  n indices  for the
C           permutation matrices. index( i ) must satisfy
C
C              1 .le. index( i ) .le. m.
C
C           It is usual for index( i ) to be at least i, but this is not
C           necessary for this routine. It is assumed that the statement
C           INDEX = PERM( I )  returns the correct integer in  INDEX, so
C           that,  if necessary,  PERM( I )  should contain a real value
C           slightly larger than  INDEX.
C
C           Unchanged on exit.
C
C  K      - INTEGER.
C
C           On entry with  SIDE = 'L' or 'l',  K must specify the number
C           of columns of B and on entry with  SIDE = 'R' or 'r', K must
C           specify the number of rows of  B.  K must be at least  zero.
C           When  K = 0  then an immediate return is effected.
C
C           Unchanged on exit.
C
C  B      - REAL  array  of  DIMENSION ( LDB, ncolb ),  where  ncolb = k
C           when  SIDE = 'L' or 'l'  and  ncolb = m  when  SIDE = 'R' or
C           'r'.
C
C           Before entry  with  SIDE = 'L' or 'l',  the  leading  m by K
C           part  of  the  array   B  must  contain  the  matrix  to  be
C           transformed  and before  entry with  SIDE = 'R' or 'r',  the
C           leading  K by m part of the array  B must contain the matrix
C           to  be  transformed.  On exit,   B  is  overwritten  by  the
C           transformed matrix.
C
C  LDB    - INTEGER.
C
C           On entry,  LDB  must specify  the  leading dimension  of the
C           array  B  as declared  in the  calling  (sub) program.  When
C           SIDE = 'L' or 'l'   then  LDB  must  be  at  least  m,  when
C           SIDE = 'R' or 'r'   then  LDB  must  be  at  least  k.
C           Unchanged on exit.
C
C
C  Nag Fortran 77 O( n**2 ) basic linear algebra routine.
C
C  -- Written on 11-August-1987.
C     Sven Hammarling, Nag Central Office.
C
C
C     .. Local Scalars ..
      LOGICAL            LEFT, NULL, RIGHT, TRNSP
      INTEGER            I, J, L
      DOUBLE PRECISION   TEMP
C     .. Intrinsic Functions ..
      INTRINSIC          MIN
C     ..
C     .. Executable Statements ..
      IF( MIN( N, K ).EQ.0 )
     $   RETURN
      LEFT = ( SIDE.EQ.'L' ).OR.( SIDE.EQ.'l' )
      RIGHT = ( SIDE.EQ.'R' ).OR.( SIDE.EQ.'r' )
      NULL = ( TRANS.EQ.'N' ).OR.( TRANS.EQ.'n' )
      TRNSP = ( TRANS.EQ.'T' ).OR.( TRANS.EQ.'t' )
      IF( LEFT )THEN
         IF( TRNSP )THEN
            DO 20 I = 1, N
               L = PERM( I )
               IF( L.NE.I )THEN
                  DO 10 J = 1, K
                     TEMP = B( I, J )
                     B( I, J ) = B( L, J )
                     B( L, J ) = TEMP
   10             CONTINUE
               END IF
   20       CONTINUE
         ELSE IF( NULL )THEN
            DO 40 I = N, 1, -1
               L = PERM( I )
               IF( L.NE.I )THEN
                  DO 30 J = 1, K
                     TEMP = B( L, J )
                     B( L, J ) = B( I, J )
                     B( I, J ) = TEMP
   30             CONTINUE
               END IF
   40       CONTINUE
         END IF
      ELSE IF( RIGHT )THEN
         IF( TRNSP )THEN
            DO 60 J = N, 1, -1
               L = PERM( J )
               IF( L.NE.J )THEN
                  DO 50 I = 1, K
                     TEMP = B( I, J )
                     B( I, J ) = B( I, L )
                     B( I, L ) = TEMP
   50             CONTINUE
               END IF
   60       CONTINUE
         ELSE IF( NULL )THEN
            DO 80 J = 1, N
               L = PERM( J )
               IF( L.NE.J )THEN
                  DO 70 I = 1, K
                     TEMP = B( I, L )
                     B( I, L ) = B( I, J )
                     B( I, J ) = TEMP
   70             CONTINUE
               END IF
   80       CONTINUE
         END IF
      END IF
C
      RETURN
C
C     End of F06QKF. ( SGEAPR )
C
      END
      SUBROUTINE F06QTF( SIDE, N, K1, K2, C, S, A, LDA )
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     .. Scalar Arguments ..
      INTEGER            K1, K2, LDA, N
      CHARACTER*1        SIDE
C     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), C( * ), S( * )
C     ..
C
C  F06QTF performs the transformation
C
C     R := P*U*Q'  when  SIDE = 'L' or 'l'  (  Left-hand side )
C
C     R := Q*U*P'  when  SIDE = 'R' or 'r'  ( Right-hand side ),
C
C  where  U and R  are  n by n  upper  triangular  matrices,   P  is  an
C  orthogonal matrix,  consisting of a given sequence of plane rotations
C  to be  applied  in  planes  k1 to k2,  and  Q  is  a  unitary  matrix
C  consisting of a sequence of plane rotations, applied in planes  k1 to
C  k2,  chosen to make  R  upper triangular.
C
C  When  SIDE = 'L' or 'l'  then  P  is  given  as a  sequence of  plane
C  rotation matrices
C
C     P = P( k2 - 1 )*...*P( k1 + 1 )*P( k1 ),
C
C  where  P( k ) is a plane rotation matrix for the  ( k, k + 1 ) plane.
C  In this case the matrix Q is given as
C
C     Q = Q( k2 - 1 )*...*Q( k1 + 1 )*Q( k1 ),
C
C  where  Q( k ) is a plane rotation matrix for the  ( k, k + 1 ) plane.
C
C  When  SIDE = 'R' or 'r'  then  P  is  given  as a  sequence of  plane
C  rotation matrices
C
C     P = P( k1 )*P( k1 + 1 )*...*P( k2 - 1 ),
C
C  where  P( k ) is a plane rotation matrix for the  ( k, k + 1 ) plane.
C  In this case the matrix Q is given as
C
C     Q = Q( k1 )*Q( k1 + 1 )*...*Q( k2 - 1 ),
C
C  where  Q( k ) is a plane rotation matrix for the  ( k, k + 1 ) plane.
C
C  The  upper  triangular  matrix  U  must  be  supplied  in the  n by n
C  leading upper triangular part of  A,  and this  is overwritten by the
C  upper triangular matrix  R.  The cosine  and  sine  that  define  the
C  plane rotation matrix  P( k )  must be supplied in  c( k ) and s( k )
C  respectively,  and  the two by two rotation part of  P( k ),  T( k ),
C  is assumed to be of the form
C
C     T( k ) = (  c( k )  s( k ) ).
C              ( -s( k )  c( k ) )
C
C  The cosine  and  sine that define  Q( k )  are overwritten on  c( k )
C  and  s( k )  respectively and the two by two rotation part of  Q( k )
C  will have the form of  T( k )  above.
C
C  If  n or k1  are less  than  unity, or  k1  is not  less than  k2, or
C  k2  is greater than  n  then an immediate return is effected.
C
C
C  Nag Fortran 77 O( n**2 ) basic linear algebra routine.
C
C  -- Written on 26-November-1987.
C     Sven Hammarling and Mick Pont, Nag Central Office.
C
C
C     .. Parameters ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
C     .. Local Scalars ..
      DOUBLE PRECISION   AIJ, CTEMP, FILL, STEMP, TEMP
      INTEGER            I, I1, J
C     .. External Subroutines ..
      EXTERNAL           F06BAF
C     .. Intrinsic Functions ..
      INTRINSIC          MIN
C     ..
C     .. Executable Statements ..
      IF( ( MIN( N, K1 ).LT.1 ).OR.( K2.LE.K1 ).OR.
     $   ( K2.GT.N ) )RETURN
      IF( ( SIDE.EQ.'L' ).OR.( SIDE.EQ.'l' ) )THEN
C
C        Apply the left-hand transformations,  column by column,  to the
C        triangular part of  U,  but not to  anywhere  that would  cause
C        fill.
C
         DO 20 J = K1 + 1, N
C
C           Apply  P( k1 ) ... P( j - 1 )  to column j.
C
            AIJ = A( K1, J )
            DO 10 I = K1, MIN( J - 1, K2 - 1 )
               A( I, J ) = S( I )*A( I + 1, J ) + C( I )*AIJ
               AIJ = C( I )*A( I + 1, J ) - S( I )*AIJ
   10       CONTINUE
            A( I, J ) = AIJ
   20    CONTINUE
C
C           Now apply each  left-hand tranformation  to form the fill-in
C           elements and apply a  right-hand transformation to eliminate
C           the fill-in element.
C
         DO 40 J = K1, K2 - 1
C
C           Apply  P( j )  to the jth diagonal element  and the  fill-in
C           position.
C
            FILL = -S( J )*A( J, J )
            A( J, J ) = C( J )*A( J, J )
C
C           Now  set up  the rotation  Q( j )  to eliminate the  fill-in
C           element,  and  apply  Q( j )  to  the  jth  and  ( j + 1 )th
C           columns.
C
            CALL F06BAF( A( J + 1, J + 1 ), FILL, CTEMP, STEMP )
            C( J ) = CTEMP
            S( J ) = -STEMP
            IF( ( CTEMP.NE.ONE ).OR.( STEMP.NE.ZERO ) )THEN
               STEMP = -STEMP
               DO 30 I = 1, J
                  TEMP = A( I, J + 1 )
                  A( I, J + 1 ) = CTEMP*TEMP - STEMP*A( I, J )
                  A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
   30          CONTINUE
            END IF
   40    CONTINUE
      ELSE IF( ( SIDE.EQ.'R' ).OR.( SIDE.EQ.'r' ) )THEN
C
C        We intermingle the  left and right hand transformations so that
C        at the kth step we form
C
C           A := Q( k )*A*P( k )'.
C
C        First  apply  the  transformations  in  columns  k2 back to k1.
C
         DO 60 J = K2 - 1, K1, -1
C
C           First apply  P( j ).
C
            IF( ( C( J ).NE.ONE ).OR.( S( J ).NE.ZERO ) )THEN
               CTEMP = C( J )
               STEMP = S( J )
               DO 50 I = 1, J
                  TEMP = A( I, J + 1 )
                  A( I, J + 1 ) = CTEMP*TEMP - STEMP*A( I, J )
                  A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
   50          CONTINUE
C
C              Next form the fill-in element  a( j + 1, j )  by applying
C              P( j ).
C
               FILL = S( J )*A( J + 1, J + 1 )
               A( J + 1, J + 1 ) = C( J )*A( J + 1, J + 1 )
C
C              Now set up the rotation  Q( j )  to eliminate the fill-in
C              element.
C
               CALL F06BAF( A( J, J ), FILL, C( J ), S( J ) )
            END IF
   60    CONTINUE
C
C        Finally  apply  Q( k2 - 1 ) ... Q( k1 )  to columns  n  back to
C        ( k1 + 1 ).
C
         DO 80 J = N, K1 + 1, -1
            I1 = MIN( K2, J )
            AIJ = A( I1, J )
            DO 70 I = I1 - 1, K1, -1
               TEMP = A( I, J )
               A( I + 1, J ) = C( I )*AIJ - S( I )*TEMP
               AIJ = S( I )*AIJ + C( I )*TEMP
   70       CONTINUE
            A( K1, J ) = AIJ
   80    CONTINUE
      END IF
      RETURN
C
C     End of F06QTF. ( SUTSQR )
C
      END
      SUBROUTINE F06QXF( SIDE, PIVOT, DIRECT, M, N, K1, K2, C, S, A,
     $                   LDA )
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     .. Scalar Arguments ..
      INTEGER            K1, K2, LDA, M, N
      CHARACTER*1        DIRECT, PIVOT, SIDE
C     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), C( * ), S( * )
C     ..
C
C  F06QXF  performs the transformation
C
C     A := P*A,   when   SIDE = 'L' or 'l'  (  Left-hand side )
C
C     A := A*P',  when   SIDE = 'R' or 'r'  ( Right-hand side )
C
C  where A is an m by n matrix and P is an orthogonal matrix, consisting
C  of a  sequence  of  plane  rotations,  applied  in  planes  k1 to k2,
C  determined by the parameters PIVOT and DIRECT as follows:
C
C     When  PIVOT  = 'V' or 'v'  ( Variable pivot )
C     and   DIRECT = 'F' or 'f'  ( Forward sequence ) then
C
C        P is given as a sequence of plane rotation matrices
C
C           P = P( k2 - 1 )*...*P( k1 + 1 )*P( k1 ),
C
C        where  P( k )  is a plane rotation matrix for the  ( k, k + 1 )
C        plane.
C
C     When  PIVOT  = 'V' or 'v'  ( Variable pivot )
C     and   DIRECT = 'B' or 'b'  ( Backward sequence ) then
C
C        P is given as a sequence of plane rotation matrices
C
C           P = P( k1 )*P( k1 + 1 )*...*P( k2 - 1 ),
C
C        where  P( k )  is a plane rotation matrix for the  ( k, k + 1 )
C        plane.
C
C     When  PIVOT  = 'T' or 't'  ( Top pivot )
C     and   DIRECT = 'F' or 'f'  ( Forward sequence ) then
C
C        P is given as a sequence of plane rotation matrices
C
C           P = P( k2 - 1 )*P( k2 - 2 )*...*P( k1 ),
C
C        where  P( k )  is a plane rotation matrix for the ( k1, k + 1 )
C        plane.
C
C     When  PIVOT  = 'T' or 't'  ( Top pivot )
C     and   DIRECT = 'B' or 'b'  ( Backward sequence ) then
C
C        P is given as a sequence of plane rotation matrices
C
C           P = P( k1 )*P( k1 + 1 )*...*P( k2 - 1 ),
C
C        where  P( k )  is a plane rotation matrix for the ( k1, k + 1 )
C        plane.
C
C     When  PIVOT  = 'B' or 'b'  ( Bottom pivot )
C     and   DIRECT = 'F' or 'f'  ( Forward sequence ) then
C
C        P is given as a sequence of plane rotation matrices
C
C           P = P( k2 - 1 )*P( k2 - 2 )*...*P( k1 ),
C
C        where  P( k )  is a  plane rotation  matrix  for the  ( k, k2 )
C        plane.
C
C     When  PIVOT  = 'B' or 'b'  ( Bottom pivot )
C     and   DIRECT = 'B' or 'b'  ( Backward sequence ) then
C
C        P is given as a sequence of plane rotation matrices
C
C           P = P( k1 )*P( k1 + 1 )*...*P( k2 - 1 ),
C
C        where  P( k )  is a  plane rotation  matrix  for the  ( k, k2 )
C        plane.
C
C  c( k ) and s( k )  must contain the  cosine and sine  that define the
C  matrix  P( k ).  The  two by two  plane rotation  part of the  matrix
C  P( k ), R( k ), is assumed to be of the form
C
C     R( k ) = (  c( k )  s( k ) ).
C              ( -s( k )  c( k ) )
C
C  If m, n or k1 are less than unity,  or k2 is not greater than k1,  or
C  SIDE = 'L' or 'l'  and  k2  is greater than  m, or  SIDE = 'R' or 'r'
C  and  k2  is greater than  n,  then an  immediate return  is effected.
C
C
C  Nag Fortran 77 O( n**2 ) basic linear algebra routine.
C
C  -- Written on 20-November-1986.
C     Sven Hammarling and Mick Pont, Nag Central Office.
C
C
C     .. Parameters ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
C     .. Local Scalars ..
      DOUBLE PRECISION   AIJ, CTEMP, STEMP, TEMP
      INTEGER            I, J
      LOGICAL            LEFT, RIGHT
C     .. Intrinsic Functions ..
      INTRINSIC          MIN
C     ..
C     .. Executable Statements ..
      LEFT = ( SIDE.EQ.'L' ).OR.( SIDE.EQ.'l' )
      RIGHT = ( SIDE.EQ.'R' ).OR.( SIDE.EQ.'r' )
      IF( ( MIN( M, N, K1 ).LT.1 ).OR.( K2.LE.K1 ).OR.
     $    ( ( LEFT ).AND.( K2.GT.M ) ).OR.
     $    ( ( RIGHT ).AND.( K2.GT.N ) ) )RETURN
      IF( LEFT )THEN
         IF( ( PIVOT.EQ.'V' ).OR.( PIVOT.EQ.'v' ) )THEN
            IF( ( DIRECT.EQ.'F' ).OR.( DIRECT.EQ.'f' ) )THEN
               DO 20 J = 1, N
                  AIJ = A( K1, J )
                  DO 10 I = K1, K2 - 1
                     TEMP = A( I + 1, J )
                     A( I, J ) = S( I )*TEMP + C( I )*AIJ
                     AIJ = C( I )*TEMP - S( I )*AIJ
   10             CONTINUE
                  A( K2, J ) = AIJ
   20          CONTINUE
            ELSE IF( ( DIRECT.EQ.'B' ).OR.( DIRECT.EQ.'b' ) )THEN
               DO 40 J = 1, N
                  AIJ = A( K2, J )
                  DO 30 I = K2 - 1, K1, -1
                     TEMP = A( I, J )
                     A( I + 1, J ) = C( I )*AIJ - S( I )*TEMP
                     AIJ = S( I )*AIJ + C( I )*TEMP
   30             CONTINUE
                  A( K1, J ) = AIJ
   40          CONTINUE
            END IF
         ELSE IF( ( PIVOT.EQ.'T' ).OR.( PIVOT.EQ.'t' ) )THEN
            IF( ( DIRECT.EQ.'F' ).OR.( DIRECT.EQ.'f' ) )THEN
               DO 60 J = 1, N
                  TEMP = A( K1, J )
                  DO 50 I = K1, K2 - 1
                     AIJ = A( I + 1, J )
                     A( I + 1, J ) = C( I )*AIJ - S( I )*TEMP
                     TEMP = S( I )*AIJ + C( I )*TEMP
   50             CONTINUE
                  A( K1, J ) = TEMP
   60          CONTINUE
            ELSE IF( ( DIRECT.EQ.'B' ).OR.( DIRECT.EQ.'b' ) )THEN
               DO 80 J = 1, N
                  TEMP = A( K1, J )
                  DO 70 I = K2 - 1, K1, -1
                     AIJ = A( I + 1, J )
                     A( I + 1, J ) = C( I )*AIJ - S( I )*TEMP
                     TEMP = S( I )*AIJ + C( I )*TEMP
   70             CONTINUE
                  A( K1, J ) = TEMP
   80          CONTINUE
            END IF
         ELSE IF( ( PIVOT.EQ.'B' ).OR.( PIVOT.EQ.'b' ) )THEN
            IF( ( DIRECT.EQ.'F' ).OR.( DIRECT.EQ.'f' ) )THEN
               DO 100 J = 1, N
                  TEMP = A( K2, J )
                  DO 90 I = K1, K2 - 1
                     AIJ = A( I, J )
                     A( I, J ) = S( I )*TEMP + C( I )*AIJ
                     TEMP = C( I )*TEMP - S( I )*AIJ
   90             CONTINUE
                  A( K2, J ) = TEMP
  100          CONTINUE
            ELSE IF( ( DIRECT.EQ.'B' ).OR.( DIRECT.EQ.'b' ) )THEN
               DO 120 J = 1, N
                  TEMP = A( K2, J )
                  DO 110 I = K2 - 1, K1, -1
                     AIJ = A( I, J )
                     A( I, J ) = S( I )*TEMP + C( I )*AIJ
                     TEMP = C( I )*TEMP - S( I )*AIJ
  110             CONTINUE
                  A( K2, J ) = TEMP
  120          CONTINUE
            END IF
         END IF
      ELSE IF( RIGHT )THEN
         IF( ( PIVOT.EQ.'V' ).OR.( PIVOT.EQ.'v' ) )THEN
            IF( ( DIRECT.EQ.'F' ).OR.( DIRECT.EQ.'f' ) )THEN
               DO 140 J = K1, K2 - 1
                  IF( ( C( J ).NE.ONE ).OR.( S( J ).NE.ZERO ) )THEN
                     CTEMP = C( J )
                     STEMP = S( J )
                     DO 130 I = 1, M
                        TEMP = A( I, J + 1 )
                        A( I, J + 1 ) = CTEMP*TEMP - STEMP*A( I, J )
                        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
  130                CONTINUE
                  END IF
  140          CONTINUE
            ELSE IF( ( DIRECT.EQ.'B' ).OR.( DIRECT.EQ.'b' ) )THEN
               DO 160 J = K2 - 1, K1, -1
                  IF( ( C( J ).NE.ONE ).OR.( S( J ).NE.ZERO ) )THEN
                     CTEMP = C( J )
                     STEMP = S( J )
                     DO 150 I = M, 1, -1
                        TEMP = A( I, J + 1 )
                        A( I, J + 1 ) = CTEMP*TEMP - STEMP*A( I, J )
                        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
  150                CONTINUE
                  END IF
  160          CONTINUE
            END IF
         ELSE IF( ( PIVOT.EQ.'T' ).OR.( PIVOT.EQ.'t' ) )THEN
            IF( ( DIRECT.EQ.'F' ).OR.( DIRECT.EQ.'f' ) )THEN
               DO 180 J = K1 + 1, K2
                  CTEMP = C( J - 1 )
                  STEMP = S( J - 1 )
                  IF( ( CTEMP.NE.ONE ).OR.( STEMP.NE.ZERO ) )THEN
                     DO 170 I = 1, M
                        TEMP = A( I, J )
                        A( I, J ) = CTEMP*TEMP - STEMP*A( I, K1 )
                        A( I, K1 ) = STEMP*TEMP + CTEMP*A( I, K1 )
  170                CONTINUE
                  END IF
  180          CONTINUE
            ELSE IF( ( DIRECT.EQ.'B' ).OR.( DIRECT.EQ.'b' ) )THEN
               DO 200 J = K2, K1 + 1, -1
                  CTEMP = C( J - 1 )
                  STEMP = S( J - 1 )
                  IF( ( CTEMP.NE.ONE ).OR.( STEMP.NE.ZERO ) )THEN
                     DO 190 I = M, 1, -1
                        TEMP = A( I, J )
                        A( I, J ) = CTEMP*TEMP - STEMP*A( I, K1 )
                        A( I, K1 ) = STEMP*TEMP + CTEMP*A( I, K1 )
  190                CONTINUE
                  END IF
  200          CONTINUE
            END IF
         ELSE IF( ( PIVOT.EQ.'B' ).OR.( PIVOT.EQ.'b' ) )THEN
            IF( ( DIRECT.EQ.'F' ).OR.( DIRECT.EQ.'f' ) )THEN
               DO 220 J = K1, K2 - 1
                  IF( ( C( J ).NE.ONE ).OR.( S( J ).NE.ZERO ) )THEN
                     CTEMP = C( J )
                     STEMP = S( J )
                     DO 210 I = 1, M
                        TEMP = A( I, J )
                        A( I, J ) = STEMP*A( I, K2 ) + CTEMP*TEMP
                        A( I, K2 ) = CTEMP*A( I, K2 ) - STEMP*TEMP
  210                CONTINUE
                  END IF
  220          CONTINUE
            ELSE IF( ( DIRECT.EQ.'B' ).OR.( DIRECT.EQ.'b' ) )THEN
               DO 240 J = K2 - 1, K1, -1
                  IF( ( C( J ).NE.ONE ).OR.( S( J ).NE.ZERO ) )THEN
                     CTEMP = C( J )
                     STEMP = S( J )
                     DO 230 I = M, 1, -1
                        TEMP = A( I, J )
                        A( I, J ) = STEMP*A( I, K2 ) + CTEMP*TEMP
                        A( I, K2 ) = CTEMP*A( I, K2 ) - STEMP*TEMP
  230                CONTINUE
                  END IF
  240          CONTINUE
            END IF
         END IF
      END IF
C
      RETURN
C
C     End of F06QXF. ( SGESRC )
C
      END
      DOUBLE PRECISION FUNCTION F06RAF(NORM,M,N,A,LDA,WORK)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C     REAL                 DLANGE
C     ENTRY                DLANGE(NORM,M,N,A,LDA,WORK)
C
C  Purpose
C  =======
C
C  DLANGE  returns the value of the one norm,  or the Frobenius norm, or
C  the  infinity norm,  or the  element of  largest absolute value  of a
C  real matrix A.
C
C  Description
C  ===========
C
C  DLANGE returns the value
C
C     DLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
C              (
C              ( norm1(A),         NORM = '1', 'O' or 'o'
C              (
C              ( normI(A),         NORM = 'I' or 'i'
C              (
C              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
C
C  where  norm1  denotes the  one norm of a matrix (maximum column sum),
C  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
C  normF  denotes the  Frobenius norm of a matrix (square root of sum of
C  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.
C
C  Arguments
C  =========
C
C  NORM    (input) CHARACTER*1
C          Specifies the value to be returned in DLANGE as described
C          above.
C
C  M       (input) INTEGER
C          The number of rows of the matrix A.  M >= 0.  When M = 0,
C          DLANGE is set to zero.
C
C  N       (input) INTEGER
C          The number of columns of the matrix A.  N >= 0.  When N = 0,
C          DLANGE is set to zero.
C
C  A       (input) REAL array, dimension (LDA,N)
C          The m by n matrix A.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(M,1).
C
C  WORK    (workspace) REAL array, dimension (LWORK),
C          where LWORK >= M when NORM = 'I'; otherwise, WORK is not
C          referenced.
C
C
C  -- LAPACK auxiliary routine (adapted for NAG Library)
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C
C     .. Parameters ..
      DOUBLE PRECISION                 ONE, ZERO
      PARAMETER                        (ONE=1.0D+0,ZERO=0.0D+0)
C     .. Scalar Arguments ..
      INTEGER                          LDA, M, N
      CHARACTER                        NORM
C     .. Array Arguments ..
      DOUBLE PRECISION                 A(LDA,*), WORK(*)
C     .. Local Scalars ..
      DOUBLE PRECISION                 SCALE, SUM, VALUE
      INTEGER                          I, J
C     .. External Subroutines ..
      EXTERNAL                         F06FJF
C     .. Intrinsic Functions ..
      INTRINSIC                        ABS, MAX, MIN, SQRT
C     .. Executable Statements ..
C
      IF (MIN(M,N).EQ.0) THEN
         VALUE = ZERO
      ELSE IF ((NORM.EQ.'M' .OR. NORM.EQ.'m')) THEN
C
C        Find max(abs(A(i,j))).
C
         VALUE = ZERO
         DO 40 J = 1, N
            DO 20 I = 1, M
               VALUE = MAX(VALUE,ABS(A(I,J)))
   20       CONTINUE
   40    CONTINUE
      ELSE IF (((NORM.EQ.'O' .OR. NORM.EQ.'o')) .OR. (NORM.EQ.'1')) THEN
C
C        Find norm1(A).
C
         VALUE = ZERO
         DO 80 J = 1, N
            SUM = ZERO
            DO 60 I = 1, M
               SUM = SUM + ABS(A(I,J))
   60       CONTINUE
            VALUE = MAX(VALUE,SUM)
   80    CONTINUE
      ELSE IF ((NORM.EQ.'I' .OR. NORM.EQ.'i')) THEN
C
C        Find normI(A).
C
         DO 100 I = 1, M
            WORK(I) = ZERO
  100    CONTINUE
         DO 140 J = 1, N
            DO 120 I = 1, M
               WORK(I) = WORK(I) + ABS(A(I,J))
  120       CONTINUE
  140    CONTINUE
         VALUE = ZERO
         DO 160 I = 1, M
            VALUE = MAX(VALUE,WORK(I))
  160    CONTINUE
      ELSE IF (((NORM.EQ.'F' .OR. NORM.EQ.'f'))
     *         .OR. ((NORM.EQ.'E' .OR. NORM.EQ.'e'))) THEN
C
C        Find normF(A).
C
         SCALE = ZERO
         SUM = ONE
         DO 180 J = 1, N
            CALL F06FJF(M,A(1,J),1,SCALE,SUM)
  180    CONTINUE
         VALUE = SCALE*SQRT(SUM)
      END IF
C
      F06RAF = VALUE
      RETURN
C
C     End of F06RAF (DLANGE)
C
      END
      SUBROUTINE F07ADF(M,N,A,LDA,IPIV,INFO)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C     MARK 16 REVISED. IER-1009 (JUN 1993).
C     .. Entry Points ..
      ENTRY             DGETRF(M,N,A,LDA,IPIV,INFO)
C
C  Purpose
C  =======
C
C  DGETRF computes an LU factorization of a general m-by-n matrix A
C  using partial pivoting with row interchanges.
C
C  The factorization has the form
C     A = P * L * U
C  where P is a permutation matrix, L is lower triangular with unit
C  diagonal elements (lower trapezoidal if m > n), and U is upper
C  triangular (upper trapezoidal if m < n).
C
C  This is the Level 3 BLAS version of the right-looking algorithm.
C
C  Arguments
C  =========
C
C  M       (input) INTEGER
C          The number of rows of the matrix A.  M >= 0.
C
C  N       (input) INTEGER
C          The number of columns of the matrix A.  N >= 0.
C
C  A       (input/output) REAL array, dimension (LDA,N)
C          On entry, the m by n matrix to be factored.
C          On exit, the factors L and U from the factorization
C          A = P*L*U; the unit diagonal elements of L are not stored.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,M).
C
C  IPIV    (output) INTEGER array, dimension (min(M,N))
C          The pivot indices; for 1 <= i <= min(M,N), row i of the
C          matrix was interchanged with row IPIV(i).
C
C  INFO    (output) INTEGER
C          = 0: successful exit
C          < 0: if INFO = -k, the k-th argument had an illegal value
C          > 0: if INFO = k, U(k,k) is exactly zero. The factorization
C               has been completed, but the factor U is exactly
C               singular, and division by zero will occur if it is used
C               to solve a system of equations.
C
C  -- LAPACK routine (adapted for NAG Library)
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C
C  =====================================================================
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE
      PARAMETER         (ONE=1.0D+0)
C     .. Scalar Arguments ..
      INTEGER           INFO, LDA, M, N
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*)
      INTEGER           IPIV(*)
C     .. Local Scalars ..
      INTEGER           I, IINFO, J, JB, NB
C     .. External Subroutines ..
      EXTERNAL          DGEMM, DTRSM, F06AAZ, F07ADY, F07ADZ, F07ZAZ
C     .. Intrinsic Functions ..
      INTRINSIC         MAX, MIN
C     .. Executable Statements ..
C
C     Test the input parameters.
C
      INFO = 0
      IF (M.LT.0) THEN
         INFO = -1
      ELSE IF (N.LT.0) THEN
         INFO = -2
      ELSE IF (LDA.LT.MAX(1,M)) THEN
         INFO = -4
      END IF
      IF (INFO.NE.0) THEN
         CALL F06AAZ('F07ADF/DGETRF',-INFO)
         RETURN
      END IF
C
C     Quick return if possible
C
      IF (M.EQ.0 .OR. N.EQ.0) RETURN
C
C     Determine the block size for this environment.
C
      CALL F07ZAZ(1,'F07ADF',NB,0)
      IF (NB.LE.1) THEN
C
C        Use unblocked code.
C
         CALL F07ADZ(M,N,A,LDA,IPIV,INFO)
      ELSE
C
C        Use blocked code.
C
         DO 40 J = 1, MIN(M,N), NB
            JB = MIN(MIN(M,N)-J+1,NB)
C
C           Factor diagonal and subdiagonal blocks and test for exact
C           singularity.
C
            CALL F07ADZ(M-J+1,JB,A(J,J),LDA,IPIV(J),IINFO)
C
C           Adjust INFO and the pivot indices.
C
            IF (INFO.EQ.0 .AND. IINFO.GT.0) INFO = IINFO + J - 1
            DO 20 I = J, MIN(M,J+JB-1)
               IPIV(I) = J - 1 + IPIV(I)
   20       CONTINUE
C
C           Apply interchanges to columns 1:J-1.
C
            CALL F07ADY(J-1,A,LDA,J,J+JB-1,IPIV,1)
C
            IF (J+JB.LE.N) THEN
C
C              Apply interchanges to columns J+JB:N.
C
               CALL F07ADY(N-J-JB+1,A(1,J+JB),LDA,J,J+JB-1,IPIV,1)
C
C              Compute block row of U.
C
               CALL DTRSM('Left','Lower','No transpose','Unit',JB,
     *                    N-J-JB+1,ONE,A(J,J),LDA,A(J,J+JB),LDA)
               IF (J+JB.LE.M) THEN
C
C                 Update trailing submatrix.
C
                  CALL DGEMM('No transpose','No transpose',M-J-JB+1,
     *                       N-J-JB+1,JB,-ONE,A(J+JB,J),LDA,A(J,J+JB),
     *                       LDA,ONE,A(J+JB,J+JB),LDA)
               END IF
            END IF
   40    CONTINUE
      END IF
      RETURN
C
C     End of F07ADF (DGETRF)
C
      END
      SUBROUTINE F07ADY(N,A,LDA,K1,K2,IPIV,INCX)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C     ENTRY             DLASWP(N,A,LDA,K1,K2,IPIV,INCX)
C
C  Purpose
C  =======
C
C  DLASWP performs a series of row interchanges on the matrix A.
C  One row interchange is initiated for each of rows K1 through K2 of A.
C
C  Arguments
C  =========
C
C  N       (input) INTEGER
C          The number of columns of the matrix A.
C
C  A       (input/output) REAL array, dimension (LDA,N)
C          On entry, the matrix of column dimension N to which the row
C          interchanges will be applied.
C          On exit, the permuted matrix.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.
C
C  K1      (input) INTEGER
C          The first element of IPIV for which a row interchange will
C          be done.
C
C  K2      (input) INTEGER
C          The last element of IPIV for which a row interchange will
C          be done.
C
C  IPIV    (input) INTEGER array, dimension( M*abs(INCX) )
C          The vector of pivot indices.  Only the elements in positions
C          K1 through K2 of IPIV are accessed.
C          IPIV(K) = L implies rows K and L are to be interchanged.
C
C  INCX    (input) INTEGER
C          The increment between succesive values of IPIV.  If IPIV
C          is negative, the pivots are applied in reverse order.
C
C
C  -- LAPACK auxiliary routine (adapted for NAG Library)
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C
C     .. Scalar Arguments ..
      INTEGER           INCX, K1, K2, LDA, N
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*)
      INTEGER           IPIV(*)
C     .. Local Scalars ..
      INTEGER           I, IP, IX
C     .. External Subroutines ..
      EXTERNAL          DSWAP
C     .. Executable Statements ..
C
C     Interchange row I with row IPIV(I) for each of rows K1 through K2.
C
      IF (INCX.EQ.0) RETURN
      IF (INCX.GT.0) THEN
         IX = K1
      ELSE
         IX = 1 + (1-K2)*INCX
      END IF
      IF (INCX.EQ.1) THEN
         DO 20 I = K1, K2
            IP = IPIV(I)
            IF (IP.NE.I) CALL DSWAP(N,A(I,1),LDA,A(IP,1),LDA)
   20    CONTINUE
      ELSE IF (INCX.GT.1) THEN
         DO 40 I = K1, K2
            IP = IPIV(IX)
            IF (IP.NE.I) CALL DSWAP(N,A(I,1),LDA,A(IP,1),LDA)
            IX = IX + INCX
   40    CONTINUE
      ELSE IF (INCX.LT.0) THEN
         DO 60 I = K2, K1, -1
            IP = IPIV(IX)
            IF (IP.NE.I) CALL DSWAP(N,A(I,1),LDA,A(IP,1),LDA)
            IX = IX + INCX
   60    CONTINUE
      END IF
C
      RETURN
C
C     End of F07ADY (DLASWP)
C
      END
      SUBROUTINE F07ADZ(M,N,A,LDA,IPIV,INFO)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C     MARK 16 REVISED. IER-1012 (JUN 1993).
C     ENTRY             DGETF2(M,N,A,LDA,IPIV,INFO)
C
C  Purpose
C  =======
C
C  DGETF2 computes an LU factorization of a general m-by-n matrix A
C  using partial pivoting with row interchanges.
C
C  The factorization has the form
C     A = P * L * U
C  where P is a permutation matrix, L is lower triangular with unit
C  diagonal elements (lower trapezoidal if m > n), and U is upper
C  triangular (upper trapezoidal if m < n).
C
C  This is the Level 2 BLAS version of the right-looking algorithm.
C
C  Arguments
C  =========
C
C  M       (input) INTEGER
C          The number of rows of the matrix A.  M >= 0.
C
C  N       (input) INTEGER
C          The number of columns of the matrix A.  N >= 0.
C
C  A       (input/output) REAL array, dimension (LDA,N)
C          On entry, the m by n matrix to be factored.
C          On exit, the factors L and U from the factorization
C          A = P*L*U; the unit diagonal elements of L are not stored.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,M).
C
C  IPIV    (output) INTEGER array, dimension (min(M,N))
C          The pivot indices; for 1 <= i <= min(M,N), row i of the
C          matrix was interchanged with row IPIV(i).
C
C  INFO    (output) INTEGER
C          = 0: successful exit
C          < 0: if INFO = -k, the k-th argument had an illegal value
C          > 0: if INFO = k, U(k,k) is exactly zero. The factorization
C               has been completed, but the factor U is exactly
C               singular, and division by zero will occur if it is used
C               to solve a system of equations.
C
C  -- LAPACK routine (adapted for NAG Library)
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C
C  =====================================================================
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE, ZERO
      PARAMETER         (ONE=1.0D+0,ZERO=0.0D+0)
C     .. Scalar Arguments ..
      INTEGER           INFO, LDA, M, N
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*)
      INTEGER           IPIV(*)
C     .. Local Scalars ..
      INTEGER           J, JP
C     .. External Functions ..
      INTEGER           IDAMAX
      EXTERNAL          IDAMAX
C     .. External Subroutines ..
      EXTERNAL          DGER, DSCAL, DSWAP, F06AAZ
C     .. Intrinsic Functions ..
      INTRINSIC         MAX, MIN
C     .. Executable Statements ..
C
C     Test the input parameters.
C
      INFO = 0
      IF (M.LT.0) THEN
         INFO = -1
      ELSE IF (N.LT.0) THEN
         INFO = -2
      ELSE IF (LDA.LT.MAX(1,M)) THEN
         INFO = -4
      END IF
      IF (INFO.NE.0) THEN
         CALL F06AAZ('F07ADZ/DGETF2',-INFO)
         RETURN
      END IF
C
C     Quick return if possible
C
      IF (M.EQ.0 .OR. N.EQ.0) RETURN
C
      DO 20 J = 1, MIN(M,N)
C
C        Find pivot and test for singularity.
C
         JP = J - 1 + IDAMAX(M-J+1,A(J,J),1)
         IPIV(J) = JP
         IF (A(JP,J).NE.ZERO) THEN
C
C           Apply interchange to columns 1:N.
C
            IF (JP.NE.J) CALL DSWAP(N,A(J,1),LDA,A(JP,1),LDA)
C
C           Compute elements J+1:M of J-th column.
C
            IF (J.LT.M) CALL DSCAL(M-J,ONE/A(J,J),A(J+1,J),1)
C
         ELSE IF (INFO.EQ.0) THEN
C
C           If A( JP, J ) is zero, set INFO to indicate that a zero
C           pivot has been found.
C
            INFO = J
         END IF
C
         IF (J.LT.MIN(M,N)) THEN
C
C           Update trailing submatrix.
C
            CALL DGER(M-J,N-J,-ONE,A(J+1,J),1,A(J,J+1),LDA,A(J+1,J+1),
     *                LDA)
         END IF
   20 CONTINUE
      RETURN
C
C     End of F07ADZ (DGETF2)
C
      END
      SUBROUTINE F07AEF(TRANS,N,NRHS,A,LDA,IPIV,B,LDB,INFO)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C     MARK 16 REVISED. IER-1013 (JUN 1993).
C     .. Entry Points ..
      ENTRY             DGETRS(TRANS,N,NRHS,A,LDA,IPIV,B,LDB,INFO)
C
C  Purpose
C  =======
C
C  DGETRS solves a system of linear equations
C     A * X = B  or  A' * X = B
C  with a general n by n matrix A using the LU factorization computed
C  by F07ADF.
C
C  Arguments
C  =========
C
C  TRANS   (input) CHARACTER*1
C          Specifies the form of the system of equations.
C          = 'N':  A * X = B  (No transpose)
C          = 'T':  A'* X = B  (Transpose)
C          = 'C':  A'* X = B  (Conjugate transpose = Transpose)
C
C  N       (input) INTEGER
C          The order of the matrix A.  N >= 0.
C
C  NRHS    (input) INTEGER
C          The number of right hand sides, i.e., the number of columns
C          of the matrix B.  NRHS >= 0.
C
C  A       (input) REAL array, dimension (LDA,N)
C          The factors L and U from the factorization A = P*L*U
C          as computed by F07ADF.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,N).
C
C  IPIV    (input) INTEGER array, dimension (N)
C          The pivot indices from F07ADF; for 1<=i<=N, row i of the
C          matrix was interchanged with row IPIV(i).
C
C  B       (input/output) REAL array, dimension (LDB,NRHS)
C          On entry, the right hand side vectors B for the system of
C          linear equations.
C          On exit, the solution vectors, X.
C
C  LDB     (input) INTEGER
C          The leading dimension of the array B.  LDB >= max(1,N).
C
C  INFO    (output) INTEGER
C          = 0:  successful exit
C          < 0: if INFO = -k, the k-th argument had an illegal value
C
C  -- LAPACK routine (adapted for NAG Library)
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C
C  =====================================================================
C
C     .. Parameters ..
      DOUBLE PRECISION  ONE
      PARAMETER         (ONE=1.0D+0)
C     .. Scalar Arguments ..
      INTEGER           INFO, LDA, LDB, N, NRHS
      CHARACTER         TRANS
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), B(LDB,*)
      INTEGER           IPIV(*)
C     .. Local Scalars ..
      LOGICAL           NOTRAN
C     .. External Subroutines ..
      EXTERNAL          F06AAZ, F07ADY, DTRSM, DTRSV
C     .. Intrinsic Functions ..
      INTRINSIC         MAX
C     .. Executable Statements ..
C
C     Test the input parameters.
C
      INFO = 0
      NOTRAN = (TRANS.EQ.'N' .OR. TRANS.EQ.'n')
      IF ( .NOT. NOTRAN .AND. .NOT. (TRANS.EQ.'T' .OR. TRANS.EQ.'t')
     *     .AND. .NOT. (TRANS.EQ.'C' .OR. TRANS.EQ.'c')) THEN
         INFO = -1
      ELSE IF (N.LT.0) THEN
         INFO = -2
      ELSE IF (NRHS.LT.0) THEN
         INFO = -3
      ELSE IF (LDA.LT.MAX(1,N)) THEN
         INFO = -5
      ELSE IF (LDB.LT.MAX(1,N)) THEN
         INFO = -8
      END IF
      IF (INFO.NE.0) THEN
         CALL F06AAZ('F07AEF/DGETRS',-INFO)
         RETURN
      END IF
C
C     Quick return if possible
C
      IF (N.EQ.0 .OR. NRHS.EQ.0) RETURN
C
      IF (NOTRAN) THEN
C
C        Solve A * X = B.
C
C        Apply row interchanges to the right hand sides.
C
         CALL F07ADY(NRHS,B,LDB,1,N,IPIV,1)
C
C        Solve L*Y = B, overwriting B with Y, and then solve U*X = Y,
C        overwriting Y with X.
C
         IF (NRHS.EQ.1) THEN
            CALL DTRSV('Lower','No transpose','Unit',N,A,LDA,B,1)
            CALL DTRSV('Upper','No transpose','Non-unit',N,A,LDA,B,1)
         ELSE
            CALL DTRSM('Left','Lower','No transpose','Unit',N,NRHS,ONE,
     *                 A,LDA,B,LDB)
            CALL DTRSM('Left','Upper','No transpose','Non-unit',N,NRHS,
     *                 ONE,A,LDA,B,LDB)
         END IF
      ELSE
C
C        Solve A' * X = B.
C
C        Solve U'*Y = B, overwriting B with Y, and then solve L'*X = Y,
C        overwriting Y with X.
C
         IF (NRHS.EQ.1) THEN
            CALL DTRSV('Upper','Transpose','Non-unit',N,A,LDA,B,1)
            CALL DTRSV('Lower','Transpose','Unit',N,A,LDA,B,1)
         ELSE
            CALL DTRSM('Left','Upper','Transpose','Non-unit',N,NRHS,ONE,
     *                 A,LDA,B,LDB)
            CALL DTRSM('Left','Lower','Transpose','Unit',N,NRHS,ONE,A,
     *                 LDA,B,LDB)
         END IF
C
C        Apply row interchanges to the solution vectors.
C
         CALL F07ADY(NRHS,B,LDB,1,N,IPIV,-1)
      END IF
C
      RETURN
C
C     End of F07AEF (DGETRS)
C
      END
      SUBROUTINE F07AJF(N,A,LDA,IPIV,WORK,LWORK,INFO)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C     .. Entry Points ..
      ENTRY             DGETRI(N,A,LDA,IPIV,WORK,LWORK,INFO)
C
C  Purpose
C  =======
C
C  DGETRI computes the inverse of a matrix using the LU factorization
C  computed by F07ADF.
C
C  This method inverts U and then computes inv(A) by solving the system
C  inv(A)*L = inv(U) for inv(A).
C
C  Arguments
C  =========
C
C  N       (input) INTEGER
C          The order of the matrix A.  N >= 0.
C
C  A       (input/output) REAL array, dimension (LDA,N)
C          On entry, the factors L and U from the factorization
C          A = P*L*U as computed by F07ADF.
C          On exit, if INFO = 0, the inverse of the original matrix A.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,N).
C
C  IPIV    (input) INTEGER array, dimension (N)
C          The pivot indices from F07ADF; for 1<=i<=N, row i of the
C          matrix was interchanged with row IPIV(i).
C
C  WORK    (workspace) REAL array, dimension (LWORK)
C          If INFO returns 0, then WORK(1) returns the minimum
C          value of LWORK required for optimal performance.
C
C  LWORK   (input) INTEGER
C          The dimension of the array WORK.  LWORK >= max(N,1).
C          For optimal performance LWORK should be at least N*NB,
C          where NB is the optimal blocksize returned by F07ZAZ.
C
C  INFO    (output) INTEGER
C          = 0:  successful exit
C          < 0: if INFO = -k, the k-th argument had an illegal value
C          > 0: if INFO = k, U(k,k) is exactly zero; the matrix is
C               singular and its inverse could not be computed.
C
C  -- LAPACK routine (adapted for NAG Library)
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C
C  =====================================================================
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO, ONE
      PARAMETER         (ZERO=0.0D+0,ONE=1.0D+0)
C     .. Scalar Arguments ..
      INTEGER           INFO, LDA, LWORK, N
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*), WORK(LWORK)
      INTEGER           IPIV(*)
C     .. Local Scalars ..
      INTEGER           I, IWS, J, JB, JJ, JP, LDWORK, NB, NBMIN, NN
C     .. External Subroutines ..
      EXTERNAL          F06AAZ, F07TJF, F07ZAZ, DGEMM, DGEMV, DSWAP,
     *                  DTRSM
C     .. Intrinsic Functions ..
      INTRINSIC         MAX, MIN
C     .. Executable Statements ..
C
C     Test the input parameters.
C
      INFO = 0
      WORK(1) = MAX(N,1)
      IF (N.LT.0) THEN
         INFO = -1
      ELSE IF (LDA.LT.MAX(1,N)) THEN
         INFO = -3
      ELSE IF (LWORK.LT.N) THEN
         INFO = -6
      END IF
      IF (INFO.NE.0) THEN
         CALL F06AAZ('F07AJF/DGETRI',-INFO)
         RETURN
      END IF
C
C     Quick return if possible
C
      IF (N.EQ.0) THEN
         WORK(1) = 1
         RETURN
      END IF
C
C     Form inv(U).  If INFO > 0 from F07TJF, then U is singular,
C     and the inverse is not computed.
C
      CALL F07TJF('Upper','Non-unit',N,A,LDA,INFO)
      IF (INFO.GT.0) RETURN
C
C     Determine the block size for this environment.
C
      CALL F07ZAZ(1,'F07AJF',NB,0)
      IF (NB.LE.1) NB = N
C
      IF (NB.LT.N) THEN
         LDWORK = N
C
C        Determine if workspace is large enough for blocked code
C
         IWS = N*NB
         IF (LWORK.LT.IWS) THEN
C
C           Not enough workspace has been supplied to use the optimal
C           value of NB: determine the minimum value of NB, and reduce
C           NB or force use of unblocked code
C
            CALL F07ZAZ(2,'F07AJF',NBMIN,0)
            NBMIN = MAX(2,NBMIN)
C
            IF (LWORK.GE.N*NBMIN) THEN
               NB = LWORK/N
            ELSE
               NB = N
            END IF
         END IF
      ELSE
         IWS = N
      END IF
C
C     Solve the equation inv(A)*L = inv(U) for inv(A).
C
      IF (NB.GE.N) THEN
C
C        Use unblocked code.
C
         DO 40 J = N, 1, -1
C
C           Copy current column of L to WORK and replace with zeros.
C
            DO 20 I = J + 1, N
               WORK(I) = A(I,J)
               A(I,J) = ZERO
   20       CONTINUE
C
C           Compute current column of inv(A).
C
            IF (J.LT.N) CALL DGEMV('No transpose',N,N-J,-ONE,A(1,J+1),
     *                             LDA,WORK(J+1),1,ONE,A(1,J),1)
   40    CONTINUE
      ELSE
C
C        Use blocked code.
C
         NN = ((N-1)/NB)*NB + 1
         DO 100 J = NN, 1, -NB
            JB = MIN(NB,N-J+1)
C
C           Copy current block column of L to WORK and replace with
C           zeros.
C
            DO 80 JJ = J, J + JB - 1
               DO 60 I = JJ + 1, N
                  WORK(I+(JJ-J)*LDWORK) = A(I,JJ)
                  A(I,JJ) = ZERO
   60          CONTINUE
   80       CONTINUE
C
C           Compute current block column of inv(A).
C
            IF (J+JB.LE.N) CALL DGEMM('No transpose','No transpose',N,
     *                                JB,N-J-JB+1,-ONE,A(1,J+JB),LDA,
     *                                WORK(J+JB),LDWORK,ONE,A(1,J),LDA)
            CALL DTRSM('Right','Lower','No transpose','Unit',N,JB,ONE,
     *                 WORK(J),LDWORK,A(1,J),LDA)
  100    CONTINUE
      END IF
C
C     Apply column interchanges.
C
      DO 120 J = N - 1, 1, -1
         JP = IPIV(J)
         IF (JP.NE.J) CALL DSWAP(N,A(1,J),1,A(1,JP),1)
  120 CONTINUE
C
      WORK(1) = IWS
      RETURN
C
C     End of F07AJF (DGETRI)
C
      END
      SUBROUTINE F07TJF(UPLO,DIAG,N,A,LDA,INFO)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C     .. Entry Points ..
      ENTRY             DTRTRI(UPLO,DIAG,N,A,LDA,INFO)
C
C  Purpose
C  =======
C
C  DTRTRI computes the inverse of a real upper or lower triangular
C  matrix A.
C
C  Arguments
C  =========
C
C  UPLO    (input) CHARACTER*1
C          Specifies whether the matrix A is upper or lower triangular.
C          = 'U':  Upper triangular
C          = 'L':  Lower triangular
C
C  DIAG    (input) CHARACTER*1
C          Specifies whether or not the matrix A is unit triangular.
C          = 'N':  Non-unit triangular
C          = 'U':  Unit triangular
C
C  N       (input) INTEGER
C          The order of the matrix A.  N >= 0.
C
C  A       (input/output) REAL array, dimension (LDA,N)
C          On entry, the triangular matrix A.  If UPLO = 'U', the
C          leading n by n upper triangular part of the array A contains
C          the upper triangular matrix, and the strictly lower
C          triangular part of A is not referenced.  If UPLO = 'L', the
C          leading n by n lower triangular part of the array A contains
C          the lower triangular matrix, and the strictly upper
C          triangular part of A is not referenced.  If DIAG = 'U', the
C          diagonal elements of A are also not referenced and are
C          assumed to be 1.
C          On exit, the (triangular) inverse of the original matrix, in
C          the same storage format.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,N).
C
C  INFO    (output) INTEGER
C          = 0: successful exit
C          < 0: if INFO = -k, the k-th argument had an illegal value
C          > 0: if INFO = k, the k-th diagonal element of A is zero,
C               indicating that the matrix is singular and the inverse
C               has not been computed.
C
C  -- LAPACK routine (adapted for NAG Library)
C     Univ. of Tennessee, Oak Ridge National Lab, Argonne National Lab,
C     Courant Institute, NAG Ltd., and Rice University
C
C  =====================================================================
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO, ONE
      PARAMETER         (ZERO=0.0D+0,ONE=1.0D+0)
C     .. Scalar Arguments ..
      INTEGER           INFO, LDA, N
      CHARACTER         DIAG, UPLO
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*)
C     .. Local Scalars ..
      INTEGER           J, JB, NB, NN
      LOGICAL           NOUNIT, UPPER
C     .. External Subroutines ..
      EXTERNAL          F06AAZ, F07TJZ, F07ZAZ, DTRMM, DTRSM
C     .. Intrinsic Functions ..
      INTRINSIC         MAX, MIN
C     .. Executable Statements ..
C
C     Test the input parameters.
C
      INFO = 0
      UPPER = (UPLO.EQ.'U' .OR. UPLO.EQ.'u')
      NOUNIT = (DIAG.EQ.'N' .OR. DIAG.EQ.'n')
      IF ( .NOT. UPPER .AND. .NOT. (UPLO.EQ.'L' .OR. UPLO.EQ.'l')) THEN
         INFO = -1
      ELSE IF ( .NOT. NOUNIT .AND. .NOT. (DIAG.EQ.'U' .OR. DIAG.EQ.'u'))
     *         THEN
         INFO = -2
      ELSE IF (N.LT.0) THEN
         INFO = -3
      ELSE IF (LDA.LT.MAX(1,N)) THEN
         INFO = -5
      END IF
      IF (INFO.NE.0) THEN
         CALL F06AAZ('F07TJF/DTRTRI',-INFO)
         RETURN
      END IF
C
C     Quick return if possible
C
      IF (N.EQ.0) RETURN
C
C     Check for singularity.
C
      IF (NOUNIT) THEN
         DO 20 INFO = 1, N
            IF (A(INFO,INFO).EQ.ZERO) RETURN
   20    CONTINUE
      END IF
      INFO = 0
C
C     Determine the block size for this environment.
C
      CALL F07ZAZ(1,'F07TJF',NB,0)
      IF (NB.LE.1) NB = MAX(1,N)
C
      IF (UPPER) THEN
C
C        Compute inverse of upper triangular matrix
C
         DO 40 J = 1, N, NB
            JB = MIN(NB,N-J+1)
C
C           Compute rows 1:j-1 of current block column
C
            CALL DTRMM('Left','Upper','No transpose',DIAG,J-1,JB,ONE,A,
     *                 LDA,A(1,J),LDA)
            CALL DTRSM('Right','Upper','No transpose',DIAG,J-1,JB,-ONE,
     *                 A(J,J),LDA,A(1,J),LDA)
C
C           Compute inverse of current diagonal block
C
            CALL F07TJZ('Upper',DIAG,JB,A(J,J),LDA,INFO)
   40    CONTINUE
      ELSE
C
C        Compute inverse of lower triangular matrix
C
         NN = ((N-1)/NB)*NB + 1
         DO 60 J = NN, 1, -NB
            JB = MIN(NB,N-J+1)
            IF (J+JB.LE.N) THEN
C
C              Compute rows j+jb:n of current block column
C
               CALL DTRMM('Left','Lower','No transpose',DIAG,N-J-JB+1,
     *                    JB,ONE,A(J+JB,J+JB),LDA,A(J+JB,J),LDA)
               CALL DTRSM('Right','Lower','No transpose',DIAG,N-J-JB+1,
     *                    JB,-ONE,A(J,J),LDA,A(J+JB,J),LDA)
            END IF
C
C           Compute inverse of current diagonal block
C
            CALL F07TJZ('Lower',DIAG,JB,A(J,J),LDA,INFO)
   60    CONTINUE
      END IF
C
      RETURN
C
C     End of F07TJF (DTRTRI)
C
      END
      SUBROUTINE F07TJZ(UPLO,DIAG,N,A,LDA,INFO)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C     ENTRY             DTRTI2(UPLO,DIAG,N,A,LDA,INFO)
C
C  Purpose
C  =======
C
C  DTRTI2 computes the inverse of a real upper or lower triangular
C  matrix A.
C
C  Arguments
C  =========
C
C  UPLO    (input) CHARACTER*1
C          Specifies whether the matrix A is upper or lower triangular.
C          = 'U':  Upper triangular
C          = 'L':  Lower triangular
C
C  DIAG    (input) CHARACTER*1
C          Specifies whether or not the matrix A is unit triangular.
C          = 'N':  Non-unit triangular
C          = 'U':  Unit triangular
C
C  N       (input) INTEGER
C          The order of the matrix A.  N >= 0.
C
C  A       (input/output) REAL array, dimension (LDA,N)
C          On entry, the triangular matrix A.  If UPLO = 'U', the
C          leading n by n upper triangular part of the array A contains
C          the upper triangular matrix, and the strictly lower
C          triangular part of A is not referenced.  If UPLO = 'L', the
C          leading n by n lower triangular part of the array A contains
C          the lower triangular matrix, and the strictly upper
C          triangular part of A is not referenced.  If DIAG = 'U', the
C          diagonal elements of A are also not referenced and are
C          assumed to be 1.
C          On exit, the (triangular) inverse of the original matrix, in
C          the same storage format.
C
C  LDA     (input) INTEGER
C          The leading dimension of the array A.  LDA >= max(1,N).
C
C  INFO    (output) INTEGER
C          = 0: successful exit
C          < 0: if INFO = -k, the k-th argument had an illegal value
C          > 0: if INFO = k, the k-th diagonal element of A is zero,
C               indicating that the matrix is singular and the inverse
C               has not been computed.
C
C  -- LAPACK routine (adapted for NAG Library)
C     Univ. of Tennessee, Oak Ridge National Lab, Argonne National Lab,
C     Courant Institute, NAG Ltd., and Rice University
C
C  =====================================================================
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO, ONE
      PARAMETER         (ZERO=0.0D+0,ONE=1.0D+0)
C     .. Scalar Arguments ..
      INTEGER           INFO, LDA, N
      CHARACTER         DIAG, UPLO
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LDA,*)
C     .. Local Scalars ..
      DOUBLE PRECISION  AJJ
      INTEGER           J
      LOGICAL           NOUNIT, UPPER
C     .. External Subroutines ..
      EXTERNAL          F06AAZ, DSCAL, DTRMV
C     .. Intrinsic Functions ..
      INTRINSIC         MAX
C     .. Executable Statements ..
C
C     Test the input parameters.
C
      INFO = 0
      UPPER = (UPLO.EQ.'U' .OR. UPLO.EQ.'u')
      NOUNIT = (DIAG.EQ.'N' .OR. DIAG.EQ.'n')
      IF ( .NOT. UPPER .AND. .NOT. (UPLO.EQ.'L' .OR. UPLO.EQ.'l')) THEN
         INFO = -1
      ELSE IF ( .NOT. NOUNIT .AND. .NOT. (DIAG.EQ.'U' .OR. DIAG.EQ.'u'))
     *         THEN
         INFO = -2
      ELSE IF (N.LT.0) THEN
         INFO = -3
      ELSE IF (LDA.LT.MAX(1,N)) THEN
         INFO = -5
      END IF
      IF (INFO.NE.0) THEN
         CALL F06AAZ('F07TJZ/DTRTI2',-INFO)
         RETURN
      END IF
C
C     Check for singularity.
C
      IF (NOUNIT) THEN
         DO 20 INFO = 1, N
            IF (A(INFO,INFO).EQ.ZERO) RETURN
   20    CONTINUE
      END IF
      INFO = 0
C
      IF (UPPER) THEN
C
C        Compute inverse of upper triangular matrix.
C
         DO 40 J = 1, N
            IF (NOUNIT) THEN
               A(J,J) = ONE/A(J,J)
               AJJ = -A(J,J)
            ELSE
               AJJ = -ONE
            END IF
C
C           Compute elements 1:j-1 of j-th column.
C
            CALL DTRMV('Upper','No transpose',DIAG,J-1,A,LDA,A(1,J),1)
            CALL DSCAL(J-1,AJJ,A(1,J),1)
   40    CONTINUE
      ELSE
C
C        Compute inverse of lower triangular matrix.
C
         DO 60 J = N, 1, -1
            IF (NOUNIT) THEN
               A(J,J) = ONE/A(J,J)
               AJJ = -A(J,J)
            ELSE
               AJJ = -ONE
            END IF
            IF (J.LT.N) THEN
C
C              Compute elements j+1:n of j-th column.
C
               CALL DTRMV('Lower','No transpose',DIAG,N-J,A(J+1,J+1),
     *                    LDA,A(J+1,J),1)
               CALL DSCAL(N-J,AJJ,A(J+1,J),1)
            END IF
   60    CONTINUE
      END IF
C
      RETURN
C
C     End of F07TJZ (DTRTI2)
C
      END
      INTEGER FUNCTION F07ZAY(NAME)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C     MARK 16 RE-ISSUE. NAG COPYRIGHT 1993.
C
C     F07ZAY returns a unique positive integer code
C     corresponding to a six-letter NAG routine name
C     given in NAME. If NAME is not recognised, 0 is
C     returned.
C
C     Modified at Mark 16 to allow calls from F08 routines.
C
C     .. Scalar Arguments ..
      CHARACTER*6             NAME
C     .. Local Scalars ..
      INTEGER                 J, K
      CHARACTER               NAME4, NAME5
      CHARACTER*3             NAME13
C     .. Executable Statements ..
C
      IF (NAME(3:3).EQ.'7' .OR. NAME(3:3).EQ.'8') THEN
         NAME13 = NAME(1:3)
         NAME4 = NAME(4:4)
         NAME5 = NAME(5:5)
      ELSE
         NAME13 = NAME(4:6)
         NAME4 = NAME(1:1)
         NAME5 = NAME(2:2)
      END IF
C
      IF (NAME13.EQ.'F07') THEN
C
         IF (NAME4.EQ.'A') THEN
            J = 0
         ELSE IF (NAME4.EQ.'B') THEN
            J = 1
         ELSE IF (NAME4.EQ.'F') THEN
            J = 2
         ELSE IF (NAME4.EQ.'H') THEN
            J = 3
         ELSE IF (NAME4.EQ.'M') THEN
            J = 4
         ELSE IF (NAME4.EQ.'N') THEN
            J = 5
         ELSE IF (NAME4.EQ.'T') THEN
            J = 6
         ELSE
            J = -1
         END IF
C
         IF (NAME5.EQ.'D') THEN
            K = 0
         ELSE IF (NAME5.EQ.'J') THEN
            K = 1
         ELSE IF (NAME5.EQ.'R') THEN
            K = 2
         ELSE IF (NAME5.EQ.'W') THEN
            K = 3
         ELSE
            K = -1
         END IF
C
         IF (J.LT.0 .OR. K.LT.0) THEN
            F07ZAY = 0
         ELSE
C           F07ZAY is in the range 1-28 for F07 routines.
            F07ZAY = 1 + 4*J + K
         END IF
C
      ELSE IF (NAME13.EQ.'F08') THEN
C
         IF (NAME4.EQ.'A') THEN
            J = 0
         ELSE IF (NAME4.EQ.'C') THEN
            J = 1
         ELSE IF (NAME4.EQ.'F') THEN
            J = 2
         ELSE IF (NAME4.EQ.'J') THEN
            J = 3
         ELSE IF (NAME4.EQ.'K') THEN
            J = 4
         ELSE IF (NAME4.EQ.'N') THEN
            J = 5
         ELSE IF (NAME4.EQ.'P') THEN
            J = 6
         ELSE IF (NAME4.EQ.'S') THEN
            J = 7
         ELSE
            J = -1
         END IF
C
         IF (NAME5.EQ.'E') THEN
            K = 0
         ELSE IF (NAME5.EQ.'F') THEN
            K = 1
         ELSE IF (NAME5.EQ.'G') THEN
            K = 2
         ELSE IF (NAME5.EQ.'H') THEN
            K = 3
         ELSE IF (NAME5.EQ.'J') THEN
            K = 4
         ELSE IF (NAME5.EQ.'K') THEN
            K = 5
         ELSE IF (NAME5.EQ.'S') THEN
            K = 6
         ELSE IF (NAME5.EQ.'T') THEN
            K = 7
         ELSE IF (NAME5.EQ.'U') THEN
            K = 8
         ELSE IF (NAME5.EQ.'V') THEN
            K = 9
         ELSE IF (NAME5.EQ.'W') THEN
            K = 10
         ELSE IF (NAME5.EQ.'X') THEN
            K = 11
         ELSE
            K = -1
         END IF
C
         IF (J.LT.0 .OR. K.LT.0) THEN
            F07ZAY = 0
         ELSE
C           F07ZAY is in the range 29-124 for F08 routines.
            F07ZAY = 29 + 12*J + K
         END IF
C
      ELSE
         F07ZAY = 0
      END IF
C
      RETURN
C
      END
      SUBROUTINE F07ZAZ(ISPEC,NAME,IVAL,RWFLAG)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C     MARK 16 RE-ISSUE. NAG COPYRIGHT 1993.
C     MARK 17 RE-ISSUE. NAG COPYRIGHT 1995.
C
C     File f07zazt.f
C     Creation date: <Dec 7, 1991 11:28:04 mick>
C        Time-stamp: <May 23, 1995 08:36:54 mick>
C
C     This version is consistent with code produced by GENZAZ.
C
C     Modified at Mark 16 to allow calls from F08
C     routines.
C     Modified at Mark 17 for four new F08 routines.
C
C  -- NAG version of LAPACK auxiliary routine ILAENV
C
C  This is an unimplemented but functional version
C  of F07ZAZ, which returns the value 1 in IVAL for
C  all calls with RWFLAG = 0 and ISPEC/NAME
C  combinations which will be used by the Fortran
C  Library.
C
C  The parameter MAXIC is set to the largest value
C  that can be returned by F07ZAY. NCODES is the
C  number of Fortran Library routines that are
C  expected to call F07ZAZ. NSPECS is the number
C  of values that ISPEC can take.
C
C  Purpose
C  =======
C
C  F07ZAZ sets or returns problem-dependent
C  parameters for the local environment. See
C  ISPEC for a description of the parameters.
C
C  The problem-dependent parameters are contained
C  in the integer array IPARMS, and the value with
C  index ISPEC is set or copied to IVAL.
C
C  Arguments
C  =========
C
C  ISPEC (input) INTEGER
C     Specifies the parameter to be set or
C     returned by F07ZAZ.
C     = 1: the optimal blocksize; if this value
C          is 1, an unblocked algorithm will give
C          the best performance.
C     = 2: the minimum block size for which the
C          block routine should be used; if the
C          usable block size is less than this
C          value, an unblocked routine should be
C          used.
C     = 3: the crossover point (in a block
C          routine, for N less than this value,
C          an unblocked routine should be used).
C     = 4: the number of shifts, used in the
C          nonsymmetric eigenvalue routines.
C     = 5: the minimum column dimension for
C          blocking to be used; rectangular
C          blocks must have dimension at least
C          k by m, where k is given by
C          F07ZAZ(2,...) and m by F07ZAZ(5,...).
C     = 6: the crossover point for the SVD (when
C          reducing an m by n matrix to bidiagonal
C          form, if max(m,n)/min(m,n) exceeds this
C          value, a QR factorization is used first
C          to reduce the matrix to a triangular
C          form).
C     = 7: the number of processors.
C     = 8: the crossover point for the multishift
C          QR and QZ methods for nonsymmetric
C          eigenvalue problems.
C
C  NAME  (input) CHARACTER*(*)
C     The name of the calling subroutine.
C
C  IVAL  (input/output) INTEGER
C     the value of the parameter set or returned.
C
C  FLAG  (input) INTEGER
C     = 0: F07ZAZ returns in IVAL the value of
C          the parameter specified by ISPEC.
C     = 1: F07ZAZ sets the parameter specified
C          by ISPEC to the value in IVAL.
C
C  ==============================================
C
C     .. Parameters ..
      INTEGER           NSPECS, NCODES, MAXIC
      PARAMETER         (NSPECS=8,NCODES=48,MAXIC=124)
C     .. Scalar Arguments ..
      INTEGER           ISPEC, IVAL, RWFLAG
      CHARACTER*(*)     NAME
C     .. Local Scalars ..
      INTEGER           I, ICODE
C     .. Local Arrays ..
      INTEGER           IPARMS(NSPECS,NCODES), POINT(0:MAXIC)
C     .. External Functions ..
      INTEGER           F07ZAY
      EXTERNAL          F07ZAY
C     .. Save statement ..
      SAVE              IPARMS
C     .. Data statements ..
      DATA              (IPARMS(I,1),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0, 0/
      DATA              (IPARMS(I,2),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0, 0/
      DATA              (IPARMS(I,3),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0, 0/
      DATA              (IPARMS(I,4),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0, 0/
      DATA              (IPARMS(I,5),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0, 0/
      DATA              (IPARMS(I,6),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0, 0/
      DATA              (IPARMS(I,7),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0, 0/
      DATA              (IPARMS(I,8),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0, 0/
      DATA              (IPARMS(I,9),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0, 0/
      DATA              (IPARMS(I,10),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,11),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,12),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,13),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,14),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,15),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,16),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,17),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,18),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,19),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,20),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,21),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,22),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,23),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,24),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,25),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,26),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,27),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,28),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,29),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,30),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,31),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,32),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,33),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,34),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,35),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,36),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,37),I=1,NSPECS)/1, 1, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,38),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,39),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,40),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,41),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,42),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,43),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,44),I=1,NSPECS)/1, 1, 1, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,45),I=1,NSPECS)/0, 0, 0, 1, 0, 0, 0,
     *                  1/
      DATA              (IPARMS(I,46),I=1,NSPECS)/0, 0, 0, 1, 0, 0, 0,
     *                  1/
      DATA              (IPARMS(I,47),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0,
     *                  0/
      DATA              (IPARMS(I,48),I=1,NSPECS)/1, 0, 0, 0, 0, 0, 0,
     *                  0/
      DATA              POINT/0, 1, 2, 3, 4, 5, 0, 6, 0, 7, 8, 9, 10,
     *                  11, 0, 12, 0, 13, 0, 14, 0, 0, 0, 15, 0, 0, 16,
     *                  0, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
     *                  28, 29, 0, 30, 31, 32, 0, 33, 0, 34, 35, 36, 0,
     *                  37, 38, 0, 0, 0, 0, 0, 39, 0, 0, 0, 0, 0, 0, 0, 
     *                  0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 
     *                  0, 42, 0, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 44, 0, 
     *                  0, 0, 0, 0, 45, 0, 0, 0, 0, 0, 46, 0, 0, 0, 0, 
     *                  0, 47, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0/
C     .. Executable Statements ..
C
C     Convert the NAG name to an integer code.
      ICODE = POINT(F07ZAY(NAME))
C
      IF (ISPEC.LT.1 .OR. ISPEC.GT.NSPECS) THEN
C        Invalid value for ISPEC
         IVAL = -1
      ELSE IF (ICODE.EQ.0) THEN
C        Invalid value for NAME
         IVAL = -2
      ELSE IF (RWFLAG.EQ.0) THEN
C        Read the value of a parameter
         IVAL = IPARMS(ISPEC,ICODE)
      ELSE
C        Set the value of a parameter
         IPARMS(ISPEC,ICODE) = IVAL
      END IF
C
      RETURN
C
C     End of F07ZAZ
C
      END
      SUBROUTINE F08HEW(F,G,CS,SN,R)
C     MARK 16 RELEASE. NAG COPYRIGHT 1992.
C     ENTRY             DLARTG(F,G,CS,SN,R)
C
C  Purpose
C  =======
C
C  DLARTG generate a plane rotation so that
C
C     [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
C     [ -SN  CS  ]     [ G ]     [ 0 ]
C
C  This is a faster version of the BLAS1 routine DROTG, except for
C  the following differences:
C     F and G are unchanged on return.
C     If G=0, then CS=1 and SN=0.
C     If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
C        floating point operations (saves work in DBDSQR when
C        there are zeros on the diagonal).
C
C  Arguments
C  =========
C
C  F       (input) DOUBLE PRECISION
C          The first component of vector to be rotated.
C
C  G       (input) DOUBLE PRECISION
C          The second component of vector to be rotated.
C
C  CS      (output) DOUBLE PRECISION
C          The cosine of the rotation.
C
C  SN      (output) DOUBLE PRECISION
C          The sine of the rotation.
C
C  R       (output) DOUBLE PRECISION
C          The nonzero component of the rotated vector.
C
C  -- LAPACK auxiliary routine (adapted for NAG Library)
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO
      PARAMETER         (ZERO=0.0D0)
      DOUBLE PRECISION  ONE
      PARAMETER         (ONE=1.0D0)
C     .. Scalar Arguments ..
      DOUBLE PRECISION  CS, F, G, R, SN
C     .. Local Scalars ..
      DOUBLE PRECISION  T, TT
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, SQRT
C     .. Executable Statements ..
C
      IF (G.EQ.ZERO) THEN
         CS = ONE
         SN = ZERO
         R = F
      ELSE IF (F.EQ.ZERO) THEN
         CS = ZERO
         SN = ONE
         R = G
      ELSE
         IF (ABS(F).GT.ABS(G)) THEN
            T = G/F
            TT = SQRT(ONE+T*T)
            CS = ONE/TT
            SN = T*CS
            R = F*TT
         ELSE
            T = F/G
            TT = SQRT(ONE+T*T)
            SN = ONE/TT
            CS = T*SN
            R = G*TT
         END IF
      END IF
      RETURN
C
C     End of F08HEW (DLARTG)
C
      END
      SUBROUTINE G05CAY(REINIT)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C
C     called by G05CAF, G05FAF, G05FBF or G05FDF when needed, to fill
C     the internal array RV in COMMON block CG05CA with new
C     pseudo-random numbers.
C
C     G05CAY uses a multiplicative congruential algorithm
C
C     N := N * 13**13 modulo 2**59
C
C     where N is a notional variable internal to G05CAY. The value of N
C     is converted to a real number in the range 0.0 to 1.0 by scaling
C     by 2**(-59), with care taken that the result lies strictly
C     between 0.0 and 1.0.
C
C     N is initially set to 123456789*(2**32+1) but can be changed
C     by a call to G05CBF or G05CCF.
C
C     G05CAY generates number 63 at a time, in order to achieve
C     efficiency on vector-processing machines. The first call of
C     G05CAY generates 63 consecutive values of N, N(i), i = 1,...,63.
C     Subsequent calls generate the next set of 63 values of N by
C
C     N(i) := N(i) * (13**13)**63 modulo 2**59, for i = 1,...,63.
C
C     The value 63 is defined as the symbol LV in a parameter statement
C     in each routine which needs it. The particular value 63 was
C     chosen because of special properties of the multiplier
C     (13**13)**63 modulo 2**59, which permit efficient multi-length
C     arithmetic when ILIM = 4 (see below). Only a few values of LV
C     have such properties.
C
C     ******************** ADVICE FOR IMPLEMENTORS *********************
C
C     These notes are intended to guide implementors through the text
C     changes necessary to implement the basic random number generator
C     routines G05CAY, G05CAZ, G05CBF, G05CCF, G05CFZ, G05CGZ. Please
C     follow these guidelines, and consult NAG Central Office if in any
C     doubt or difficulty. Please send a listing of your final text for
C     these routines to Central Office.
C
C     1.  Read "DETAILS-NOTE-1" below.
C         Decide the relevant value of ILIM, say nn, taking account of
C         the suggestion for 'long' integers.
C
C     2.  Activate all lines beginning CAnn.
C
C     3.  Read "DETAILS-NOTE-2" below.
C         Check whether your compiler has the functions ISHFT and IAND
C         (or equivalent functions) and compiles inline code for them.
C
C     4.  If ISHFT and IAND or equivalent functions are available as
C         inline functions, activate all lines beginning CYnn. If
C         necessary, change the function names. Otherwise activate all
C         lines beginning CXnn.
C
C     ******************************************************************
C
C     ************************ DETAILS-NOTE-1 **************************
C
C     The algorithm requires that the values of N and of the multi-
C     plier 13**13 be stored as 59-bit unsigned integers and that
C     the least significant 59 bits of their product be computed. On
C     most machines this can be done much more efficiently in
C     machine code than in Fortran. The Fortran code given here is
C     intended to give guidance on a machine code implementation,
C     and to provide a less efficient implementation as a fall-back.
C
C     The 59-bit integer N is stored as a multiple-length integer in
C     the array B. In fact for convenience the 60-bit integer 2*N is
C     stored. The multiplier 13**13 is stored in the array M.
C     The multiplier (13**13)**63 modulo 2**59 is stored in the array
C     MLV in exactly the same way as the basic multiplier is stored in
C     the array M.
C
C     The number of elements in N and M (ILIM) and the number of bits
C     used in each element of N and M (IBITS) depend on the number
C     of bits (including sign) in an integer variable as follows -
C
C        ILIM     IBITS     number of bits in integer variable
C          4        15                 .ge. 32
C          3        20                 .ge. 41
C          2        30                 .ge. 60
C
C     For greatest efficiency ILIM should be chosen as small as
C     possible.
C
C     N.B. the most significant bits of N are stored in B(I,ILIM),
C     the next most significant bits in B(I,ILIM-1), . . . , and
C     the least significant bits in B(I,1). The multiplier is stored
C     in M(ILIM), M(ILIM-1), . . . , M(1) in the same way.
C
C     Note -
C
C     1) in the above table the value of IBITS is less than half the
C     number of bits in an integer variable. This ensures that the
C     necessary integer products can be formed and summed correctly
C     without integer overflow. However many machines have instruc-
C     tions for forming double-length integer products. A machine
C     code implementation can take advantage of this and allow IBITS
C     to be as large (or almost as large) as the number of bits in
C     an integer variable and ILIM to be correspondingly smaller.
C     This should be much more efficient.
C
C     2) the figures in the rightmost column in the above table are
C     correct for the specific value of the multiplier. They are
C     certainly not correct for arbitrary 60-bit arithmetic.
C
C     3) it may well be advantageous to use 'long' integers, if
C     available, within G05CAY, even if they are not used
C     elsewhere in the library.
C
C     Variant code for the array declarations and data statements
C     is supplied in comments beginning CAnn where the digits nn are
C     the value of ILIM.
C
C     ******************************************************************
C
C     .. Parameters ..
      INTEGER           LV
      PARAMETER         (LV=63)
      INTEGER           ILIM
      PARAMETER         (ILIM=4)
CA03  PARAMETER         (ILIM=3)
CA02  PARAMETER         (ILIM=2)
      DOUBLE PRECISION  ONE, R2
      PARAMETER         (ONE=1.0D0,R2=0.5D0)
      DOUBLE PRECISION  RP1, RP2
      PARAMETER         (RP1=R2**60,RP2=R2**30)
CA03  DOUBLE PRECISION  RP1, RP2
CA03  PARAMETER         (RP1=R2**60,RP2=R2**40)
CA02  DOUBLE PRECISION  RP1
CA02  PARAMETER         (RP1=R2**60)
C     .. Scalar Arguments ..
      LOGICAL           REINIT
C     .. Scalars in Common ..
      INTEGER           DEFOPT, OPTION, POSSOP, KV
C     .. Arrays in Common ..
      DOUBLE PRECISION  RV(LV)
      INTEGER           B(0:LV,ILIM)
C     .. Local Scalars ..
      DOUBLE PRECISION  ONEM
      INTEGER           I, T1, T2, T3, U, V
CX03  INTEGER           I, T1, T2, U, V
CX02  INTEGER           I, T1, U, V
CY04  INTEGER           I, T1, T2, T3, T4
CY03  INTEGER           I, T1, T2, T3
CY02  INTEGER           I, T1, T2
      LOGICAL           INIT
C     .. Local Arrays ..
      INTEGER           M(ILIM), MLV(ILIM)
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF
      EXTERNAL          X02AJF
C     .. Intrinsic Functions ..
      INTRINSIC         SIGN
C     .. Common blocks ..
      COMMON            /AG05CA/B, OPTION, POSSOP, DEFOPT
c$OMP THREADPRIVATE(/AG05CA/)
      COMMON            /CG05CA/RV, KV
c$OMP THREADPRIVATE(/CG05CA/)
C     .. Save statement ..
      SAVE              /AG05CA/, /CG05CA/, ONEM, INIT
C     .. Data statements ..
      DATA              INIT / .TRUE. /
      DATA              M /
     *                  17917, 13895, 19930,     8 /
CA03 *                  247293, 485810,    275 /
CA02 *                  455329277,    282074 /
      DATA              MLV /
     *                  85,  3703,  6070,  6822 /
CA03 *                  753749, 972915, 218309 /
CA02 *                  121339989, 223549366 /
C     .. Executable Statements ..
C
C     ************************ DETAILS-NOTE-2 **************************
C
C     It is advantageous to use non-standard Fortran intrinsic
C     functions for shifting and masking if these are available and if
C     they are compiled as in-line code without the overhead of a
C     subroutine call. Alternative code is given which uses the integer
C     functions:
C
C     ISHFT(I,J) to shift I J bits to the left (a negative value of
C                 J indicating a right shift)
C     IAND(I,J)  to form the logical and of I and J
C
C     It may be necesssary to replace these by calls to different
C     intrinsic functions provided by the fortran compiler.
C
C     Variant code for this computation is supplied in comments
C     beginning CXnn (using only arithmetic operations) or in
C     comments beginning CYnn (using shifting and masking functions)
C     where the digits nn are the value of ILIM.
C
C     ******************************************************************
C
      IF (INIT.OR.REINIT) THEN
         INIT = .FALSE.
         ONEM = ONE - X02AJF()
C
C        Generate first buffer of LV integers by multiplying
C        recursively by M modulo 2**59.
C        This loop cannot be vectorized.
C
         DO 20 I = 1, LV
            V = B(I-1,1)*M(1)
            U = V/32768
            B(I,1) = V - 32768*U
            V = U + B(I-1,2)*M(1) + B(I-1,1)*M(2)
            U = V/32768
            B(I,2) = V - 32768*U
            V = U + B(I-1,3)*M(1) + B(I-1,2)*M(2) + B(I-1,1)*M(3)
            U = V/32768
            B(I,3) = V - 32768*U
            V = U + B(I-1,4)*M(1) + B(I-1,3)*M(2) + B(I-1,2)*M(3)
     *            + B(I-1,1)*M(4)
            U = V/32768
            B(I,4) = V - 32768*U
CX03        V = B(I-1,1)*M(1)
CX03        U = V/1048576
CX03        B(I,1) = V - 1048576*U
CX03        V = U + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CX03        U = V/1048576
CX03        B(I,2) = V - 1048576*U
CX03        V = U + B(I-1,3)*M(1) + B(I-1,2)*M(2) + B(I-1,1)*M(3)
CX03        U = V/1048576
CX03        B(I,3) = V - 1048576*U
CX02        V = B(I-1,1)*M(1)
CX02        U = V/1073741824
CX02        B(I,1) = V - 1073741824*U
CX02        V = U + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CX02        U = V/1073741824
CX02        B(I,2) = V - 1073741824*U
CY04        T1 = B(I-1,1)*M(1)
CY04        T2 = ISHFT(T1,-15) + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CY04        T3 = ISHFT(T2,-15) + B(I-1,3)*M(1) + B(I-1,2)*M(2)
CY04 *                         + B(I-1,1)*M(3)
CY04        T4 = ISHFT(T3,-15) + B(I-1,4)*M(1) + B(I-1,3)*M(2)
CY04 *                         + B(I-1,2)*M(3) + B(I-1,1)*M(4)
CY04        B(I,4) = IAND(T4,32767)
CY04        B(I,3) = IAND(T3,32767)
CY04        B(I,2) = IAND(T2,32767)
CY04        B(I,1) = IAND(T1,32767)
CY03        T1 = B(I-1,1)*M(1)
CY03        T2 = ISHFT(T1,-20) + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CY03        T3 = ISHFT(T2,-20) + B(I-1,3)*M(1) + B(I-1,2)*M(2)
CY03 *                         + B(I-1,1)*M(3)
CY03        B(I,3) = IAND(T3,1048575)
CY03        B(I,2) = IAND(T2,1048575)
CY03        B(I,1) = IAND(T1,1048575)
CY02        T1 = B(I-1,1)*M(1)
CY02        T2 = ISHFT(T1,-30) + B(I-1,2)*M(1) + B(I-1,1)*M(2)
CY02        B(I,2) = IAND(T2,1073741823)
CY02        B(I,1) = IAND(T1,1073741823)
   20    CONTINUE
      ELSE
C
C        Generate next buffer of LV integers by multiplying in
C        parallel by M**LV modulo 2**59.
C
         DO 40 I = 1, LV
            V = B(I,1)*MLV(1)
            U = V/32768
            T1 = V - 32768*U
            V = U + B(I,2)*MLV(1) + B(I,1)*MLV(2)
            U = V/32768
            T2 = V - 32768*U
            V = U + B(I,3)*MLV(1) + B(I,2)*MLV(2) + B(I,1)*MLV(3)
            U = V/32768
            T3 = V - 32768*U
            V = U + B(I,4)*MLV(1) + B(I,3)*MLV(2) + B(I,2)*MLV(3)
     *            + B(I,1)*MLV(4)
            U = V/32768
            B(I,4) = V - 32768*U
            B(I,3) = T3
            B(I,2) = T2
            B(I,1) = T1
CX03        V = B(I,1)*MLV(1)
CX03        U = V/1048576
CX03        T1 = V - 1048576*U
CX03        V = U + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CX03        U = V/1048576
CX03        T2 = V - 1048576*U
CX03        V = U + B(I,3)*MLV(1) + B(I,2)*MLV(2) + B(I,1)*MLV(3)
CX03        U = V/1048576
CX03        B(I,3) = V - 1048576*U
CX03        B(I,2) = T2
CX03        B(I,1) = T1
CX02        V = B(I,1)*MLV(1)
CX02        U = V/1073741824
CX02        T1 = V - 1073741824*U
CX02        V = U + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CX02        U = V/1073741824
CX02        B(I,2) = V - 1073741824*U
CX02        B(I,1) = T1
CY04        T1 = B(I,1)*MLV(1)
CY04        T2 = ISHFT(T1,-15) + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CY04        T3 = ISHFT(T2,-15) + B(I,3)*MLV(1) + B(I,2)*MLV(2)
CY04 *                         + B(I,1)*MLV(3)
CY04        T4 = ISHFT(T3,-15) + B(I,4)*MLV(1) + B(I,3)*MLV(2)
CY04 *                         + B(I,2)*MLV(3) + B(I,1)*MLV(4)
CY04        B(I,4) = IAND(T4,32767)
CY04        B(I,3) = IAND(T3,32767)
CY04        B(I,2) = IAND(T2,32767)
CY04        B(I,1) = IAND(T1,32767)
CY03        T1 = B(I,1)*MLV(1)
CY03        T2 = ISHFT(T1,-20) + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CY03        T3 = ISHFT(T2,-20) + B(I,3)*MLV(1) + B(I,2)*MLV(2)
CY03 *                         + B(I,1)*MLV(3)
CY03        B(I,3) = IAND(T3,1048575)
CY03        B(I,2) = IAND(T2,1048575)
CY03        B(I,1) = IAND(T1,1048575)
CY02        T1 = B(I,1)*MLV(1)
CY02        T2 = ISHFT(T1,-30) + B(I,2)*MLV(1) + B(I,1)*MLV(2)
CY02        B(I,2) = IAND(T2,1073741823)
CY02        B(I,1) = IAND(T1,1073741823)
   40    CONTINUE
      END IF
C
C     Convert integers in B to real numbers in (0.0,1.0) stored in RV.
C
      DO 60 I = 1, LV
         RV(I) = MIN(ONEM,(B(I,4)*32768+B(I,3))*RP2
     *                     +(B(I,2)*32768+B(I,1))*RP1)
CX03     RV(I) = MIN(ONEM,(B(I,3)*1048576+B(I,2))*RP2 + B(I,1)*RP1)
CX02     RV(I) = MIN(ONEM,(B(I,2)*1073741824+B(I,1))*RP1)
CY04     RV(I) = MIN(ONEM,(ISHFT(B(I,4),15)+B(I,3))*RP2
CY04 *                     +(ISHFT(B(I,2),15)+B(I,1))*RP1)
CY03     RV(I) = MIN(ONEM,(ISHFT(B(I,3),20)+B(I,2))*RP2 + B(I,1)*RP1)
CY02     RV(I) = MIN(ONEM,(ISHFT(B(I,2),30)+B(I,1))*RP1)
   60 CONTINUE
      KV = 0
C
      RETURN
      END
      SUBROUTINE G05CAZ(INIT)
C     MARK 14 RE-ISSUE. NAG COPYRIGHT 1989.
C
C     called by G05CAF, G05CBF, G05CCF, G05CFZ, G05CGZ, G05DGF, G05FAF,
C     G05FBF AND G05FDF to ensure that the contents of common blocks
C     /AG05CA/, /BG05CA/, /CG05CA/ and /DG05CA/ are initialized.
C
C     ******************** ADVICE FOR IMPLEMENTORS *********************
C
C     This version of G05CAZ must be used in conjunction with the
C     new auxiliary routine G05CAY which has been introduced at Mark 14.
C
C     These notes are intended to guide implementors through the text
C     changes necessary to implement the basic random number generator
C     routines G05CAY, G05CAZ, G05CBF, G05CCF, G05CFZ, G05CGZ. Please
C     follow these guidelines, and consult NAG Central Office if in any
C     doubt or difficulty. Please send a listing of your final text for
C     these routines to Central Office.
C
C     1.  Prepare code for G05CAY following guidelines supplied there.
C
C     2.  Read "DETAILS-NOTE-1" below.
C
C     3.  Activate all lines beginning CAnn, where nn is the value of
C         ILIM used in G05CAY.
C
C     ******************************************************************
C
C     ************************ DETAILS-NOTE-1 **************************
C
C     G05CAZ must be implemented consistently with G05CAY.
C
C     If G05CAY has been implemented simply by selecting suitable
C     variant code according to the value of ILIM, then a consistent
C     implementation of G05CAY may be obtained by using the variant
C     code supplied in comments beginning CAnn where the digits nn
C     are the value of ILIM.
C
C     If G05CAY has been implemented in machine code, it will still
C     be possible on many machines to implement G05CAZ in Fortran
C     and this will be satisfactory since it is not important for
C     G05CAZ to be particularly efficient. Essentially the code for
C     G05CAZ depends only on how the internal variable N is stored in
C     the array B in the common block /AG05CA/ and the code given
C     below should be applicable provided that N is stored in
C     accordance with a particular value of ILIM as defined in the
C     text of G05CAY.
C
C     ******************************************************************
C
C     .. Parameters ..
      INTEGER           LV
      PARAMETER         (LV=63)
      INTEGER           ILIM
      PARAMETER         (ILIM=4)
CA03  PARAMETER         (ILIM=3)
CA02  PARAMETER         (ILIM=2)
C     .. Scalar Arguments ..
      LOGICAL           INIT
C     .. Scalars in Common ..
      DOUBLE PRECISION  GAMMA, NORMAL, VNORML
      INTEGER           DEFOPT, OPTION, POSSOP
C     .. Arrays in Common ..
      INTEGER           B(0:LV,ILIM)
C     .. Local Scalars ..
      LOGICAL           INIT2
C     .. External Subroutines ..
      EXTERNAL          G05CAY
C     .. Common blocks ..
      COMMON            /AG05CA/B, OPTION, POSSOP, DEFOPT
c$OMP THREADPRIVATE(/AG05CA/)
      COMMON            /BG05CA/NORMAL, GAMMA
c$OMP THREADPRIVATE(/BG05CA/)
      COMMON            /DG05CA/VNORML
c$OMP THREADPRIVATE(/DG05CA/)
C     .. Save statement ..
      SAVE              INIT2, /AG05CA/, /BG05CA/, /DG05CA/
C     .. Data statements ..
      DATA              INIT2/.TRUE./
C     .. Executable Statements ..
C
C     If INIT2 is not already .FALSE. , initialize /AG05CA/, /BG05CA/
C     and /DG05CA/ and set INIT2 to .FALSE.
C
      IF (INIT2) THEN
C
         B(0,1) =  6698
         B(0,2) =  7535
         B(0,3) = 26792
         B(0,4) = 30140
CA03     B(0,1) = 498218
CA03     B(0,2) = 172267
CA03     B(0,3) = 964506
CA02     B(0,1) = 246913578
CA02     B(0,2) = 987654312
         OPTION = 0
         DEFOPT = 0
         POSSOP = 0
C
         NORMAL = 1.0D0
         GAMMA = -1.0D0
         VNORML = 256.0D0
C
         INIT2 = .FALSE.
C
C        Initialize the buffer
C
         CALL G05CAY(.TRUE.)
      END IF
C
C     Set INIT to .FALSE. in any case
C
      INIT = .FALSE.
C
      RETURN
      END
      SUBROUTINE G05CBF(I)
C     MARK 14 RE-ISSUE. NAG COPYRIGHT 1989.
C
C     initializes the internal variables used by the generator
C     routines to produce a repeatable sequence
C
C     G05CBF initializes the notional internal variable N in G05CAY
C     to 2*ABS(I)+1 and then calls G05CAY to fill the buffer with the
C     next LV pseudo-random numbers.
C
C     G05CBF also re-initializes the varibles NORMAL, GAMMA and VNORML
C     which are used by G05DDF, G05DGF and G05FDF respectively.
C
C     ******************** ADVICE FOR IMPLEMENTORS *********************
C
C     This version of G05CBF must be used in conjunction with the
C     new auxiliary routine G05CAY which has been introduced at Mark 14.
C
C     These notes are intended to guide implementors through the text
C     changes necessary to implement the basic random number generator
C     routines G05CAY, G05CAZ, G05CBF, G05CCF, G05CFZ, G05CGZ. Please
C     follow these guidelines, and consult NAG Central Office if in any
C     doubt or difficulty. Please send a listing of your final text for
C     these routines to Central Office.
C
C     1.  Prepare code for G05CAY following guidelines supplied there.
C
C     2.  Read "DETAILS-NOTE-1" below.
C
C     3.  Activate all lines beginning CAnn, where nn is the value of
C         ILIM used in G05CAY.
C
C     ******************************************************************
C
C     ************************ DETAILS-NOTE-1 **************************
C
C     G05CBF must be implemented consistently with G05CAY.
C
C     If G05CAY has been implemented simply by selecting suitable
C     variant code according to the value of ILIM, then a consistent
C     implementation of G05CBF may be obtained by using the variant
C     code supplied in comments beginning CAnn where the digits nn
C     are the value of ILIM.
C
C     If G05CAY has been implemented in machine code, it will still
C     be possible on many machines to implement G05CBF in Fortran
C     and this will be satisfactory since it is not important for
C     G05CBF to be particularly efficient. Essentially the code for
C     G05CBF depends only on how the internal variable N is stored in
C     the array B in the common block /AG05CA/ and the code given
C     below should be applicable provided that N is stored in
C     accordance with a particular value of ILIM as defined in the
C     text of G05CAY.
C
C     ******************************************************************
C
C     .. Parameters ..
      INTEGER           LV
      PARAMETER         (LV=63)
      INTEGER           ILIM
      PARAMETER         (ILIM=4)
CA03  PARAMETER         (ILIM=3)
CA02  PARAMETER         (ILIM=2)
      INTEGER           IPW2, IPW2A
      PARAMETER         (IPW2=2**(60/ILIM),IPW2A=IPW2/4)
C     .. Scalar Arguments ..
      INTEGER           I
C     .. Scalars in Common ..
      DOUBLE PRECISION  GAMMA, NORMAL, VNORML
      INTEGER           DEFOPT, OPTION, POSSOP, KV
C     .. Arrays in Common ..
      DOUBLE PRECISION  RV(LV)
      INTEGER           B(0:LV,ILIM)
C     .. Local Scalars ..
      INTEGER           IA, IB, J
      LOGICAL           INIT
C     .. External Subroutines ..
      EXTERNAL          G05CAY, G05CAZ
C     .. Intrinsic Functions ..
      INTRINSIC         ABS
C     .. Common blocks ..
      COMMON            /AG05CA/B, OPTION, POSSOP, DEFOPT
c$OMP THREADPRIVATE(/AG05CA/)
      COMMON            /BG05CA/NORMAL, GAMMA
c$OMP THREADPRIVATE(/BG05CA/)
      COMMON            /CG05CA/RV, KV
c$OMP THREADPRIVATE(/CG05CA/)
      COMMON            /DG05CA/VNORML
c$OMP THREADPRIVATE(/DG05CA/)
C     .. Save statement ..
      SAVE              /AG05CA/, /BG05CA/, /CG05CA/, /DG05CA/
C     .. Executable Statements ..
C
C     Call G05CAZ to ensure that the initializations about to be
C     performed by G05CBF will not be overwritten by a subsequent
C     call t0 G05CAZ from G05CAY
C
      CALL G05CAZ(INIT)
C
C     Store 2*IABS(I)+1 in B(0,1:ILIM) as required by G05CAY
C
      IA = ABS(I)
      IB = IA/IPW2A
      B(0,1) = 4*(IA-IPW2A*IB) + 2
      DO 20 J = 2, ILIM
         IA = IB
         IB = IA/IPW2
         B(0,J) = IA - IPW2*IB
   20 CONTINUE
C
C     Re-initialize NORMAL, GAMMA and VNORML
C
      NORMAL = 1.0D0
      GAMMA = -1.0D0
      VNORML = 256.0D0
C
C     Re-initialize RV and set KV to skip first number
C
      CALL G05CAY(.TRUE.)
      KV = KV + 1
C
      RETURN
      END
      SUBROUTINE G05FAF(A,B,N,X)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C
C     Returns a vector of N pseudo-random numbers uniformly distributed
C     between A and B.
C
C     Pseudo-random numbers are generated by the auxiliary routine
C     G05CAY, 63 at a time, and stored in the array RV in common block
C     CG05CA. G05FAF copies numbers from the array RV into X,
C     transforming them to the interval (A, B), and calling G05CAY to
C     replenish RV when necessary.
C
C     A call of G05FAF returns the same sequence of pseudo-random
C     numbers as N consecutive calls to G05DAF.
C
C     Jeremy Du Croz, NAG Ltd, June 1989.
C
C     .. Parameters ..
      INTEGER           LV
      PARAMETER         (LV=63)
      DOUBLE PRECISION  ONE, ZERO
      PARAMETER         (ONE=1.0D0,ZERO=0.0D0)
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, B
      INTEGER           N
C     .. Array Arguments ..
      DOUBLE PRECISION  X(N)
C     .. Scalars in Common ..
      INTEGER           KV
C     .. Arrays in Common ..
      DOUBLE PRECISION  RV(LV)
C     .. Local Scalars ..
      DOUBLE PRECISION  Y, Z
      INTEGER           I, I1, I2, IV
      LOGICAL           INIT
C     .. External Subroutines ..
      EXTERNAL          G05CAY, G05CAZ
C     .. Intrinsic Functions ..
      INTRINSIC         MAX, MIN
C     .. Common blocks ..
      COMMON            /CG05CA/RV, KV
c$OMP THREADPRIVATE(/CG05CA/)
C     .. Save statement ..
      SAVE              /CG05CA/, INIT
C     .. Data statements ..
      DATA              INIT/.TRUE./
C     .. Executable Statements ..
      IF (N.LE.0) RETURN
      Y = MIN(A,B)
      Z = MAX(A,B)
C
C     Ensure that the basic generator has been initialized
C
      IF (INIT) CALL G05CAZ(INIT)
C
C     Replenish the buffer if necessary
C
      IF (KV.GE.LV) CALL G05CAY(.FALSE.)
C
C     Fill the array X in segments: I1 and I2 are indices of first and
C     last elements in current segment
C
      I1 = 1
      I2 = -KV
   20 CONTINUE
      I2 = MIN(I2+LV,N)
      IV = KV - I1 + 1
C
C     Generate values for the current segment of X. These loops should
C     be vectorizable; their length is at most LV.
C
      IF (Y.EQ.ZERO) THEN
CDIR$ SHORTLOOP
         DO 40 I = I1, I2
            X(I) = RV(I+IV)*Z
   40    CONTINUE
      ELSE IF (Z.EQ.ZERO) THEN
CDIR$ SHORTLOOP
         DO 60 I = I1, I2
            X(I) = (ONE-RV(I+IV))*Y
   60    CONTINUE
      ELSE
CDIR$ SHORTLOOP
         DO 80 I = I1, I2
            X(I) = MAX(Y,MIN(Z,Y*(ONE-RV(I+IV))+Z*RV(I+IV)))
   80    CONTINUE
      END IF
      KV = I2 + IV
C
      IF (I2.GE.N) RETURN
C
C     Replenish buffer and go back to generate next segment
C
      CALL G05CAY(.FALSE.)
      I1 = I2 + 1
      GO TO 20
      END
      INTEGER FUNCTION P01ABF(IFAIL,IERROR,SRNAME,NREC,REC)
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C     MARK 13 REVISED. IER-621 (APR 1988).
C     MARK 13B REVISED. IER-668 (AUG 1988).
C
C     P01ABF is the error-handling routine for the NAG Library.
C
C     P01ABF either returns the value of IERROR through the routine
C     name (soft failure), or terminates execution of the program
C     (hard failure). Diagnostic messages may be output.
C
C     If IERROR = 0 (successful exit from the calling routine),
C     the value 0 is returned through the routine name, and no
C     message is output
C
C     If IERROR is non-zero (abnormal exit from the calling routine),
C     the action taken depends on the value of IFAIL.
C
C     IFAIL =  1: soft failure, silent exit (i.e. no messages are
C                 output)
C     IFAIL = -1: soft failure, noisy exit (i.e. messages are output)
C     IFAIL =-13: soft failure, noisy exit but standard messages from
C                 P01ABF are suppressed
C     IFAIL =  0: hard failure, noisy exit
C
C     For compatibility with certain routines included before Mark 12
C     P01ABF also allows an alternative specification of IFAIL in which
C     it is regarded as a decimal integer with least significant digits
C     cba. Then
C
C     a = 0: hard failure  a = 1: soft failure
C     b = 0: silent exit   b = 1: noisy exit
C
C     except that hard failure now always implies a noisy exit.
C
C     S.Hammarling, M.P.Hooper and J.J.du Croz, NAG Central Office.
C
C     .. Scalar Arguments ..
      INTEGER                 IERROR, IFAIL, NREC
      CHARACTER*(*)           SRNAME
C     .. Array Arguments ..
      CHARACTER*(*)           REC(*)
C     .. Local Scalars ..
      INTEGER                 I, NERR
      CHARACTER*72            MESS
C     .. External Subroutines ..
      EXTERNAL                P01ABZ, X04AAF, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC               ABS, MOD
C     .. Executable Statements ..
      IF (IERROR.NE.0) THEN
C        Abnormal exit from calling routine
         IF (IFAIL.EQ.-1 .OR. IFAIL.EQ.0 .OR. IFAIL.EQ.-13 .OR.
     *       (IFAIL.GT.0 .AND. MOD(IFAIL/10,10).NE.0)) THEN
C           Noisy exit
            CALL X04AAF(0,NERR)
            DO 20 I = 1, NREC
               CALL X04BAF(NERR,REC(I))
   20       CONTINUE
            IF (IFAIL.NE.-13) THEN
               WRITE (MESS,FMT=99999) SRNAME, IERROR
               CALL X04BAF(NERR,MESS)
               IF (ABS(MOD(IFAIL,10)).NE.1) THEN
C                 Hard failure
                  CALL X04BAF(NERR,
     *                     ' ** NAG hard failure - execution terminated'
     *                        )
                  CALL P01ABZ
               ELSE
C                 Soft failure
                  CALL X04BAF(NERR,
     *                        ' ** NAG soft failure - control returned')
               END IF
            END IF
         END IF
      END IF
      P01ABF = IERROR
      RETURN
C
99999 FORMAT (' ** ABNORMAL EXIT from NAG Library routine ',A,': IFAIL',
     *  ' =',I6)
      END
      SUBROUTINE P01ABW(N,NAME,INFORM,IERR,SRNAME)
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     P01ABW increases the value of IERR by 1 and, if
C
C        ( mod( INFORM, 10 ).ne.1 ).or.( mod( INFORM/10, 10 ).ne.0 )
C
C     writes a message on the current error message channel giving the
C     value of N, a message to say that N is invalid and the strings
C     NAME and SRNAME.
C
C     NAME must be the name of the actual argument for N and SRNAME must
C     be the name of the calling routine.
C
C     This routine is intended for use when N is an invalid input
C     parameter to routine SRNAME. For example
C
C        IERR = 0
C        IF( N.NE.'Valid value' )
C     $     CALL P01ABW( N, 'N', IDIAG, IERR, SRNAME )
C
C  -- Written on 15-November-1984.
C     Sven Hammarling, Nag Central Office.
C
C     .. Scalar Arguments ..
      INTEGER           IERR, INFORM
      CHARACTER*(*)     N
      CHARACTER*(*)     NAME, SRNAME
C     .. Local Scalars ..
      INTEGER           NERR
C     .. Local Arrays ..
      CHARACTER*65      REC(3)
C     .. External Subroutines ..
      EXTERNAL          X04AAF, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC         MOD
C     .. Executable Statements ..
      IERR = IERR + 1
      IF ((MOD(INFORM,10).NE.1) .OR. (MOD(INFORM/10,10).NE.0)) THEN
         CALL X04AAF(0,NERR)
         WRITE (REC,FMT=99999) NAME, SRNAME, N
         CALL X04BAF(NERR,' ')
         CALL X04BAF(NERR,REC(1))
         CALL X04BAF(NERR,REC(2))
         CALL X04BAF(NERR,REC(3))
      END IF
      RETURN
C
C
C     End of P01ABW.
C
99999 FORMAT (' *****  Parameter  ',A,'  is invalid in routine  ',A,
     *  '  ***** ',/8X,'Value supplied is',/8X,A)
      END
      SUBROUTINE P01ABY(N,NAME,INFORM,IERR,SRNAME)
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     P01ABY increases the value of IERR by 1 and, if
C
C        ( mod( INFORM, 10 ).ne.1 ).or.( mod( INFORM/10, 10 ).ne.0 )
C
C     writes a message on the current error message channel giving the
C     value of N, a message to say that N is invalid and the strings
C     NAME and SRNAME.
C
C     NAME must be the name of the actual argument for N and SRNAME must
C     be the name of the calling routine.
C
C     This routine is intended for use when N is an invalid input
C     parameter to routine SRNAME. For example
C
C        IERR = 0
C        IF( N.LT.1 )CALL P01ABY( N, 'N', IDIAG, IERR, SRNAME )
C
C  -- Written on 23-February-1984.  Sven.
C
C     .. Scalar Arguments ..
      INTEGER           IERR, INFORM, N
      CHARACTER*(*)     NAME, SRNAME
C     .. Local Scalars ..
      INTEGER           NERR
C     .. Local Arrays ..
      CHARACTER*65      REC(2)
C     .. External Subroutines ..
      EXTERNAL          X04AAF, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC         MOD
C     .. Executable Statements ..
      IERR = IERR + 1
      IF ((MOD(INFORM,10).NE.1) .OR. (MOD(INFORM/10,10).NE.0)) THEN
         CALL X04AAF(0,NERR)
         WRITE (REC,FMT=99999) NAME, SRNAME, N
         CALL X04BAF(NERR,' ')
         CALL X04BAF(NERR,REC(1))
         CALL X04BAF(NERR,REC(2))
      END IF
      RETURN
C
C
C     End of P01ABY.
C
99999 FORMAT (' *****  Parameter  ',A,'  is invalid in routine  ',A,
     *  '  ***** ',/8X,'Value supplied is ',I6)
      END
      SUBROUTINE P01ABZ
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C
C     Terminates execution when a hard failure occurs.
C
C     ******************** IMPLEMENTATION NOTE ********************
C     The following STOP statement may be replaced by a call to an
C     implementation-dependent routine to display a message and/or
C     to abort the program.
C     *************************************************************
C     .. Executable Statements ..
      STOP
      END
      INTEGER FUNCTION P01ACF(IFAIL,IERROR,SRNAME,VARBNM,NREC,REC)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C
C     P01ACF is the error-handling routine for the F06 AND F07
C     Chapters of the NAG Fortran Library. It is a slightly modified
C     version of P01ABF.
C
C     P01ACF either returns the value of IERROR through the routine
C     name (soft failure), or terminates execution of the program
C     (hard failure). Diagnostic messages may be output.
C
C     If IERROR = 0 (successful exit from the calling routine),
C     the value 0 is returned through the routine name, and no
C     message is output
C
C     If IERROR is non-zero (abnormal exit from the calling routine),
C     the action taken depends on the value of IFAIL.
C
C     IFAIL =  1: soft failure, silent exit (i.e. no messages are
C                 output)
C     IFAIL = -1: soft failure, noisy exit (i.e. messages are output)
C     IFAIL =-13: soft failure, noisy exit but standard messages from
C                 P01ACF are suppressed
C     IFAIL =  0: hard failure, noisy exit
C
C     For compatibility with certain routines included before Mark 12
C     P01ACF also allows an alternative specification of IFAIL in which
C     it is regarded as a decimal integer with least significant digits
C     cba. Then
C
C     a = 0: hard failure  a = 1: soft failure
C     b = 0: silent exit   b = 1: noisy exit
C
C     except that hard failure now always implies a noisy exit.
C
C     S.Hammarling, M.P.Hooper and J.J.du Croz, NAG Central Office.
C
C     .. Scalar Arguments ..
      INTEGER                 IERROR, IFAIL, NREC
      CHARACTER*(*)           SRNAME, VARBNM
C     .. Array Arguments ..
      CHARACTER*(*)           REC(*)
C     .. Local Scalars ..
      INTEGER                 I, NERR, VARLEN
      CHARACTER*72            MESS
C     .. External Subroutines ..
      EXTERNAL                P01ABZ, X04AAF, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC               ABS, LEN, MOD
C     .. Executable Statements ..
      IF (IERROR.NE.0) THEN
         VARLEN = 0
         DO 20 I = LEN(VARBNM), 1, -1
            IF (VARBNM(I:I).NE.' ') THEN
               VARLEN = I
               GO TO 40
            END IF
   20    CONTINUE
   40    CONTINUE
C        Abnormal exit from calling routine
         IF (IFAIL.EQ.-1 .OR. IFAIL.EQ.0 .OR. IFAIL.EQ.-13 .OR.
     *       (IFAIL.GT.0 .AND. MOD(IFAIL/10,10).NE.0)) THEN
C           Noisy exit
            CALL X04AAF(0,NERR)
            DO 60 I = 1, NREC
               CALL X04BAF(NERR,REC(I))
   60       CONTINUE
            IF (IFAIL.NE.-13) THEN
               IF (VARLEN.NE.0) THEN
                  WRITE (MESS,FMT=99999) SRNAME, VARBNM(1:VARLEN),
     *              IERROR
               ELSE
                  WRITE (MESS,FMT=99998) SRNAME
               END IF
               CALL X04BAF(NERR,MESS)
               IF (ABS(MOD(IFAIL,10)).NE.1) THEN
C                 Hard failure
                  CALL X04BAF(NERR,
     *                     ' ** NAG hard failure - execution terminated'
     *                        )
                  CALL P01ABZ
               ELSE
C                 Soft failure
                  CALL X04BAF(NERR,
     *                        ' ** NAG soft failure - control returned')
               END IF
            END IF
         END IF
      END IF
      P01ACF = IERROR
      RETURN
C
99999 FORMAT (' ** ABNORMAL EXIT from NAG Library routine ',A,': ',A,
     *       ' =',I6)
99998 FORMAT (' ** ABNORMAL EXIT from NAG Library routine ',A)
      END
      DOUBLE PRECISION FUNCTION X01AAF(X)
C     MARK 8 RE-ISSUE. NAG COPYRIGHT 1980.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C
C     RETURNS THE VALUE OF THE MATHEMATICAL CONSTANT PI.
C
C     X IS A DUMMY ARGUMENT
C
C     IT MAY BE NECESSARY TO ROUND THE REAL CONSTANT IN THE
C     ASSIGNMENT STATEMENT TO A SMALLER NUMBER OF SIGNIFICANT
C     DIGITS IN ORDER TO AVOID COMPILATION PROBLEMS.  IF SO, THEN
C     THE NUMBER OF DIGITS RETAINED SHOULD NOT BE LESS THAN
C     .     2 + INT(FLOAT(IT)*ALOG10(IB))
C     WHERE  IB  IS THE BASE FOR THE REPRESENTATION OF FLOATING-
C     .             POINT NUMBERS
C     . AND  IT  IS THE NUMBER OF IB-ARY DIGITS IN THE MANTISSA OF
C     .             A FLOATING-POINT NUMBER.
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 X
C     .. Executable Statements ..
      X01AAF = 3.14159265358979323846264338328D0
      RETURN
      END
      DOUBLE PRECISION FUNCTION X02AJF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS  (1/2)*B**(1-P)  IF ROUNDS IS .TRUE.
C     RETURNS  B**(1-P)  OTHERWISE
C
      DOUBLE PRECISION X02CON
      DATA X02CON /Z'3CA0000000000001' /
C     .. Executable Statements ..
      X02AJF = X02CON
      RETURN
      END
      DOUBLE PRECISION FUNCTION X02AKF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS  B**(EMIN-1)  (THE SMALLEST POSITIVE MODEL NUMBER)
C
      DOUBLE PRECISION X02CON
      DATA X02CON /Z'0010000000000000' /
C     .. Executable Statements ..
      X02AKF = X02CON
      RETURN
      END
      DOUBLE PRECISION FUNCTION X02AMF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS THE 'SAFE RANGE' PARAMETER
C     I.E. THE SMALLEST POSITIVE MODEL NUMBER Z SUCH THAT
C     FOR ANY X WHICH SATISFIES X.GE.Z AND X.LE.1/Z
C     THE FOLLOWING CAN BE COMPUTED WITHOUT OVERFLOW, UNDERFLOW OR OTHER
C     ERROR
C
C        -X
C        1.0/X
C        SQRT(X)
C        LOG(X)
C        EXP(LOG(X))
C        Y**(LOG(X)/LOG(Y)) FOR ANY Y
C
      DOUBLE PRECISION X02CON
      DATA X02CON /Z'0010000000000000' /
C     .. Executable Statements ..
      X02AMF = X02CON
      RETURN
      END
      INTEGER FUNCTION X02BHF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS THE MODEL PARAMETER, B.
C
C     .. Executable Statements ..
      X02BHF =     2
      RETURN
      END
      INTEGER FUNCTION X02BKF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS THE MODEL PARAMETER, EMIN.
C
C     .. Executable Statements ..
      X02BKF =  -1021
      RETURN
      END
      INTEGER FUNCTION X02BLF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS THE MODEL PARAMETER, EMAX.
C
C     .. Executable Statements ..
      X02BLF =  1024
      RETURN
      END
      SUBROUTINE X04AAF(I,NERR)
C     MARK 7 RELEASE. NAG COPYRIGHT 1978
C     MARK 7C REVISED IER-190 (MAY 1979)
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 14 REVISED. IER-829 (DEC 1989).
C     IF I = 0, SETS NERR TO CURRENT ERROR MESSAGE UNIT NUMBER
C     (STORED IN NERR1).
C     IF I = 1, CHANGES CURRENT ERROR MESSAGE UNIT NUMBER TO
C     VALUE SPECIFIED BY NERR.
C
C     .. Scalar Arguments ..
      INTEGER           I, NERR
C     .. Local Scalars ..
      INTEGER           NERR1
C     .. Save statement ..
      SAVE              NERR1
C     .. Data statements ..
      DATA              NERR1/6/
C     .. Executable Statements ..
      IF (I.EQ.0) NERR = NERR1
      IF (I.EQ.1) NERR1 = NERR
      RETURN
      END
      SUBROUTINE X04BAF(NOUT,REC)
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C
C     X04BAF writes the contents of REC to the unit defined by NOUT.
C
C     Trailing blanks are not output, except that if REC is entirely
C     blank, a single blank character is output.
C     If NOUT.lt.0, i.e. if NOUT is not a valid Fortran unit identifier,
C     then no output occurs.
C
C     .. Scalar Arguments ..
      INTEGER           NOUT
      CHARACTER*(*)     REC
C     .. Local Scalars ..
      INTEGER           I
C     .. Intrinsic Functions ..
      INTRINSIC         LEN
C     .. Executable Statements ..
      IF (NOUT.GE.0) THEN
C        Remove trailing blanks
         DO 20 I = LEN(REC), 2, -1
            IF (REC(I:I).NE.' ') GO TO 40
   20    CONTINUE
C        Write record to external file
   40    WRITE (NOUT,FMT=99999) REC(1:I)
      END IF
      RETURN
C
99999 FORMAT (A)
      END
